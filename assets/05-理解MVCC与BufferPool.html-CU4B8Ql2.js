import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,a as i}from"./app-CHnnUJwX.js";const l="/myblog/assets/img/image-20231127163449-w9utnr1.png",r="/myblog/assets/img/image-20231127163529-wcwkk5a.png",n={},a=i('<h2 id="mvcc多版本控制机制" tabindex="-1"><a class="header-anchor" href="#mvcc多版本控制机制"><span>MVCC多版本控制机制</span></a></h2><p>MySql在可重复读的事务隔离机制下，如何保证事务较高的隔离级别，同样的查询语句在一个事务里如何做到查询相同的结果的，就算有其他事务对数据进行修改也不影响该事务内的查询结果。<br> 这个隔离性就是靠着<strong>MVCC(Multi-Version Concurrency Control)</strong> 机制来保证的，对同一行数据的读默认不加互斥锁来保证隔离性，避免的频繁加锁解锁带来的性能问题。MySql默认在可重复读和读已提交的事务隔离情况下都实现了MVCC</p><h3 id="undo日志版本链和read-veiw机制" tabindex="-1"><a class="header-anchor" href="#undo日志版本链和read-veiw机制"><span>undo日志版本链和read-veiw机制</span></a></h3><p>undo日志版本链是指一行数据被多个事务修改，在每个事务修改完之后，mysql会保留本次修改的数据到undo回滚日志，并且用两个字段trx_id和roll_pointer来记录本次修改的事务id和回滚的指针，其中回滚的指针指向修改前的数据。这样undo日志链可以将数据串联成一个历史版本链</p><p>​<img src="'+l+'" alt="image">​</p><p>一个事务开启后，<strong>当执行第一条sql语句时会生成read-view(一致性视图)</strong> ，该视图在事务结束前都不会改变(读已提交的隔离级别则在每次执行查询语句的时候重新生成read-view)</p><p>read-view由生成时仍在活跃的事务id(<strong>未提交的事务id</strong>)数组，和<strong>已创建的最大的事务id</strong>组成，其中未提交事务数组中最小的事务id为min_trx_ids，已创建的最大事务id为max_trx_ids，事务里的任何sql查询，都需要从undo日志链中的最新数据开始，逐一与read-view做比较，以得到最终结果。</p><h4 id="比对方式" tabindex="-1"><a class="header-anchor" href="#比对方式"><span>比对方式</span></a></h4><p>事务的sql查询时，会先从undo日志链中获取最新的一条数据，读取trx_id，然后与read-view比较：</p><ul><li><p>当 trx_id &lt; min_trx_ids时，表明该数据最后修改的事务id比生成的read-view中最小的事务id还小，表示是已经提交过的事务，数据可以展示。</p></li><li><p>当 trx_id &gt; max_trx_ids时，表明该数据最后修改的事务id比生成read-veiw时最大的事务id还大，表示这是未来事务提交的数据，数据不可展示。</p></li><li><p>当 min_trx_ids ≤ trx_id ≤ max_trx_ids 时，表明该数据落入read-veiw视图中，需进一步判断：</p><ul><li>当trx_id在read-veiw的活跃事务数组中时，则表明提交该数据的事务在生成视图时仍在活跃，数据不可以展示(当trx_id和当前事务id一致时，则表明是该事务提交的数据，此时可以展示)。</li><li>当trx_id不在read-veiw的活跃事务数组中时，则表明提交该数据的事务在生成视图时已经提交，数据可以展示。</li></ul></li><li><p>所有不可展示的条件，会再根据roll_pointer查找到上一个版本的数据，再根据规则进行比较，直到查找到可以展示的数据。</p></li></ul><p><strong>注意：begin/start transaction并不是一个事务的起点，这个时候mysql还没有分配事务id，只有当执行了修改innodb表的语句时，才真正启动事务，向mysql申请事务id，mysql内部是严格按照启动顺序来分配事务id的。</strong></p><h2 id="innodb引擎sql执行的bufferpool缓存机制" tabindex="-1"><a class="header-anchor" href="#innodb引擎sql执行的bufferpool缓存机制"><span><strong>Innodb引擎SQL执行的BufferPool缓存机制</strong></span></a></h2><p>​<img src="'+r+'" alt="image">​</p><ol><li>更新前，mysql会根据索引查找到相应数据，并将该数据所在的页，加载到BufferPool中；</li><li>更新前，mysql将更新数据的旧值写入undo日志，便于回滚；</li><li>mysql将BufferPool中的数据进行更新；</li><li>事务准备提交时，mysql将更新后数据写入readLog日志缓存中，readLog日志主要作用是在mysql启动时，恢复BufferPool中数据，保证数据一致性；</li><li>mysql将readLog日志缓存刷入磁盘；</li><li>事务准备提交时，mysql将更新后数据写入binlog日志，以便于恢复磁盘数据；</li><li>事务提交后，更新完binlog日志后，向readLog日志写入commit标志，保证readLog与binlog日志一致。</li><li>BufferPool的磁盘I/O会不定时将BufferPool中数据刷入磁盘相应数据。</li></ol><h3 id="设计原因" tabindex="-1"><a class="header-anchor" href="#设计原因"><span>设计原因</span></a></h3><p>因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据，性能可能相当差。磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。<br> Mysql这套机制看起来复杂，但它可以保证每个更新请求都是更新内存BufferPool，然后顺序写日志文件，同时还能保证各种异常情况下的数据一致性。<br> 更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干甚至上万的读写请求。</p>',16),s=[a];function d(p,m){return t(),o("div",null,s)}const u=e(n,[["render",d],["__file","05-理解MVCC与BufferPool.html.vue"]]),y=JSON.parse('{"path":"/statudy/Mysql/05-%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool.html","title":"05-理解MVCC与BufferPool","lang":"zh-CN","frontmatter":{"title":"05-理解MVCC与BufferPool","order":5,"date":"2024-04-15T00:00:00.000Z","category":["Mysql"],"tag":["Mysql"],"description":"MVCC多版本控制机制 MySql在可重复读的事务隔离机制下，如何保证事务较高的隔离级别，同样的查询语句在一个事务里如何做到查询相同的结果的，就算有其他事务对数据进行修改也不影响该事务内的查询结果。 这个隔离性就是靠着MVCC(Multi-Version Concurrency Control) 机制来保证的，对同一行数据的读默认不加互斥锁来保证隔离性...","head":[["meta",{"property":"og:url","content":"https://xsyl06.github.io/myblog/myblog/statudy/Mysql/05-%E7%90%86%E8%A7%A3MVCC%E4%B8%8EBufferPool.html"}],["meta",{"property":"og:site_name","content":"Xsyl06的博客"}],["meta",{"property":"og:title","content":"05-理解MVCC与BufferPool"}],["meta",{"property":"og:description","content":"MVCC多版本控制机制 MySql在可重复读的事务隔离机制下，如何保证事务较高的隔离级别，同样的查询语句在一个事务里如何做到查询相同的结果的，就算有其他事务对数据进行修改也不影响该事务内的查询结果。 这个隔离性就是靠着MVCC(Multi-Version Concurrency Control) 机制来保证的，对同一行数据的读默认不加互斥锁来保证隔离性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231127163449-w9utnr1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-16T10:28:03.000Z"}],["meta",{"property":"article:author","content":"xsyl06"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:published_time","content":"2024-04-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-16T10:28:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"05-理解MVCC与BufferPool\\",\\"image\\":[\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231127163449-w9utnr1.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231127163529-wcwkk5a.png\\"],\\"datePublished\\":\\"2024-04-15T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-16T10:28:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xsyl06\\",\\"url\\":\\"https://gitee.com/xsyl06\\"}]}"]]},"headers":[{"level":2,"title":"MVCC多版本控制机制","slug":"mvcc多版本控制机制","link":"#mvcc多版本控制机制","children":[{"level":3,"title":"undo日志版本链和read-veiw机制","slug":"undo日志版本链和read-veiw机制","link":"#undo日志版本链和read-veiw机制","children":[{"level":4,"title":"比对方式","slug":"比对方式","link":"#比对方式","children":[]}]}]},{"level":2,"title":"Innodb引擎SQL执行的BufferPool缓存机制","slug":"innodb引擎sql执行的bufferpool缓存机制","link":"#innodb引擎sql执行的bufferpool缓存机制","children":[{"level":3,"title":"设计原因","slug":"设计原因","link":"#设计原因","children":[]}]}],"git":{"createdTime":1713263283000,"updatedTime":1713263283000,"contributors":[{"name":"Wang","email":"xsyl06@qq.com","commits":1}]},"readingTime":{"minutes":4.44,"words":1331},"filePathRelative":"statudy/Mysql/05-理解MVCC与BufferPool.md","localizedDate":"2024年4月15日","excerpt":"<h2>MVCC多版本控制机制</h2>\\n<p>MySql在可重复读的事务隔离机制下，如何保证事务较高的隔离级别，同样的查询语句在一个事务里如何做到查询相同的结果的，就算有其他事务对数据进行修改也不影响该事务内的查询结果。<br>\\n这个隔离性就是靠着<strong>MVCC(Multi-Version Concurrency Control)</strong> 机制来保证的，对同一行数据的读默认不加互斥锁来保证隔离性，避免的频繁加锁解锁带来的性能问题。MySql默认在可重复读和读已提交的事务隔离情况下都实现了MVCC</p>\\n<h3>undo日志版本链和read-veiw机制</h3>\\n<p>undo日志版本链是指一行数据被多个事务修改，在每个事务修改完之后，mysql会保留本次修改的数据到undo回滚日志，并且用两个字段trx_id和roll_pointer来记录本次修改的事务id和回滚的指针，其中回滚的指针指向修改前的数据。这样undo日志链可以将数据串联成一个历史版本链</p>","autoDesc":true}');export{u as comp,y as data};
