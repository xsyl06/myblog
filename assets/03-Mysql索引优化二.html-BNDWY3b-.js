import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as a,a as e}from"./app-DdVJFwBG.js";const t="/myblog/assets/img/image-20231126212344-7jdcmhs.png",l="/myblog/assets/img/image-20231126213117-0bxxcpr.png",o="/myblog/assets/img/image-20231126213331-90d94ig.png",p="/myblog/assets/img/image-20231126213907-9ogaith.png",i="/myblog/assets/img/image-20231126214000-ig9ob0o.png",c="/myblog/assets/img/image-20231126214044-8dbv6c6.png",r={},d=e(`<h2 id="分页查询-limit-start-end" tabindex="-1"><a class="header-anchor" href="#分页查询-limit-start-end"><span>分页查询 limit start,end</span></a></h2><p>常见的mysql分页写法</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>limit 90000,10 这种写法，mysql会查询出90010条数据，然后将前面90000条数据丢弃，保留最后10条数据。</p><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h3><p>以下优化方式各有优缺点，需要根据业务需要灵活选择。</p><h4 id="当主键连续且自增-并且根据主键排序时" tabindex="-1"><a class="header-anchor" href="#当主键连续且自增-并且根据主键排序时"><span>当主键连续且自增，并且根据主键排序时</span></a></h4><p>可改写为以主键为条件，查询所需条数的写法。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">90000</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上条件在实际生产中一般不会出现，业务中删除操作可能会导致主键不连续，同时如果根据非主键排序，也会导致结果不准确。</p><h4 id="主键不连续" tabindex="-1"><a class="header-anchor" href="#主键不连续"><span>主键不连续</span></a></h4><p>当主键不连续时，还有一种一般以最初查询出的数据最后一条的某个字段(一般为创建时间)为条件，查询大于这个条件的后10条或后几条，写法如下</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> hire_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-04-28 06:34:28&#39;</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> hire_time<span class="token operator">&gt;</span><span class="token string">&#39;2022-05-05 03:00:23&#39;</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种写法也有缺陷，一是需要前端修改分页逻辑，该种查询，前端没有数据总数，需要查询比较靠后的数据需要一步一步点击。二是对where后面的条件也有要求，需要递增，且没有其他条件。</p><h4 id="根据非主键字段排序的分页" tabindex="-1"><a class="header-anchor" href="#根据非主键字段排序的分页"><span>根据非主键字段排序的分页</span></a></h4><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​<img src="`+t+`" alt="image">​</p><p>查看执行计划，该sql走了全表扫描，没有走索引，原因是：<strong>该sql语句需查询出非主键的字段，因此，如果走辅助索引，还涉及回表操作，同时因为要limit操作，mysql认为走索引效率不如全表扫描，选择了全表扫描，同时排序使用了文件排序(using filesort)。</strong></p><p>优化关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL改写如下。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees e <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> employees <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">90000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> t <span class="token keyword">on</span> t<span class="token punctuation">.</span>id<span class="token operator">=</span>e<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="join关联优化" tabindex="-1"><a class="header-anchor" href="#join关联优化"><span>join关联优化</span></a></h2><h3 id="nested-loop-join-嵌套循环连接-nlj" tabindex="-1"><a class="header-anchor" href="#nested-loop-join-嵌套循环连接-nlj"><span>Nested-Loop Join 嵌套循环连接(NLJ)</span></a></h3><p>一次一行的从第一张表(驱动表)中读取数据，并根据关联关系，去第二张表中关联相关数据，取出满足条件的行，然后取两张表的合集。</p><p>此种需要被关联的的关联关系建立了索引</p><p>如有t1表(a,b)有10000行数据，且a字段建立了索引；t2表(100)结构与t1表结构完全相同</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​<img src="`+l+`" alt="image">​</p><p>查看执行计划可以看到，t2小表为驱动表</p><ol><li>mysql先将小表的数据取出来(没有where条件，全表扫描)</li><li>然后将数据中a字段的值取出，到t1表中获取数据，因为关联关系在t1表中为索引，因此走索引查询出t1表中的数据。</li></ol><p>这种方式磁盘扫描了t2表100行，t1表100行，总共200行，效率还是比较高的。<br> 同时可以看到，mysql优化器会自动选择较小的表作为驱动表，因此inner join写在左边的表不一定是驱动表。</p><h3 id="block-nested-loop-join-基于块的嵌套循环连接-bnl" tabindex="-1"><a class="header-anchor" href="#block-nested-loop-join-基于块的嵌套循环连接-bnl"><span>Block-Nested-Loop Join 基于块的嵌套循环连接(BNL)</span></a></h3><p>当被驱动表关联关系字段没有建立索引时，mysql会使用基于块的嵌套循环连接(BNL)</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">inner</span> <span class="token keyword">join</span> t1 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​<img src="`+o+`" alt="image">​</p><p><strong>Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。</strong></p><ol><li>mysql会先将驱动表t2中的数据取出来存放到内存的join_buffer中。</li><li>mysql从被驱动表t1中取出每一行数据，与join_buffer中的t2表数据，根据关联关系进行关联。</li><li>返回满足join条件的数据。</li></ol><p>根据步骤，可以看到，在获取驱动表数据时mysql扫描了t2表数据100行，然后在比对过程中，需要全表扫描t1表10000行，即需要扫描10100次磁盘，同时在内存中的比对极限情况下可能需要执行100*10000=100万次。</p><h3 id="为什么不用嵌套循环连接-nlj-呢" tabindex="-1"><a class="header-anchor" href="#为什么不用嵌套循环连接-nlj-呢"><span><strong>为什么不用嵌套循环连接(NLJ)呢</strong></span></a></h3><p>根据NLJ步骤：</p><ol><li>从t2表取出一条数据</li><li>查询t1表，此时数据没有建立索引，因此mysql需要从头开始扫描B+树的所有叶子节点，根据关联关系获取数据，并将符合条件的数据返回。</li><li>重复上述过程。</li></ol><p>从过程中可以看到，t2表做全表扫描，扫描了100行数据，然后再扫描t1表，极限状态下每条数据在t1里扫描10000次；总共扫描磁盘100*10000=100万次，效率很低，因此mysql不选择NLJ。</p><p><strong>注意</strong>：join_buffer默认256K，由join_buffer_size参数进行设置。如果放不下t2表数据，mysql会进行切块，分多次存放(<strong>分段放</strong>)。比如join_buffer中可以存放80条数据，但t2表有100行，此时mysql会先放80条数据在join_buffer中，然后取t1数据进行比较；完成后，将join_buffer中数据删除，放剩下20行数据，再取t1数据进行比较。所以此时会多扫一次t1表。</p><h3 id="优化方法" tabindex="-1"><a class="header-anchor" href="#优化方法"><span>优化方法</span></a></h3><ol><li>被驱动表的关联字段添加索引，让mysql尽量走嵌套循环连接(NLJ)。</li><li>使用小表驱动大表。</li><li>根据阿里开发规范，join的表尽量不要超过三张。</li></ol><p>inner join通常情况下mysql执行引擎会优化挑选小表为驱动表，但也有可能会出现优化错误的情况，即数据量大的表为驱动表，此时可使用straight_join指定驱动表，类似如下写法</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 straight_join t1 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​<img src="`+p+`" alt="image">​</p><ol><li>straight_join方法只适用与inner join形式，left join和right join已经默认指定了驱动表。</li><li>尽量让mysql自己来选择驱动表，大部分情况下，程序判断的比人判断的要准确一些，同时straight_join要慎重使用，因为部分情况下，人为指定的顺序不一定比优化引擎靠谱。</li></ol><p><strong>驱动表的定义：</strong> 应该为两个表按各自条件过滤后，参与连接的数据，那个表参与连接的数据小，就是驱动表，而不是单纯只看表内的数据量。比如下面两个语句。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>a <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​<img src="`+i+`" alt="image">​</p><p>当两个表数据量接近</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>a <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a<span class="token operator">&lt;</span><span class="token number">80</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​<img src="`+c+`" alt="image">​</p><h2 id="in和exists" tabindex="-1"><a class="header-anchor" href="#in和exists"><span>in和exists</span></a></h2><p>原则：小表驱动大表</p><p>如果表b的数据集大小小于表a，in优先exists</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
基本等价于
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> b<span class="token punctuation">)</span>{
  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">where</span> a<span class="token punctuation">.</span>id<span class="token operator">=</span>b<span class="token punctuation">.</span>id
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当a表数据集小于b表时，exists优先in</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> b <span class="token keyword">where</span> b<span class="token punctuation">.</span>id<span class="token operator">=</span>a<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
等价于
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a<span class="token punctuation">)</span>{
  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> b <span class="token keyword">where</span> b<span class="token punctuation">.</span>id<span class="token operator">=</span>a<span class="token punctuation">.</span>id
}
a和b表连接字段需要添加索引
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>exists执行逻辑：</strong></p><ol><li>先查询出外面select * from a的数据</li><li>然后根据id关联查询b表中数据((select 1 from b where b.id=a.id)，如果在b表中存在，则保留(exists子句返回1)，否则不保留(exists子句返回0)。</li><li>语句返回结果</li></ol><h2 id="count-语句" tabindex="-1"><a class="header-anchor" href="#count-语句"><span>count()语句</span></a></h2><p><strong>以下语句执行效率：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看执行计划，可以看到其实计划都一样；</p><ul><li><p><strong>当有字段有索引时候的效率：count(*)≈count(1)&gt;count(索引字段)&gt;count(主键)</strong> 当字段有索引时候，辅助索引只保存了数据主键，索引树大小较小，效率比count(主键)高一点</p></li><li><p>当字段没有索引时候的效率：count(*)≈count(1)&gt;count(主键)&gt;count(字段)<br> 当字段没有索引时，mysql主要扫描聚簇索引，即count(主键)从叶子节点扫描，count(字段)需从磁盘加载数据到内存，效率较低。</p></li></ul><h3 id="count-1" tabindex="-1"><a class="header-anchor" href="#count-1"><span><strong>count(1)</strong></span></a></h3><p>count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出字段，所以理论上count(1)比count(字段)会快一点。</p><h3 id="count" tabindex="-1"><a class="header-anchor" href="#count"><span><strong>count(*)</strong></span></a></h3><p>count(<em>) 是例外，mysql并不会把全部字段取出来，而是专门做了优化，<strong>不取值，按行累加</strong>，效率很高，所以不需要用count(列名)或count(常量)来替代 count(</em>)。</p><h3 id="常见查询优化方法" tabindex="-1"><a class="header-anchor" href="#常见查询优化方法"><span><strong>常见查询优化方法</strong></span></a></h3><h4 id="查询mysql自己维护的总行数" tabindex="-1"><a class="header-anchor" href="#查询mysql自己维护的总行数"><span><strong>查询mysql自己维护的总行数</strong></span></a></h4><p>对于myisam不带where条件的总行数要求，count的性能很高，因为myisam存储引擎在存储数据时，会将表的总行数存储在磁盘上，直接读取即可，查询不需要计算。</p><h4 id="show-table-status" tabindex="-1"><a class="header-anchor" href="#show-table-status"><span><strong>show table status</strong></span></a></h4><p>如果只需要知道表的总行数估值，可以使用如下命令</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">table</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">&#39;tablename&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="将总数维护到缓存中如redis" tabindex="-1"><a class="header-anchor" href="#将总数维护到缓存中如redis"><span><strong>将总数维护到缓存中如redis</strong></span></a></h4><p>需要注意的是，插入或删除数据的时候需要同时维护该数据，且最好使用redis原子性增加或减少的方法。</p><h4 id="维护相应数据到数据库表中" tabindex="-1"><a class="header-anchor" href="#维护相应数据到数据库表中"><span><strong>维护相应数据到数据库表中</strong></span></a></h4><p>可以将统计计数的数据维护到数据库的一个表中，让他们在同一个事务中处理。</p><p>‍</p>`,82),u=[d];function k(m,g){return n(),a("div",null,u)}const b=s(r,[["render",k],["__file","03-Mysql索引优化二.html.vue"]]),v=JSON.parse('{"path":"/statudy/Mysql/03-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%BA%8C.html","title":"03-Mysql索引优化二","lang":"zh-CN","frontmatter":{"title":"03-Mysql索引优化二","order":3,"date":"2024-04-13T00:00:00.000Z","category":["Mysql"],"tag":["Mysql"],"description":"分页查询 limit start,end 常见的mysql分页写法 limit 90000,10 这种写法，mysql会查询出90010条数据，然后将前面90000条数据丢弃，保留最后10条数据。 优化 以下优化方式各有优缺点，需要根据业务需要灵活选择。 当主键连续且自增，并且根据主键排序时 可改写为以主键为条件，查询所需条数的写法。 以上条件在实际生...","head":[["meta",{"property":"og:url","content":"https://xsyl06.github.io/myblog/myblog/statudy/Mysql/03-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%BA%8C.html"}],["meta",{"property":"og:site_name","content":"Xsyl06的博客"}],["meta",{"property":"og:title","content":"03-Mysql索引优化二"}],["meta",{"property":"og:description","content":"分页查询 limit start,end 常见的mysql分页写法 limit 90000,10 这种写法，mysql会查询出90010条数据，然后将前面90000条数据丢弃，保留最后10条数据。 优化 以下优化方式各有优缺点，需要根据业务需要灵活选择。 当主键连续且自增，并且根据主键排序时 可改写为以主键为条件，查询所需条数的写法。 以上条件在实际生..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231126212344-7jdcmhs.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-16T10:28:03.000Z"}],["meta",{"property":"article:author","content":"xsyl06"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:published_time","content":"2024-04-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-16T10:28:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03-Mysql索引优化二\\",\\"image\\":[\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231126212344-7jdcmhs.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231126213117-0bxxcpr.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231126213331-90d94ig.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231126213907-9ogaith.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231126214000-ig9ob0o.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20231126214044-8dbv6c6.png\\"],\\"datePublished\\":\\"2024-04-13T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-16T10:28:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xsyl06\\",\\"url\\":\\"https://gitee.com/xsyl06\\"}]}"]]},"headers":[{"level":2,"title":"分页查询 limit start,end","slug":"分页查询-limit-start-end","link":"#分页查询-limit-start-end","children":[{"level":3,"title":"优化","slug":"优化","link":"#优化","children":[{"level":4,"title":"当主键连续且自增，并且根据主键排序时","slug":"当主键连续且自增-并且根据主键排序时","link":"#当主键连续且自增-并且根据主键排序时","children":[]},{"level":4,"title":"主键不连续","slug":"主键不连续","link":"#主键不连续","children":[]},{"level":4,"title":"根据非主键字段排序的分页","slug":"根据非主键字段排序的分页","link":"#根据非主键字段排序的分页","children":[]}]}]},{"level":2,"title":"join关联优化","slug":"join关联优化","link":"#join关联优化","children":[{"level":3,"title":"Nested-Loop Join 嵌套循环连接(NLJ)","slug":"nested-loop-join-嵌套循环连接-nlj","link":"#nested-loop-join-嵌套循环连接-nlj","children":[]},{"level":3,"title":"Block-Nested-Loop Join 基于块的嵌套循环连接(BNL)","slug":"block-nested-loop-join-基于块的嵌套循环连接-bnl","link":"#block-nested-loop-join-基于块的嵌套循环连接-bnl","children":[]},{"level":3,"title":"为什么不用嵌套循环连接(NLJ)呢","slug":"为什么不用嵌套循环连接-nlj-呢","link":"#为什么不用嵌套循环连接-nlj-呢","children":[]},{"level":3,"title":"优化方法","slug":"优化方法","link":"#优化方法","children":[]}]},{"level":2,"title":"in和exists","slug":"in和exists","link":"#in和exists","children":[]},{"level":2,"title":"count()语句","slug":"count-语句","link":"#count-语句","children":[{"level":3,"title":"count(1)","slug":"count-1","link":"#count-1","children":[]},{"level":3,"title":"count(*)","slug":"count","link":"#count","children":[]},{"level":3,"title":"常见查询优化方法","slug":"常见查询优化方法","link":"#常见查询优化方法","children":[{"level":4,"title":"查询mysql自己维护的总行数","slug":"查询mysql自己维护的总行数","link":"#查询mysql自己维护的总行数","children":[]},{"level":4,"title":"show table status","slug":"show-table-status","link":"#show-table-status","children":[]},{"level":4,"title":"将总数维护到缓存中如redis","slug":"将总数维护到缓存中如redis","link":"#将总数维护到缓存中如redis","children":[]},{"level":4,"title":"维护相应数据到数据库表中","slug":"维护相应数据到数据库表中","link":"#维护相应数据到数据库表中","children":[]}]}]}],"git":{"createdTime":1713263283000,"updatedTime":1713263283000,"contributors":[{"name":"Wang","email":"xsyl06@qq.com","commits":1}]},"readingTime":{"minutes":7.93,"words":2380},"filePathRelative":"statudy/Mysql/03-Mysql索引优化二.md","localizedDate":"2024年4月13日","excerpt":"<h2>分页查询 limit start,end</h2>\\n<p>常见的mysql分页写法</p>\\n<div class=\\"language-sql\\" data-ext=\\"sql\\" data-title=\\"sql\\"><pre class=\\"language-sql\\"><code><span class=\\"token keyword\\">select</span> <span class=\\"token operator\\">*</span> <span class=\\"token keyword\\">from</span> employees <span class=\\"token keyword\\">limit</span> <span class=\\"token number\\">90000</span><span class=\\"token punctuation\\">,</span><span class=\\"token number\\">10</span><span class=\\"token punctuation\\">;</span>\\n</code></pre></div>","autoDesc":true}');export{b as comp,v as data};
