---
title: 07-表结构及索引设计
order: 6
date: 2024-04-17
category:
  - Mysql
tag:
  - Mysql
---

## 数据库表设计-范式化

范式来自英文Normal Form，简称NF。MySQL是关系型数据库，但是要想设计—个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求得严格。满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(insert)、删除(delete)和更新(update)操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。

### 第一范式

定义：属于第一范式关系的所有属性都不可再分，即数据项不可分。

如：

|**id**|**name-age**|
| :-: | :-: |
|1|张三-18|

name-age不符合第一范式，可将其拆分

|**id**|**name**|**age**|
| :-: | :-: | :-: |
|1|张三|18|

### 第二范式

定义：第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。通常在实现来说，需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。  
**通俗来说，表中数据需要主键或唯一索引。**

### 第三范式

定义：指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主键对主键的传递依赖。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。  
**通俗来说就是个需要关联关系表将相关信息进行关联**

### 反范式化设计

完全符合范式化的设计真的完美无缺吗？很明显在实际的业务查询中会大量存在着表的关联查询，而大量的表关联很多的时候非常影响查询的性能。  
所谓得反范式化就是为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反。允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间。  

## 总结

### 范式化设计的优缺点

#### 优点

1. 范式化设计的表结构，更新操作会比反范式化快。
2. 范式化设计的表结构，存储空间比反范式化小。
3. 范式化设计的表，数据冗余较小，若出现需要修改的情况，修改位置，修改数据量较小，通常只修改一处即可。
4. 很少有多余的数据，在检索列表时，可以更少的使用distinct和order by

#### 缺点

1. 范式化设计的表通常需要连表查询才能得到所有结果。稍微复杂一点的查询语句，可能需要关联多张表，此时查询语句执行效率变低，也可能会导致一些表索引失效。

### 反范式化设计的优缺点

#### 优点

1. 反范式化设计，可以减少表的关联。
2. 可以更好的进行索引优化。

#### 缺点

1. 数据冗余，维护成本变高，可能会出现数据错误或不一致情况。
2. 对数据修改需要考虑的地方更多

## 实际工作中的反范式化

### 1.缓存和汇总

最常见的反范式化方法是对数据进行缓存，在不同的表中存储特定的列，将本来需要连表查询的语句，通过表结构，改为单表查询。  
汇总也是一种反范式化方式，将经常需要用到的汇总且结果不变的数据，存入一张表中，每天只做一次加工后，后续查询既可不用加工数据。此种方式常见于报表等情况。  
在使用缓存表和汇总表时，有个关键点是如何维护缓存表和汇总表中的数据，常用的有两种方式，**实时维护数据**和**定期重建**，这个取决于应用程序，不过一般来说，缓存表用实时维护数据更多点，往往在一个事务中同时更新数据本表和缓存表，汇总表则用定期重建更多，使用定时任务对汇总表进行更新。

### 2.计数器表

计数器表在Web应用中很常见。比如网站点击数、用户的朋友数、文件下载次数等。对于高并发下的处理，首先可以创建一张独立的表存储计数器，这样可使计数器表小且快，并且可以使用一些更高级的技巧。

比如假设有一个计数器表，只有一行数据，记录网站的点击次数，网站的每次点击都会导致对计数器进行更新，问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁(mutex)。这会使得这些事务只能串行执行，会严重限制系统的并发能力。

可以将计数器保存在多行中，每次随机选择一行进行更新。在具体实现上，可以增加一个槽（slot)字段，然后预先在这张表增加100行或者更多数据，当对计数器更新时，选择一个随机的槽（slot)进行更新即可。

这种解决思路其实就是写热点的分散，在JDK的JDK1.8中新的原子类LongAdder也是这种处理方式，而我们在实际的缓冲中间件Redis等的使用、架构设计中，可以采用这种写热点的分散的方式，当然架构设计中对于写热点还有削峰填谷的处理方式，这种在MySQL的实现中也有体现。

其实还有一种方式是这类计数器类更新操作可以在程序中用线程实现，将计数类操作与业务解耦，实现更好的业务体验。

### 3.字段类型优化

* 02-Mysql索引优化一
* 03-Mysql索引优化二

### 4.mysql索引

#### 按结构分

* B+树索引
* 哈希索引
* FULLTEXT(全文索引，现在innodb也支持了)

#### 按物理角度分

* 聚集索引
* 非聚集索引

### MRR

每次从二级索引/非聚簇索引中读取到一条记录后，就会根据该记录的主键值执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机IO带来的性能开销比较大。MySQL中提出了一个名为Disk-SweepMulti-RangeRead(MRR，多范围读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执行回表操作。相对于每读取一条二级索引记录就立即执行回表操作，这样会节省一些IO开销。使用这个MRR优化措施的条件比较苛刻，所以我们直接认为每读取一条二级索引记录就立即执行回表操作。MRR的详细信息，可以查询官方文档。

### 如何创建高性能索引

#### **索引列的类型大小尽可能小**

在定义列时，需要指定列的类型，比如tinyint、int、bigint所占空间是依次增大的，我们要表示的数据类型大小是可以根据业务推断出来的，在选择列类型时，尽量在满足业务要求的条件下，选择占用空间小的类型，这样的列在做索引时，每个索引页可存储的数据就更多，减少了索引I/O读取带来的消耗。

#### **利用索引离散化选择和前缀索引**

创建索引时候优先选择离散性强的列。索引离散型指不重复索引的数量与数据总量的比值，这个比值越大越好。当这个比值越大，说明该字段不重复的可能性越大，通过索引筛选出的数据较少，可以过滤掉更多的行。

```sql
select count(distinct order_no)/count(*) from order_exp;
```

#### **前缀索引**

有的时候需要将很长的字段添加索引，这时不需要将所有长度全部加上索引，否则会让索引变长变慢，因此可以索引该字段的开始部分，这样可以节约索引空间，提高索引效率

```sql
SELECT 
    COUNT( DISTINCT LEFT ( order_note, 3 ))/ COUNT(*) AS sel3,
    COUNT( DISTINCT LEFT ( order_note, 4 ))/ COUNT(*) AS sel4,
    COUNT( DISTINCT LEFT ( order_note, 5 ))/ COUNT(*) AS sel5,
    COUNT( DISTINCT LEFT ( order_note, 6 ))/ COUNT(*) AS sel6,
    COUNT( DISTINCT LEFT ( order_note, 7 ))/ COUNT(*) AS sel7,
    COUNT( DISTINCT LEFT ( order_note, 8 ))/ COUNT(*) AS sel8,
    COUNT( DISTINCT LEFT ( order_note, 9 ))/ COUNT(*) AS sel9,
    COUNT( DISTINCT LEFT ( order_note, 10 ))/ COUNT(*) AS sel10,
    COUNT( DISTINCT LEFT ( order_note, 11 ))/ COUNT(*) AS sel11,
    COUNT( DISTINCT LEFT ( order_note, 12 ))/ COUNT(*) AS sel12,
    COUNT( DISTINCT LEFT ( order_note, 13 ))/ COUNT(*) AS sel13,
    COUNT( DISTINCT LEFT ( order_note, 14 ))/ COUNT(*) AS sel14,
    COUNT( DISTINCT LEFT ( order_note, 15 ))/ COUNT(*) AS sel15,
    COUNT( DISTINCT order_note )/ COUNT(*) AS total 
FROM
    order_exp;
```

在阿里的编码规范中，长字段做索引时，建议用字段的前20位作为索引，但根据经验，一般13-15个字符长度即可

```sql
ALTER TABLE order_exp ADD KEY (order_note(14));
```

#### **只为用于搜索、排序、分组的列创建索引**

即为where、order by、group by后面的条件列创建索引，出现在查询列表中的列可不建立索引，除非是为了进行索引覆盖。order by和group by的顺序，需要和索引建立的顺序一致，才能使用索引。例如，一个表的索引是(name,age,sex)，则order by name,age,sex;语句可以利用索引在建立时的排序，直接从索引中读取主键信息，回表查询其余列，而order by age,sex,name;语句则不能利用索引，需要在内存中重新排序后才能查询出需要的数据。group by同理。

#### **尽可能设计三星索引**

* 索引将所有记录放到一起获得一星；
* 如果索引中的顺序和查询的排序顺序一致，获得二星；
* 索引中的列包含了查询中所需要的列，获得三星。

其中，三星一般是最重要的，二星和一星重要性相差不大。

#### **主键尽量是不改变的**

主键在设计时，尽量不要频繁update，当需要updat主键时，已经平衡的页需要频繁的分裂和合并，会严重影响性能。
