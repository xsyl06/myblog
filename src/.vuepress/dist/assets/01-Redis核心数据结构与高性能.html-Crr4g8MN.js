import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as i,a as t}from"./app-DeNibpf_.js";const a="/myblog/assets/img/image-20240419175358-kdm8c0m.png",n="/myblog/assets/img/image-20240419175508-u0a0ed8.png",l="/myblog/assets/img/image-20240419180025-0u4y835.png",r="/myblog/assets/img/image-20240419180032-vhbwkr2.png",d="/myblog/assets/img/image-20240419180148-qqcjokf.png",o={},p=t('<h2 id="redis的单线程和高性能" tabindex="-1"><a class="header-anchor" href="#redis的单线程和高性能"><span>Redis的单线程和高性能</span></a></h2><h3 id="redis是单线程吗" tabindex="-1"><a class="header-anchor" href="#redis是单线程吗"><span>Redis是单线程吗</span></a></h3><p>Redis的单线程是指网络I/O和键值对的读写的时候是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程，但Redis的其他功能，比如持久化、主从同步、集群数据同步、异步删除等都是其他线程完成的。</p><h3 id="redis单线程为什么这么快" tabindex="-1"><a class="header-anchor" href="#redis单线程为什么这么快"><span>Redis单线程为什么这么快</span></a></h3><p>因为Redis的数据是存储在<strong>内存</strong>中的，所有运算都是内存级别的，而单线程避免了线程切换上下文带来的损耗问题。但也正因为Redis是单线程的，使用时需要注意考虑耗时指令带来的影响，比如keys*等，否则可能会带来Redis卡顿等问题。</p><h3 id="redis单线程如何处理那么多并发客户连接" tabindex="-1"><a class="header-anchor" href="#redis单线程如何处理那么多并发客户连接"><span>Redis单线程如何处理那么多并发客户连接</span></a></h3><p>Redis的客户连接处理使用的是通过epoll来实现的I/O多路复用技术，将连接放到队列中，依次放到文件事件分配器中，文件事件分配器将事件分发给具体的事件处理器处理。</p><p>​<img src="'+a+`" alt="image">​</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 查看redis支持的最大连接数，在redis.conf文件中可修改，# maxclients 10000</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> CONFIG GET maxclients
    <span class="token comment">##1) &quot;maxclients&quot;</span>
    <span class="token comment">##2) &quot;10000&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="redis其他高级命令" tabindex="-1"><a class="header-anchor" href="#redis其他高级命令"><span>Redis其他高级命令</span></a></h2><h3 id="keys" tabindex="-1"><a class="header-anchor" href="#keys"><span><strong>keys</strong></span></a></h3><p>全量遍历键，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用</p><p>​<img src="`+n+'" alt="image">​</p><h3 id="scan" tabindex="-1"><a class="header-anchor" href="#scan"><span>scan</span></a></h3><p>渐进式遍历键</p><p>SCAN cursor [MATCH pattern] [COUNT count]</p><p>scan 参数提供了三个参数，第一个是 cursor 整数值(hash桶的索引值)，第二个是 key 的正则模式，第三个是一次遍历的key的数量(参考值，底层遍历的数量不一定)，并不是符合条件的结果数量。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。</p><p>注意：但是scan并非完美无瑕， 如果在scan的过程中如果有键的变化（增加、 删除、 修改） ，那么遍历效果可能会碰到如下问题： 新增的键可能没有遍历到， 遍历出了重复的键等情况， 也就是说scan并不能保证完整的遍历出来所有的键， 这些是在开发时需要考虑到的。</p><p>​<img src="'+l+'" alt="image"><img src="'+r+'" alt="image">​</p><h3 id="info" tabindex="-1"><a class="header-anchor" href="#info"><span>Info</span></a></h3><p>查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是</p><ul><li>Server 服务器运行的环境参数</li><li>Clients 客户端相关信息</li><li>Memory 服务器运行内存统计数据</li><li>Persistence 持久化信息</li><li>Stats 通用统计数据</li><li>Replication 主从复制相关信息</li><li>CPU CPU 使用情况</li><li>Cluster 集群信息</li><li>KeySpace 键值对统计数量信息</li></ul><p>​<img src="'+d+'" alt="image">​</p>',23),c=[p];function m(g,h){return s(),i("div",null,c)}const R=e(o,[["render",m],["__file","01-Redis核心数据结构与高性能.html.vue"]]),b=JSON.parse('{"path":"/statudy/Redis/01-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD.html","title":"01-Redis核心数据结构与高性能","lang":"zh-CN","frontmatter":{"title":"01-Redis核心数据结构与高性能","order":3,"index":true,"date":"2024-04-21T00:00:00.000Z","category":["Redis"],"tag":["Redis"],"description":"Redis的单线程和高性能 Redis是单线程吗 Redis的单线程是指网络I/O和键值对的读写的时候是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程，但Redis的其他功能，比如持久化、主从同步、集群数据同步、异步删除等都是其他线程完成的。 Redis单线程为什么这么快 因为Redis的数据是存储在内存中的，所有运算都是内存级别的...","head":[["meta",{"property":"og:url","content":"https://xsyl06.github.io/myblog/myblog/statudy/Redis/01-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD.html"}],["meta",{"property":"og:site_name","content":"Xsyl06的博客"}],["meta",{"property":"og:title","content":"01-Redis核心数据结构与高性能"}],["meta",{"property":"og:description","content":"Redis的单线程和高性能 Redis是单线程吗 Redis的单线程是指网络I/O和键值对的读写的时候是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程，但Redis的其他功能，比如持久化、主从同步、集群数据同步、异步删除等都是其他线程完成的。 Redis单线程为什么这么快 因为Redis的数据是存储在内存中的，所有运算都是内存级别的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xsyl06.github.io/myblog/myblog/assets/img/image-20240419175358-kdm8c0m.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"xsyl06"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2024-04-21T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"01-Redis核心数据结构与高性能\\",\\"image\\":[\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20240419175358-kdm8c0m.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20240419175508-u0a0ed8.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20240419180025-0u4y835.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20240419180032-vhbwkr2.png\\",\\"https://xsyl06.github.io/myblog/myblog/assets/img/image-20240419180148-qqcjokf.png\\"],\\"datePublished\\":\\"2024-04-21T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xsyl06\\",\\"url\\":\\"https://gitee.com/xsyl06\\"}]}"]]},"headers":[{"level":2,"title":"Redis的单线程和高性能","slug":"redis的单线程和高性能","link":"#redis的单线程和高性能","children":[{"level":3,"title":"Redis是单线程吗","slug":"redis是单线程吗","link":"#redis是单线程吗","children":[]},{"level":3,"title":"Redis单线程为什么这么快","slug":"redis单线程为什么这么快","link":"#redis单线程为什么这么快","children":[]},{"level":3,"title":"Redis单线程如何处理那么多并发客户连接","slug":"redis单线程如何处理那么多并发客户连接","link":"#redis单线程如何处理那么多并发客户连接","children":[]}]},{"level":2,"title":"Redis其他高级命令","slug":"redis其他高级命令","link":"#redis其他高级命令","children":[{"level":3,"title":"keys","slug":"keys","link":"#keys","children":[]},{"level":3,"title":"scan","slug":"scan","link":"#scan","children":[]},{"level":3,"title":"Info","slug":"info","link":"#info","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.53,"words":758},"filePathRelative":"statudy/Redis/01-Redis核心数据结构与高性能.md","localizedDate":"2024年4月21日","excerpt":"<h2>Redis的单线程和高性能</h2>\\n<h3>Redis是单线程吗</h3>\\n<p>Redis的单线程是指网络I/O和键值对的读写的时候是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程，但Redis的其他功能，比如持久化、主从同步、集群数据同步、异步删除等都是其他线程完成的。</p>\\n<h3>Redis单线程为什么这么快</h3>\\n<p>因为Redis的数据是存储在<strong>内存</strong>中的，所有运算都是内存级别的，而单线程避免了线程切换上下文带来的损耗问题。但也正因为Redis是单线程的，使用时需要注意考虑耗时指令带来的影响，比如keys*等，否则可能会带来Redis卡顿等问题。</p>","autoDesc":true}');export{R as comp,b as data};
