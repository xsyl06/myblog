const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":84,\"nextId\":84,\"documentIds\":{\"0\":\"1\",\"1\":\"1@0\",\"2\":\"1@1\",\"3\":\"2\",\"4\":\"2#前端编译\",\"5\":\"2#后端编译\",\"6\":\"2#解释执行与编译执行\",\"7\":\"2#热点代码识别\",\"8\":\"2#客户端编译器和服务端编译器\",\"9\":\"2#方法内联-inline\",\"10\":\"2#逃逸分析-escape-analysis\",\"11\":\"2#标量替换\",\"12\":\"2#栈上分配\",\"13\":\"2#锁消除-lock-elision\",\"14\":\"2@0\",\"15\":\"2@1\",\"16\":\"3\",\"17\":\"3#_1、类加载检查\",\"18\":\"3#_2、分配内存\",\"19\":\"3#_3、初始化零值\",\"20\":\"3#_4、设置对象头\",\"21\":\"3#_5、执行-init-方法\",\"22\":\"3#栈上分配-xx-doescapeanalysis\",\"23\":\"3#_1、大对象直接进入老年代\",\"24\":\"3#_2、长期存活的对象进入老年代\",\"25\":\"3#_3、对象动态年龄判断\",\"26\":\"3#_4、老年代空间担保\",\"27\":\"3#引用计数\",\"28\":\"3#可达性分析\",\"29\":\"3#常见引用类型\",\"30\":\"3#finalize-方法最终判定对象是否存活\",\"31\":\"3#如何判断一个类是无用的类\",\"32\":\"3@0\",\"33\":\"3@1\",\"34\":\"4\",\"35\":\"4#分代收集理论\",\"36\":\"4#标记-复制算法\",\"37\":\"4#标记-清除算法\",\"38\":\"4#标记-整理算法\",\"39\":\"4#_2-1-serial-收集器-xx-useserialgc-xx-useserialoldgc\",\"40\":\"4#_2-2-parallel-scavenge-收集器-xx-useparallelgc-年轻代-xx-useparalleloldgc-老年代\",\"41\":\"4#_2-3-parnew-收集器-xx-useparnewgc\",\"42\":\"4#_2-4-cms-收集器-xx-useconcmarksweepgc-old\",\"43\":\"4#cms的相关核心参数\",\"44\":\"4#三色标记\",\"45\":\"4#多标-浮动垃圾\",\"46\":\"4#漏标-读写屏障\",\"47\":\"4#写屏障\",\"48\":\"4#写屏障实现satb\",\"49\":\"4#写屏障实现增量更新\",\"50\":\"4#读屏障\",\"51\":\"4#记忆集与卡表\",\"52\":\"4#卡表的维护\",\"53\":\"4@0\",\"54\":\"4@1\",\"55\":\"5\",\"56\":\"5#g1垃圾收集器-xx-useg1gc\",\"57\":\"5#g1垃圾收集分类\",\"58\":\"5#younggc\",\"59\":\"5#mixedgc\",\"60\":\"5#fullgc\",\"61\":\"5#g1收集器参数设置\",\"62\":\"5#g1垃圾收集器优化建议\",\"63\":\"5#什么场景适合使用g1\",\"64\":\"5#每秒几十万并发的系统如何优化jvm\",\"65\":\"5#zgc收集器-xx-usezgc\",\"66\":\"5#zgc的目标\",\"67\":\"5#不分代-暂时\",\"68\":\"5#zgc内存布局\",\"69\":\"5#zgc收集过程\",\"70\":\"5#颜色指针\",\"71\":\"5#三大优势\",\"72\":\"5#读屏障\",\"73\":\"5#zgc存在的问题\",\"74\":\"5#zgc触发时机\",\"75\":\"5#如何选择垃圾回收器\",\"76\":\"5#安全点与安全区域\",\"77\":\"5#安全点-safe-point\",\"78\":\"5#安全区域-safe-region\",\"79\":\"5@0\",\"80\":\"5@1\",\"81\":\"6\",\"82\":\"7\",\"83\":\"8\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,60],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[2],\"4\":[1,4],\"5\":[1,22],\"6\":[1,45],\"7\":[1,38],\"8\":[1,87],\"9\":[3,159],\"10\":[4,23],\"11\":[1,26],\"12\":[1,38],\"13\":[4,72],\"14\":[null,null,1],\"15\":[null,null,1],\"16\":[2,1],\"17\":[2,7],\"18\":[2,43],\"19\":[2,9],\"20\":[2,29],\"21\":[2,42],\"22\":[1,28],\"23\":[2,12],\"24\":[2,33],\"25\":[2,18],\"26\":[2,29],\"27\":[1,33],\"28\":[1,12],\"29\":[1,39],\"30\":[1,75],\"31\":[1,18],\"32\":[null,null,1],\"33\":[null,null,1],\"34\":[4,1],\"35\":[1,27],\"36\":[2,10],\"37\":[2,20],\"38\":[2,24],\"39\":[2,45],\"40\":[1,51],\"41\":[2,24],\"42\":[2,84],\"43\":[1,42],\"44\":[1,62],\"45\":[2,21],\"46\":[2,34],\"47\":[1,30],\"48\":[1,23],\"49\":[1,7],\"50\":[1,71],\"51\":[1,50],\"52\":[1,6],\"53\":[null,null,1],\"54\":[null,null,2],\"55\":[4],\"56\":[4,208],\"57\":[1],\"58\":[1,13],\"59\":[1,12],\"60\":[1,7],\"61\":[1,68],\"62\":[1,24],\"63\":[1,8],\"64\":[1,33],\"65\":[2,58],\"66\":[1,24],\"67\":[3,16],\"68\":[1,31],\"69\":[1,65],\"70\":[1,50],\"71\":[1,13],\"72\":[1,73],\"73\":[1,39],\"74\":[1,32],\"75\":[1,26],\"76\":[1],\"77\":[4,19],\"78\":[4,11],\"79\":[null,null,1],\"80\":[null,null,2],\"81\":[1,3],\"82\":[1],\"83\":[1]},\"averageFieldLength\":[1.6415836127859307,37.86484444929754,0.7720824805792126],\"storedFields\":{\"0\":{\"h\":\"01-JVM内存模型\",\"t\":[\"​​\",\"​​\",\"-Xss：每个线程的栈大小\",\"-Xms：设置堆的初始可用大小，默认物理内存的1/64\",\"-Xmx：设置堆的最大可用大小，默认物理内存的1/4\",\"-Xmn：新生代大小\",\"-XX:NewRatio：默认2表示新生代占年老代的1/2，占整个堆内存的1/3\",\"-XX:SurvivorRatio：默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存\",\"元空间设置参数有两个：\",\"-XX:MaxMetaspaceSize ：元空间最大值，默认-1，不限制，只受限于本地物理内存大小\",\"-XX:MetaspaceSiz：指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的-XX:PermSize参数意思不一样，-XX:PermSize代表永久代的初始容量。\",\"由于调整元空间大小需要Fullgc，很耗费开销。在应用启动过程中发生大量Fullgc，通常是元空间发生了大小调整，基于这种情况，一般建议将JVM参数-XX:MaxMetaspaceSize和-XX:MetaspaceSize设置成一样的值，并且设置的比初始值要大，对于8G内存的系统来说，一般可以设置成256M。\",\"‍\"]},\"1\":{\"c\":[\"JVM\"]},\"2\":{\"c\":[\"JVM\"]},\"3\":{\"h\":\"02-深入理解JVM执行引擎\"},\"4\":{\"h\":\"前端编译\",\"t\":[\"通常认为将java文件编译成class的字节码文件乘坐前端编译。而且在class编译时会对原文件进行一定优化，这种优化不会提高执行效率。\"]},\"5\":{\"h\":\"后端编译\",\"t\":[\"jvm在执行时，将class的字节码文件解释编译成机器码供计算机执行，称为后端编译\",\"​​\",\"其中前端编译是在 JVM 虚拟机之外执⾏，所以与 JVM 虚拟机没有太⼤的关系。任何编程语言，只要能够编译出满⾜ JVM 规范的 Class ⽂件，就可以提交到 JVM 虚拟机执⾏。⾄于编译的过程，如果你不是想要专⻔去研究语⾔，那么就没有必要太过深⼊的去了解了。这⾥就暂时略过。我们更关注JVM在后端编译过程中如何提升执⾏的效率。\"]},\"6\":{\"h\":\"解释执行与编译执行\",\"t\":[\"class文件中已经保留了每一行java代码对应的字节码，也就是说，jvm执行引擎如何执行一段java代码已经在class文件中确定了，\",\"​​\",\"那么jvm如何执行class的字节码文件呢，最简单的做法就是一个指令就翻译一次成为机器码进行之心，称之为解释执行 但是这种方式需要在上层语言和机器码之间经过中间⼀层JVM字节码的转换，显然执⾏效率是⽐不上C 和 C++那 些直接面向本地机器指令编程的语言的，这也是长久以前， Java被 C 和 C++开发者吐槽执⾏速度慢的根源\",\"JVM为了加快运行速度，维护了一个CodeCache，将那些字节码指令，提前编译出来放到缓存当中。当再次执行时，会直接从缓存中获取机器码直接执行，这种先编译，后执行的方式称为编译执行\",\"但是JVM也不清楚程序员会写出什么样的代码，所以没有办法提前维护出一个完整的字节码缓存，故而退而求其次，将那些运行频率高的热点代码进行提前编译，放到缓存当中\",\"使用java -version就可以看到当前使用的是那种模式\",\"​​\",\"这里可以看出，HotSpot虚拟机并没有直接选择执行效率最高的编译执行模式，而是默认采用了混合模式，兼顾效率和运行成本。因为编译执行需要识别热点代码，需要进行机器编译，需要额外的CodeCache存储编译的代码，另外，在编译执行识别热点代码的过程中，还需要解释执行来帮助提供一些信息支持，因此在HotSpot中，会默认使用混合模式，而不是单纯的使用其中一种模式。\"]},\"7\":{\"h\":\"热点代码识别\",\"t\":[\"使用JIT实时编译的前提是需要识别出热点代码，要知道某段代码是否是热点代码，是否需要即时编译，这个行为称之为“热点探测”。在HotSpot中使方法调用计数器和回边计数器来实现，在JVM运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器的计数一旦溢出阈值，就会触发即时编译\",\"方法调用计数器： 就是记录统计方法的调用次数，每当某个方法被调用一次时，就会记录一下该方法的调用次数，当这个方法调用次数非常多，超过了设定的某一个阈值，就可以认为是热点代码。这时就可以向JIT提交针对该方法的热点编译请求。这个阈值默认是10000次，可以通过-XX:CompileThreshold​来设定\",\"‍\",\"回边计数器： 作用是统计一个方法中循环体代码执行的次数，在字节码中遇到的向后跳转的指令称之为回边，建立回边计数器就是为了发现一个方法体内被频繁调用的循环。回边计数器在默认情况下的阈值是1070\",\"阈值计算公式\",\"阈值计算公式：回边计数器阈值=方法调用计数器阈值×(比率-解释器监控比率)/100 其中比率的值默认为140，解释器监控比率为33，如果都取默认值，那么server模式下的虚拟机回边计数器的阈值就为10700。\"]},\"8\":{\"h\":\"客户端编译器和服务端编译器\",\"t\":[\"当识别出热点代码后，在编译时不可避免的需要进行编译优化，在HotSpot虚拟机中，热点代码在被JIT即时编译的过程中，JIT会运用很多经典的编译优化技术来实现对字节码指令的优化，让编译出来的机器码运行效率更高。\",\"HotSpot虚拟机内置两个即时编译器，这两个编译器存在已久，分别被称为“客户端编译器”和“服务端编译器”，简称C1编译器和C2编译器。\",\"C1相当于一个初级编译。在编译过程中，C1会对字节码做简单和可靠的优化，耗时短以达到更快编译的速度。启动快，占用内存小，但翻译出来的机器码优化程度不高，比较适合一些小巧的桌面应用，因此也被称为客户端编译器。\",\"C2相当于一个高级编译。在编译过程中，C2编译器会更加激进的对字节码进行优化，优化后的机器码执行效率更高。但也相应的，占用资源更多，包括启动速度较慢、内存占用多、进行优化的耗时也更长等。比较适合资源相对充裕的服务器，因此也被称为服务端编译器。\",\"但实际上两个编译器不是相互取代而是相互协作的关系。由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot虚拟机在编译子系统中加入了分层编译的功能，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次。\",\"等级\",\"描述\",\"性能\",\"0\",\"纯解释执行，并且解释器不开启性能监控\",\"1\",\"1\",\"使用C1来将字节码编译为本地机器码，进行简单的优化，不开启性能监控\",\"4\",\"2\",\"仍然使用C1编译器来执行，仅开启方法计数器和回边计数器\",\"3\",\"3\",\"仍使用C1编译器来执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部信息\",\"2\",\"4\",\"使用C2编译器来执行，相比于C1编译器，C2编译器会对字节码进行更加激进的优化，同时启动会更慢、耗时更长\",\"5\",\"JDK8中提供的-XX:TieredStopAtLevel=1可以指定使用那一层编译器。\",\"之前说过，在解释时，JVM只负责进行翻译和执行，而进行JIT时，会对代码进行一些优化，这使得在大部分情况下，即使程序员写的代码不够优化，JVM也能保证一个不错的执行效率，就成为编译优化技术。\",\"参数信息\",\"具体的优化策略可参见OpenJDK的WIKI：PerformanceTacticIndex - PerformanceTacticIndex - OpenJDK Wiki\"]},\"9\":{\"h\":\"方法内联(InLine)\",\"t\":[\"方法内联就是将目标方法的执行代码复制到调用该方法的地方，从而避免真实的调用，进一步减少频繁创建栈帧的性能开销。\",\"​​\",\"比如如下代码\",\"public class CompDemo { private int add1(int x1,int x2,int x3,int x4){ return add2(x1,x2)+ add2(x3,x4); } private int add2(int x1, int x2){ return x1+x2; } //内联优化 private int add(int x1,int x2,int x3,int x4){ return x1+x2+x3+x4; } public static void main(String[] args) { CompDemo compDemo = new CompDemo(); //超过方法调用计数器的阈值 100000 次，才会进入 JIT 实时编译，进行内联优化。 for (int i = 0; i < 1000000; i++) { compDemo.add1(1,2,3,4); } } } \",\"加入 JVM 参数：-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining 后可以看到以下的执行日志\",\"​​\",\"当然，发生方法内联的前提是要让这个方法循环足够的次数，成为热点代码。比如，如果将循环次数减少，就看不到方法内联了。\",\"方法内联的优化本质就是把目标方法的代码原封不动的“复制”到发起调用的方法之中，避免发生真实的方法调用。但是，实际上，Java 虚拟机中的内联过程却远没有想象中那么容易。而且，方法内联往往还是很多后续优化手段的基础。\",\"public class InlineDemo { public static void foo(Object obj){ if(obj !=null){ System.out.println(\\\"do something\\\"); } } //方法内联之后会继续进行无用代码消除 public static void testInline(){ Object obj= null; foo(obj); } public static void main(String[] args) { long l = System.currentTimeMillis(); for (int i = 0; i < 10000000; i++) { testInline(); } System.out.println(\\\">>>>>>>>\\\"+(System.currentTimeMillis()-l)); } } \",\"单独来看testInline()和foo(obj)是两个单独的方法但是当出现方法内联，将foo(obj)的代码复制到test Inline()中后会发现，if条件永远为false，就是死代码，接下来，JVM虚拟机就可以将DeadCode移除来进行优化\",\"在JDK8中，提供多个跟InLine内联相关参数，可以进行干预内联行为\",\"-XX:+Inline 启用方法内联。默认开启。\",\"-XX:InlineSmallCode=size 用来判断是否需要对方法进行内联优化。如果一个方法编译后的字节码大小大于这个值，就无法进行内联。默认值是1000bytes。\",\"-XX:MaxInlineSize=size 设定内联方法的最大字节数。如果一个方法编译后的字节码大于这个值，则无法进行内联。默认值是35byt\",\"-XX:FreqInlineSize=size 设定热点方法进行内联的最大字节数。如果一个热点方法编译后的字节码大于这个值，则无法进行内联。默认值是325bytes。\",\"-XX:MaxTrivialSize=size 设定要进行内联的琐碎方法的最大字节数(Trivial Method：通常指那些只包含一两行语句，并且逻辑非常简单的方法。比如像这样的方法，默认值是6bytes。\",\"public int getTrivialValue() { return 42; } \",\"-XX:+PrintInlining 打印内联决策，通过这个指令可以看到哪些方法进行了内联。默认是关闭的。另外，这个参数需要配合-XX:+UnlockDiagnosticVMOptions 参数使用。\",\"从这几个相关参数可以看到，我们可以通过以下一些方法提高内联发生的概率。\",\"1 、在编程中，尽量多写小方法，避免写大方法。方法太大不光会导致方法无法内联，另外，成为热点方法后，还会占用更多的CodeCache。\",\"2 、在内存不紧张的情况下，可以通过调整JVM参数，减少热点阈值或增加方法体阈值，让更多的方法可以进行内联。\",\"3 、看情况使用final, private,static关键字修饰方法。方法如果需要继承(也就是需要使用invokevirtual指令调用)，那么具体调用的方法，就只能在运行这一行代码时才能确定，编译器很难在编译时得出绝对正确的结论，也就加大了编译执行的难度。\"]},\"10\":{\"h\":\"逃逸分析(Escape Analysis)\",\"t\":[\"对象在方法中创建后，如果被方法外部所引用或者作为参数传递给其他方法，这种叫方法逃逸。如果被其他线程访问，譬如作为其他线程可访问对象的属性被引用，就称之为线程逃逸。\",\"private void test1(){ T t = new T(); t.setAge(10); } private void test2(){ T t = new T(); t.setAge(10); saveT(t); } \",\"如上方法中，test1方法内的t对象就没有被方法外部引用，因此他不会逃逸，而test2方法中的t就逃逸到其他方法了\",\"如果能保证一个方法不会逃逸出方法或线程，JIT就能针对该对象进行优化\"]},\"11\":{\"h\":\"标量替换\",\"t\":[\"如果一个对象的属性无法再分解为更小的数据来表示了(java中的int、long、reference类型等)，都不能分解，那么这些变量就可以称为标量。如果把一个java对象拆散，根据程序访问情况，去实际访问拆散后的成员变量，就称之为标量替换。\",\"假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。JDK8 中默认开启了标量替换，可以通过添加参数 -XX:-EliminateAllocations​ 主动关闭标量替换。\"]},\"12\":{\"h\":\"栈上分配\",\"t\":[\"正常情况下，JVM 中所有对象都应该创建在堆上，并由 GC 线程进行回收。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。\",\"这三种优化措施中，逃逸分析是基础。因为虚拟机栈是对应一个线程的，而堆内存是对应整个Java进程的。如果发生了线程逃逸，那么堆中的同一个对象，可能隶属于多个线程，这时要将堆中的对象挪到虚拟机栈中，那就必须扫描所有的虚拟机栈，检查这个虚拟机栈对应的线程中是否引用了这个对象。这个性能开销是难以接受的。\",\"而栈是一个非常小的内存结构，他也不可能像堆中那么豪横的使用内存空间，所以，也必须要对对象进行最大程度的瘦身，才能放到栈中。而瘦身的方式，就是去掉对象的mark标志位中的补充信息，拆分成最精简的标量。所以，要开启栈上分配，标量替换也是不可或缺的。\"]},\"13\":{\"h\":\"锁消除(lock elision)\",\"t\":[\"这个也是经过逃逸分析后可以直接进行的优化措施。\",\"这个优化措施主要针对synchronized关键字，当JVM检测到一个加锁的代码不会出现锁竞争时，会对这个对象的锁进行锁消除\",\"场景举例\",\"多线程并发资源竞争是一个很复杂的场景，所以通常想要检查锁是否存在多线程竞争比较困难。 但有一种情况比较简单，如果一个方法没有发生逃逸，那么他内部的锁就不会存在竞争。\",\"public class LockElisionDemo { public static String BufferString(String s1,String s2){ StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString(); } public static String BuilderString(String s1, String s2){ StringBuilder sb = new StringBuilder(); sb.append(s1); sb.append(s2); return sb.toString(); } public static void main(String[] args) { long startTime = System.currentTimeMillis(); for (int i = 0; i < 100000000; i++) { BufferString(\\\"aaaaa\\\",\\\"bbbbbb\\\"); } System.out.println(\\\"StringBuffer耗时：\\\"+(System.currentTimeMillis()-startTime)); long startTime2 = System.currentTimeMillis(); for (int i = 0; i < 100000000; i++) { BuilderString(\\\"aaaaa\\\",\\\"bbbbbb\\\"); } System.out.println(\\\"StringBuilder耗时：\\\"+(System.currentTimeMillis()-startTime2)); } } \",\"以上代码分别测试了StringBuffer和StringBuilder的字符串构建方法。两者最大的区别就是StringBuildr是线程不安全的，而StringBuffer是线程安全的，在它的append和toString方法都加了sychronized同步锁，而StringBuilder则没加。\",\"当前代码中，只有一个main线程顺序执行代码，不存在线程竞争，所以这个sychronized没有起作用，因此，在触发了JIT时，JVM会在编译时将这个无用的锁消除掉，这样两个方法耗时是差不多的。\",\"StringBuffer耗时：1521 StringBuilder耗时：1039 \",\"当使用JVM参数 -XX:-EliminateLocks​ 主动关闭锁清除后，执行时间就有比较大的差距\",\"StringBuffer耗时：2461 StringBuilder耗时：1049 \",\"‍\"]},\"14\":{\"c\":[\"JVM\"]},\"15\":{\"c\":[\"JVM\"]},\"16\":{\"h\":\"03-JVM对象创建及内存分配机制\",\"t\":[\"​​\"]},\"17\":{\"h\":\"1、类加载检查\",\"t\":[\"虚拟机执行new方法指令时，先去检查这个指令的参数是否能够在类的常量池中定位到一个类的符号引用，并检查这个类的符号引用所指向的类是否已加载、解析和初始化过程。如果没有，则执行类加载过程。\"]},\"18\":{\"h\":\"2、分配内存\",\"t\":[\"对象加载完成过后，虚拟机会对新生对象分配内存操作；对象所需的内存大小，在加载完成便可以确定，为对象分配空间，即JVM将java堆内一部分区域划分给这个对象使用。\",\"2.1 如何划分：\",\"指针碰撞： 如果java内存绝对规整，所有使用过的内存都在一边，则可以使用指针碰撞方法，即左边都是内存，中间是指针作为内存临界标识，所分配内存仅仅是把指针向空闲一边移动所需大小的相等的距离。\",\"空闲列表： 当java堆内存并不是规整的，即一部分空闲的和已使用的相互交错，虚拟机会维护一个列表，记录那些内存块可用，在分配时查找一块空间足够的可用内存，分配给这个对象。\",\"2.2 并发分配时解决办法：\",\"CAS： 虚拟机采用CAS+重新分配方式保证更新时的原子性来保证并发时的内存分配\",\"本地线程分配缓冲(Thread Local Allcation Buffer,TLAB): 在堆内为每个线程划分出一块单独区域，根据线程不同，向该线程的单独区域内进行内存分配。使用-XX:-/+UseTLAB参数来关闭和开启本地线程分配缓冲(JVM默认开启)，-XX:TLABSize来指定缓冲区大小。当无法进行本地线程分配缓冲时，JVM使用CAS方式分配内存。​​\",\"​​\"]},\"19\":{\"h\":\"3、初始化零值\",\"t\":[\"内存分配完成后，虚拟机需要将分配的空间都初始化为零值(对象头除外)，如int的0值等， 如果使用TLAB，这一步可提前至TLAB分配时进行，这一步操作保证了java里对象实例不赋值默认值也可以直接使用，程序可以访问到这些对象默认的零值。\"]},\"20\":{\"h\":\"4、设置对象头\",\"t\":[\"初始化零值之后，虚拟机需要对对象设置对象头，主要保存对象类的路径(这个对象是那个类)，如何才能找到类的元信息，对象的哈希码，对象GC分代年龄信息等。 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\",\"​​\",\"​​\"]},\"21\":{\"h\":\"5、\",\"t\":[\"执行init方法，即对象按照程序员意愿进行初始化。即为属性赋值，和执行构造方法。\",\"-XX:-/+ UseCompressedOops(默认开启)\",\"在64位系统中，如实际是32位的地址，但使用64位进行存储，相比较32位存储，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动，占用较大带宽，且GC压力会比较大。\",\"为了减少在64位平台下的内存消耗，jvm默认启用了指针压缩功能。\",\"在JVM中32位地址可以支持4G内存(2的32次方)，当内存大于4G时，可以通过对对象指针存入堆内存时压缩编码、取出到cpu寄存器后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方=32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)。\",\"当堆内存小于4G时，不需要手动启用指针压缩，JVM会默认去掉高位的0，使用低位的32位地址\",\"当堆内存大于32G时，指针压缩会失效，JVM会强制使用64位(即8字节)来对java对象寻址。\",\"填充对齐： 对于大部分处理器，对象以8字节整数倍来对齐填充都是最高效的存取方式。\",\"​​\"]},\"22\":{\"h\":\"\",\"t\":[\"java对象一般在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。\",\"逃逸分析(-XX:-/+EliminateAllocations)： 就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，就称之为逃逸，逃逸的对象无法进行栈上分配。\",\"由于一个线程的栈的大小通常不会太大，虚拟机不会将一个对象完整的分配到栈上，而是使用标量替换的方法进，将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。\",\"打印GC参数： -XX:+PrintGCDetails\"]},\"23\":{\"h\":\"1、大对象直接进入老年代\",\"t\":[\"当对象需要大量且连续的空间时，如果新生代的eden区域无法存放，会触发Minor GC，此时大对象在S0和S1区域也无法存储，会直接进入老年代。可通过 -XX:PretenureSizeThreshold参数设置大对象阈值(单位是字节)，此参数在Serial和ParNew垃圾回收器下起作用。\"]},\"24\":{\"h\":\"2、长期存活的对象进入老年代\",\"t\":[\"虚拟机采用分代的算法进行对象管理和垃圾收集，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\"]},\"25\":{\"h\":\"3、对象动态年龄判断\",\"t\":[\"当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在Minor GC之后触发的。\"]},\"26\":{\"h\":\"4、老年代空间担保\",\"t\":[\"年轻代每次Minor GC时，JVM会计算老年代剩余可用空间，如果该空间小于年轻代所有剩余对象之和(包括垃圾对象)\",\"检查“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置\",\"如果设置了，则会对老年代剩余可用空间大小和之前每一次Minor GC后进入老年代对象的平均大小进行比较\",\"如果是小于或参数未设置，则会触发Full GC，对堆内存进行回收，如果回收完还没有足够的空间，则报OOM\",\"如果比对结果为大于，但Minor GC之后需要存放到老年代的对象大小仍然超过了老年代剩余可用空间大小，也会触发Full GC，对堆内存进行回收，如果回收完还没有足够的空间，则报OOM\",\"​​\",\"堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。\"]},\"27\":{\"h\":\"引用计数\",\"t\":[\"可以给对象添加一个引用计数，如果该对象被引用，则计数加1，如果没有被引用，则计数减1，任何计数为0的对象就是可回收对象。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。\",\"class A{ public B b; } class B{ public A a; } public void test(){ A a = new A(); B a = new B(); a.b = b; b.a = a; } \"]},\"28\":{\"h\":\"可达性分析\",\"t\":[\"将 “GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象， 其余未标记的对象都是垃圾对象\",\"GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等\",\"​​\"]},\"29\":{\"h\":\"\",\"t\":[\"java的引用类型一般分为四种：强引用、软引用、弱引用、虚引用\",\"强引用： 普通的变量引用\",\"​public static User user = new User();​\",\"软引用： 将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。\",\"​public static SoftReference<User> user = new SoftReference<User>(new User()); ​\",\"软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。\",\"​（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建\",\"（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出\",\"弱引用： 将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用\",\"​public static WeakReference<User> user = new WeakReference<User>(new User()); ​\",\"虚引用： 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用\"]},\"30\":{\"h\":\"\",\"t\":[\"即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。\",\"标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。\",\"1. 第一次标记并进行一次筛选。 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize方法，对象将直接被回收。\",\"2. 第二次标记 如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。\",\"注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。\",\"public class OOMTest { public static void main(String[] args) { List<Object> list = new ArrayList<>(); int i = 0; int j = 0; while (true) { list.add(new User(i++, UUID.randomUUID().toString())); new User(j--, UUID.randomUUID().toString()); } } } //User类需要重写finalize方法 @Override protected void finalize() throws Throwable { OOMTest.list.add(this); System.out.println(\\\"关闭资源，userid=\\\" + id + \\\"即将被回收\\\"); } \"]},\"31\":{\"h\":\"\",\"t\":[\"方法区主要回收的是无用的类，那么如何判断一个类是无用的类呢？ 类需要同时满足下面3个条件才能算是 “无用的类” ：\",\"该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\",\"加载该类的 ClassLoader 已经被回收。\",\"该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"‍\"]},\"32\":{\"c\":[\"JVM\"]},\"33\":{\"c\":[\"JVM\"]},\"34\":{\"h\":\"04-JVM的垃圾收集器（上）\",\"t\":[\"​​\"]},\"35\":{\"h\":\"分代收集理论\",\"t\":[\"当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\",\"比如在新生代中，每次收集都会有大量对象(近 99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢 10 倍以上。\"]},\"36\":{\"h\":\"标记-复制算法\",\"t\":[\"为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\",\"​​\"]},\"37\":{\"h\":\"标记-清除算法\",\"t\":[\"算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：\",\"效率问题 (如果需要标记的对象太多，效率不高)\",\"空间问题（标记清除后会产生大量不连续的碎片）\",\"​​\"]},\"38\":{\"h\":\"标记-整理算法\",\"t\":[\"根据老年代的特点，特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\",\"​​\",\"如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\",\"​​\",\"虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 Java 虚拟机就不会实现那么多不同的垃圾收集器了。\"]},\"39\":{\"h\":\"2.1\",\"t\":[\"Serial（串行） 收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ \\\"Stop The World\\\" ），直到它收集结束。\",\"新生代采用复制算法​ ，老年代采用标记-整理​算法。\",\"​​\",\"虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\",\"但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。\",\"Serial Old 收集器是 Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\"]},\"40\":{\"h\":\"2.2\",\"t\":[\"Parallel 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器类似。默认的收集线程数跟 cpu 核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改 。\",\"Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\",\"新生代采用复制算法​ ，老年代采用标记-整理​算法。\",\"​​\",\"Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器(JDK8 默认的新生代和老年代收集器)。\"]},\"41\":{\"h\":\"2.3\",\"t\":[\"ParNew 收集器其实跟 Parallel 收集器很类似，区别主要在于它可以和 CMS 收集器配合使用。​\",\"新生代采用复制算法​ ，老年代采用标记-整理​算法。\",\"​​\",\"它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\"]},\"42\":{\"h\":\"2.4\",\"t\":[\"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\",\"从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 **“**​标记-清除​ ”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\",\"初始标记： 暂停所有的其他线程(STW)，并记录下 gc roots 直接能引用的对象，速度很快。\",\"并发标记： 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。\",\"重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。\",\"并发清理： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。​\",\"并发重置： 重置本次GC过程中的标记数据。\",\"​​\",\"从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面几个明显的缺点：\",\"对CPU资源敏感（会和服务抢资源）；\",\"无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；\",\"它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理\",\"执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是\\\"concurrent mode failure\\\"，此时会进入stop the world，用serial old垃圾收集器来回收\"]},\"43\":{\"h\":\"\",\"t\":[\"-XX:+UseConcMarkSweepGC：启用cms\",\"-XX:ConcGCThreads：并发的GC线程数\",\"-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）\",\"-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次\",\"-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）\",\"-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整\",\"-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，降低CMS GC标记阶段(也会对年轻代一起做标记，如果在minor gc就干掉了很多对垃圾对象，标记阶段就会减少一些标记时间)时的开销，一般CMS的GC耗时 80%都在标记阶段\",\"-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW\",\"-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;\"]},\"44\":{\"h\":\"三色标记\",\"t\":[\"在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。\",\"这里我们引入“三色标记”来给大家解释下，把gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：\",\"黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。\",\"灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。\",\"白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。\",\"​​\",\"/** * 垃圾收集算法细节之三色标记 * 为了简化例子，代码写法可能不规范，请忽略 */ public class ThreeColorRemark { public static void main(String[] args) { A a = new A(); //开始做并发标记 D d = a.b.d; // 1.读 a.b.d = null; // 2.写 a.d = d; // 3.写 } } class A { B b = new B(); D d = null; } class B { C c = new C(); D d = new D(); } class C { } class D { } \"]},\"45\":{\"h\":\"多标-浮动垃圾\",\"t\":[\"在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。 另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象在标记和回收期间可能也会变为垃圾，这也算是浮动垃圾的一部分。\"]},\"46\":{\"h\":\"漏标-读写屏障\",\"t\":[\"漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案：增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。\",\"增量更新： 就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。\",\"原始快照： 就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)\",\"以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。\"]},\"47\":{\"h\":\"写屏障\",\"t\":[\"给某个对象的成员变量赋值时，其底层代码大概长这样：\",\"/** * @param field 某对象的成员变量，如 a.b.d * @param new_value 新值，如 null */ void oop_field_store(oop* field, oop new_value) { *field = new_value; // 赋值操作 } \",\"所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）:\",\"void oop_field_store(oop* field, oop new_value) { pre_write_barrier(field); // 写屏障-写前操作 *field = new_value; post_write_barrier(field, value); // 写屏障-写后操作 } \"]},\"48\":{\"h\":\"\",\"t\":[\"当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B原来成员变量的引用对象D记录下来：\",\"void pre_write_barrier(oop* field) { oop old_value = *field; // 获取旧值 remark_set.add(old_value); // 记录原来的引用对象 } \"]},\"49\":{\"h\":\"\",\"t\":[\"当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A新的成员变量引用对象D记录下来\"]},\"50\":{\"h\":\"读屏障\",\"t\":[\"oop oop_field_load(oop* field) { pre_load_barrier(field); // 读屏障-读取前操作 return *field; } \",\"读屏障是直接针对第一步：D d = a.b.d，当读取成员变量时，一律记录下来：\",\"void pre_load_barrier(oop* field) { oop old_value = *field; remark_set.add(old_value); // 记录读取到的对象 } \",\"现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。\",\"对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下 ：\",\"CMS：写屏障 + 增量更新\",\"G1，Shenandoah：写屏障 + SATB\",\"ZGC：读屏障\",\"工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。\",\"为什么G1用SATB？CMS用增量更新？\",\"我的理解： SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。\"]},\"51\":{\"h\":\"记忆集与卡表\",\"t\":[\"在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象(老年代的对象引用着新生代的对象)，这种如果又去对老年代再去扫描效率太低了。\",\"为此，在新生代可以引入记录集（Remember Set）的数据结构（记录从非收集区[老年代] 到收集区[新生代] 的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。\",\"垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。\",\"hotspot使用一种叫做“卡表”(Cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。\",\"卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。\",\"hotSpot使用的卡页是2^9大小，即512字节 ​\",\"一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.\",\"GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。\"]},\"52\":{\"h\":\"\",\"t\":[\"卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。\",\"Hotspot使用写屏障维护卡表状态。\"]},\"53\":{\"c\":[\"JVM\"]},\"54\":{\"c\":[\"JVM\",\"垃圾收集器\"]},\"55\":{\"h\":\"05-JVM的垃圾收集器（下）\"},\"56\":{\"h\":\"G1垃圾收集器(-XX:+UseG1GC)\",\"t\":[\"G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.\",\"​​\",\"​​\",\"G1将Java堆划分为多个大小相等的独立区域（Region），JVM目标是不超过2048个Region(JVM源码里TARGET_REGION_NUMBER 定义)，实际可以超过该值，但是不推荐。 一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数-XX:G1HeapRegionSize​手动指定Region大小，但是推荐默认的计算方式。\",\"G1保留了年轻代和老年代的概念，但不再是物理隔离了，他们都是(相同性质的堆可以不连续)Region的集合 默认年轻代占5%，如果堆大小为4096M，那么年轻代就是200M左右内存，对应大概是100个Region，可以通过-XX:G1NewSizePercent设置新生代初始占比。在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过-XX:G1MaxNewSizePercent​调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。\",\"一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。\",\"G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理 G1有专门分配大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50% ，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。\",\"Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。\",\"G1收集器一次GC(主要指Mixed GC)的运作过程大致分为以下几个步骤：\",\"​​\",\"初始标记(Init Mark,STW): 暂停所有其他线程，从gc roots开始标记gc roots能达到的第一个对象，这一步速度很快。\",\"并发标记(Concurrent Marking): 与业务线程一起运行，从第一步标记的对象开始，标记能达到所有对象\",\"最终标记(Remark,STW): 暂停所有其他线程，重新标记漏标对象。\",\"筛选回收(CleanUp,STW): 暂停所有其他线程，筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿STW时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片。(注：CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了ZGC，Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本)\",\"G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。\",\"G1在处理多标和漏标的方式为 ：\",\"多标： 暂不处理，形成浮动垃圾，在下次垃圾回收时再处理 。\",\"漏标： 使用原始快照方式进行处理。\",\"G1被视为JDK1.7以后版本的Java虚拟机中一个重要进化特征。它具备以下特点：\",\"并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。\",\"分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。\",\"空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\",\"可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数\\\"-XX:MaxGCPauseMillis\\\"指定)内完成垃圾收集。\",\"毫无疑问， 可以由用户指定期望的停顿时间是G1收集器很强大的一个功能， 设置不同的期望停顿时间， 可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。 不过， 这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时间再怎么低也得有个限度。 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发Full GC反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。\"]},\"57\":{\"h\":\"G1垃圾收集分类\"},\"58\":{\"h\":\"YoungGC\",\"t\":[\"YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC\"]},\"59\":{\"h\":\"MixedGC\",\"t\":[\"MixedGC不是FullGC，当老年代占有率达到了参数-XX:InitiatingHeapOccupancyPercent​设置的值时则触发，回收所有的Young和部分old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中的对象拷贝到别的region中。拷贝的过程中发现没有足够的空region能够承载拷贝对象就会触发一次FullGC。\"]},\"60\":{\"h\":\"FullGC\",\"t\":[\"停止系统线程，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)\"]},\"61\":{\"h\":\"\",\"t\":[\"-XX:+UseG1GC: 使用G1收集器\",\"-XX:ParallelGCThreads: 指定GC工作的线程数量\",\"-XX:G1HeapRegionSize: 指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区\",\"-XX:MaxGCPauseMillis: 目标暂停时间(默认200ms)\",\"-XX:G1NewSizePercent: 新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)\",\"-XX:G1MaxNewSizePercent: 新生代内存最大空间\",\"-XX:TargetSurvivorRatio: Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代\",\"-XX:MaxTenuringThreshold: 最大年龄阈值(默认15)\",\"-XX:InitiatingHeapOccupancyPercent: 老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了\",\"-XX:G1MixedGCLiveThresholdPercent(默认85%): region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。\",\"-XX:G1MixedGCCountTarget: 在一次回收过程中指定做几次筛选回收(默认8次)，这个参数标识最后的混合回收阶段会执行8次，一次只回收掉一部分的Region，然后系统继续运行，过了一小段时间之后，又再次进行混合回收，重复8次，这样可以让系统不至于单次停顿时间过长。\",\"-XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。\"]},\"62\":{\"h\":\"\",\"t\":[\"假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。或者是当年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。\",\"所以这里的优化核心还是在于调节 -XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc。\"]},\"63\":{\"h\":\"\",\"t\":[\"50%以上的堆被存活对象占用\",\"对象分配和晋升的速度变化非常大\",\"垃圾回收时间特别长，超过1秒\",\"8GB以上的堆内存(建议值)\",\"停顿时间是500ms以内\"]},\"64\":{\"h\":\"\",\"t\":[\"Kafka类似的支撑高并发消息系统大家肯定不陌生，对于kafka来说，每秒处理几万甚至几十万消息时很正常的，一般来说部署kafka需要用大内存机器(比如64G)，也就是说可以给年轻代分配个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题，我们以前常说的对于eden区的young gc是很快的，这种情况下它的执行还会很快吗？很显然，不可能，因为内存太大，处理还是要花不少时间的，假设三四十G内存回收可能最快也要几秒钟，按kafka这个并发量放满三四十G的eden区可能也就一两分钟，那么意味着整个系统每运行一两分钟就会因为young gc卡顿几秒钟没法处理新消息，显然是不行的。\",\"对于这种情况，我们可以使用G1收集器，假设50ms能够回收三到四个G内存，那么设置 -XX:MaxGCPauseMills 为50ms，然后50ms的卡顿其实完全能够接受，用户几乎无感知，这样整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。\",\"适用场景\",\"G1垃圾回收器天生适合这种大JVM内存的场景，可以有效解决大内存带来的垃圾回收时间过长问题。\"]},\"65\":{\"h\":\"ZGC收集器(\",\"t\":[\"参考文章\",\"https://wiki.openjdk.java.net/display/zgc/Main\",\"http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf\",\"ZGC是JDK11开始引入的一个新的低延时垃圾收集器，它的目标之一是将STW控制在10ms左右的同时，支持最高TB级别内存的垃圾回收。\",\"注\",\"根据R大的说法，ZGC是根据Azul的论文，通过软件方式设计的\",\"https://www.usenix.org/legacy/events/vee05/full_papers/p46-click.pdf\",\"Azul PGC简单来说是：它是一个mark-compact GC，但是GC过程中所有的阶段都设计为可以并发的，包括移动对象的阶段，所以GC正常工作的时候除了会在自己的线程上吃点CPU之外并不会显著干扰应用的运行。为了实现上方便，PGC虽然算法上可以做成完全并发，但Azul PGC在Azul VM里的实现还是有三个非常短暂的safepoint，其中第一个是做根集合（root set）扫描，包括全局变量啊线程栈啊啥的里面的对象指针，但不包括GC堆里的对象指针，所以这个暂停就不会随着GC堆的大小而变化（不过会根据线程的多少啊、线程栈的大小之类的而变化）。另外两个暂停也同样不会随着堆大小而变化。\"]},\"66\":{\"h\":\"ZGC的目标\",\"t\":[\"​​\",\"支持TB量级的堆： 在半导体现有的发展情况下，TB级别的堆内存支持，基本可以满足之后数十年的发展。\",\"最大的GC停顿时间不超过10ms：目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，Major GC一般都需要100ms以上（G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反），之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。\",\"奠定未来GC的基础\",\"最糟糕的情况下吞吐量下降15%\",\"另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。\"]},\"67\":{\"h\":\"不分代(暂时)\",\"t\":[\"不区分年轻代和老年代。之前的垃圾收集器进行分代区分是基于\\\"大部分对象都是朝生夕死\\\"的假设，事实上大部分系统的对象也是这种情况。但ZGC目前实现起来太麻烦。具体可参考R大在2018年知乎的回答。\",\"为何 ZGC 不像C4 GC一样采用分代机制？是因为实现复杂度还是另有考虑？ - 知乎 (zhihu.com)\"]},\"68\":{\"h\":\"ZGC内存布局\",\"t\":[\"ZGC是一款基于Region内存布局的，暂时不分代的垃圾收集器，主要使用读屏障，颜色指针等技术实现可并发收集垃圾的垃圾收集器，主要使用标记-整理算法实现。\",\"ZGC的Region可分为大、中、小三类：\",\"小型Region（Small Region） ： 容量固定为2MB， 用于放置小于256KB的小对象。\",\"中型Region（Medium Region） ： 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。\",\"大型Region（Large Region） ： 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配的， 因为复制一个大对象的代价非常高昂。\",\"​​\"]},\"69\":{\"h\":\"ZGC收集过程\",\"t\":[\"​​\",\"并发标记(Concurrent Mark)： 和G1一样，并发标记也是遍历对象图做可达性分析的阶段，它的初始标记(Pause Mark Start)和最终标记(Pause Mark End)阶段会短暂的暂停。但与其说是标记对象(记录对象是否一般标记)，不如说是标记指针(记录指针是否已经被标记)，此时会更新指针中Marked0和Marked1标志位。\",\"并发预备重分配(Concurrent Prepare for Relocate): 这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。\",\"并发重分配(Concurrent Relocate): 重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力\",\"ZGC的颜色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢， 一旦重分配集中某个Region的存活对象都复制完毕后， 这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。\",\"并发重映射(Concurrent Remap): 重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了\"]},\"70\":{\"h\":\"颜色指针\",\"t\":[\"Colored Pointers，即颜色指针，如下图所示，ZGC的核心设计之一。以前的垃圾回收器的GC信息都保存在对象头中，而ZGC的GC信息保存在指针中。\",\"​​\",\"‍\",\"每个对象有64位的指针，具体被划分为：\",\"18位：预留位，给之后使用。\",\"1位：Finalizable标识，用于并发引用有关，它表示这个对象只能通过finalizer才能引用。\",\"1位：Remapped标识，表示该对象未指向重分配集（Relocation Set，表示需要GC的Region集合）中。\",\"1位：Marked1标识，与Marked0配合使用\",\"1位：Marked0标识，和Marked1配合用于辅助GC\",\"42位：对象地址，因此ZGC可以支持2^42=4TB内存\",\"在每个GC周期开始，颜色指针就会互换标志位，使上次GC周期中修正的标志位失效，这样，所有标志都变成了未标记，这时再做GC进行标记存活的对象，并通过标记整理算法清除垃圾对象。\",\"GC周期1：使用Marked0，即周期结束标识为01\",\"GC周期2：使用Marked1，即周期结束标识为10，这样，所有期望的引用都能被重新标记。\",\"ZGC使用了指针的第19-22位，因此ZGC无法使用指针压缩，同时也无法支持32位的操作系统。\"]},\"71\":{\"h\":\"\",\"t\":[\"因为使用了读屏障，一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。\",\"颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。\",\"颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。\"]},\"72\":{\"h\":\"\",\"t\":[\"ZGC之前的垃圾回收器在处理漏标时使用的都是写屏障(Write Barrier)，ZGC使用了完全不同的读屏障(Load Barrier)。在标记和移动阶段，每次从堆内对象的引用类型中读取一个指针时，都会加上一个Load Barriers。\",\"如下面的代码，第一行代码我们尝试读取堆中的一个对象引用obj.fieldA并赋给引用o（fieldA也是一个对象时才会加上读屏障）。如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW。\",\"那么，JVM是如何判断对象被移动过呢？就是利用上面提到的颜色指针，如果指针是Bad Color，那么程序还不能往下执行，需要「slow path」，修正指针；如果指针是Good Color，那么正常往下执行即可：\",\"​​\",\"后面3行代码都不需要加读屏障：\",\"Object p = o这行代码并没有从堆中读取数据；\",\"o.doSomething()也没有从堆中读取数据；\",\"obj.fieldB不是对象引用，而是原子类型。\",\"正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销：\",\"​​\",\"那么，判断对象是Bad Color还是Good Color的依据是什么呢？就是根据上一段提到的Colored Pointers的4个颜色位。当加上读屏障时，根据对象指针中这4位的信息，就能知道当前对象是Bad/Good Color了。\",\"思考\",\"既然低42位指针可以支持4T内存，那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢？\",\"答案肯定是不可以。因为目前主板地址总线最宽只有48bit，4位是颜色位，就只剩44位了，所以受限于目前的硬件，ZGC最大只能支持16T的内存，JDK13就把最大支持堆内存从4T扩大到了16T。\"]},\"73\":{\"h\":\"ZGC存在的问题\",\"t\":[\"ZGC最大的问题是浮动垃圾。ZGC的停顿时间是在10ms以下，但是ZGC的总的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。\",\"ZGC问题\",\"Per大大毫无遮掩地表示当前的ZGC如果遇到非常高的对象分配速率（allocation rate）的话会跟不上，目前唯一有效的“调优”方式就是增大整个GC堆的大小来让ZGC有更大的喘息空间。而添加分代或者Thread-Local GC则可以有效降低这种情况下对堆大小（喘息空间）的需求。 作者：RednaxelaFX 来源：知乎\",\"启用ZGC比较简单，设置JVM参数即可：-XX:+UnlockExperimentalVMOptions 「-XX:+UseZGC」。调优也并不难，因为ZGC调优参数并不多，远不像CMS那么复杂。它和G1一样，可以调优的参数都比较少，大部分工作JVM能很好的自动完成。下图所示是ZGC可以调优的参数：\",\"​​\"]},\"74\":{\"h\":\"\",\"t\":[\"ZGC目前有4中机制触发GC：\",\"定时触发，默认为不使用，可通过ZCollectionInterval参数配置。\",\"预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。\",\"分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。\",\"主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。\"]},\"75\":{\"h\":\"如何选择垃圾回收器\",\"t\":[\"优先调整堆的大小让服务器自己来选择\",\"如果内存小于100M，使用串行收集器\",\"如果是单核，并且没有停顿时间的要求，串行或JVM自己选择\",\"如果允许停顿时间超过1秒，选择并行或者JVM自己选\",\"如果响应时间最重要，并且不能超过1秒，使用并发收集器\",\"4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC\",\"下图有连线的可以搭配使用\",\"​​\",\"JDK 1.8默认使用 Parallel(年轻代和老年代都是)\",\"JDK 1.9开始默认使用 G1，JDK11中删除了CMS垃圾收集器\"]},\"76\":{\"h\":\"安全点与安全区域\"},\"77\":{\"h\":\"安全点(Safe Point)\",\"t\":[\"安全点就是指代码中的一些特定的位置，当线程运行到这些位置时，它的状态是可以确定的，JVM就可以安全的进行一些操作，比如GC等。因此GC也不是随时都能立即触发的，需要等到所有线程运行到安全点时才能触发。\",\"特定的位置有\",\"方法返回之前\",\"调用某个方法之后\",\"抛出异常的位置\",\"循环的末尾\",\"思路\",\"大体实现思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的\"]},\"78\":{\"h\":\"安全区域(Safe Region)\",\"t\":[\"Safe Point是针对正在执行线程设计的，但程序运行中会存在Sleep或者中断的线程，这种线程无法响应JVM的中断请求。因此JVM引入安全区域(Safe Region)概念，Safe Region是指在一段代码片段中，对象的引用关系不会发生变化。在这个区域内进行GC都是安全的。\"]},\"79\":{\"c\":[\"JVM\"]},\"80\":{\"c\":[\"JVM\",\"垃圾收集器\"]},\"81\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"82\":{\"h\":\"JVM\"},\"83\":{\"h\":\"Statudy\"}},\"dirtCount\":0,\"index\":[[\"概念\",{\"1\":{\"78\":1}}],[\"安全区域\",{\"0\":{\"78\":1}}],[\"安全点就是指代码中的一些特定的位置\",{\"1\":{\"77\":1}}],[\"安全点\",{\"0\":{\"77\":1}}],[\"安全点与安全区域\",{\"0\":{\"76\":1}}],[\"轮询标志的地方和安全点是重合的\",{\"1\":{\"77\":1}}],[\"各个线程执行过程时会不停地主动去轮询这个标志\",{\"1\":{\"77\":1}}],[\"仅仅简单地设置一个标志位\",{\"1\":{\"77\":1}}],[\"仅开启方法计数器和回边计数器\",{\"1\":{\"8\":1}}],[\"思路\",{\"1\":{\"77\":1}}],[\"思考\",{\"1\":{\"72\":1}}],[\"循环的末尾\",{\"1\":{\"77\":1}}],[\"抛出异常的位置\",{\"1\":{\"77\":1}}],[\"调用某个方法之后\",{\"1\":{\"77\":1}}],[\"调优也并不难\",{\"1\":{\"73\":1}}],[\"调优\",{\"1\":{\"73\":1}}],[\"选择并行或者jvm自己选\",{\"1\":{\"75\":1}}],[\"距上次gc堆内存增长10\",{\"1\":{\"74\":1}}],[\"耗尽时间\",{\"1\":{\"74\":1}}],[\"耗时更长\",{\"1\":{\"8\":1}}],[\"耗时短以达到更快编译的速度\",{\"1\":{\"8\":1}}],[\"9开始默认使用\",{\"1\":{\"75\":1}}],[\"9\",{\"1\":{\"74\":1}}],[\"99\",{\"1\":{\"35\":1}}],[\"计算内存99\",{\"1\":{\"74\":1}}],[\"计数器\",{\"1\":{\"24\":1}}],[\"计数器的计数一旦溢出阈值\",{\"1\":{\"7\":1}}],[\"预热触发\",{\"1\":{\"74\":1}}],[\"预留位\",{\"1\":{\"70\":1}}],[\"定时触发\",{\"1\":{\"74\":1}}],[\"定义\",{\"1\":{\"56\":1}}],[\"远不像cms那么复杂\",{\"1\":{\"73\":1}}],[\"远远比并发标记阶段时间短\",{\"1\":{\"42\":1}}],[\"作者\",{\"1\":{\"73\":1}}],[\"作用是统计一个方法中循环体代码执行的次数\",{\"1\":{\"7\":1}}],[\"喘息空间\",{\"1\":{\"73\":1}}],[\"方式就是增大整个gc堆的大小来让zgc有更大的喘息空间\",{\"1\":{\"73\":1}}],[\"方法返回之前\",{\"1\":{\"77\":1}}],[\"方法区主要回收的是无用的类\",{\"1\":{\"31\":1}}],[\"方法只会被执行一次\",{\"1\":{\"30\":1}}],[\"方法\",{\"1\":{\"30\":1}}],[\"方法如果需要继承\",{\"1\":{\"9\":1}}],[\"方法太大不光会导致方法无法内联\",{\"1\":{\"9\":1}}],[\"方法内联之后会继续进行无用代码消除\",{\"1\":{\"9\":1}}],[\"方法内联往往还是很多后续优化手段的基础\",{\"1\":{\"9\":1}}],[\"方法内联的优化本质就是把目标方法的代码原封不动的\",{\"1\":{\"9\":1}}],[\"方法内联就是将目标方法的执行代码复制到调用该方法的地方\",{\"1\":{\"9\":1}}],[\"方法内联\",{\"0\":{\"9\":1}}],[\"方法调用计数器\",{\"1\":{\"7\":1}}],[\"答案肯定是不可以\",{\"1\":{\"72\":1}}],[\"既然低42位指针可以支持4t内存\",{\"1\":{\"72\":1}}],[\"判断对象是bad\",{\"1\":{\"72\":1}}],[\"官方的测试数据是需要多出额外4\",{\"1\":{\"72\":1}}],[\"正是因为load\",{\"1\":{\"72\":1}}],[\"正常情况g1的垃圾收集是先做mixedgc\",{\"1\":{\"59\":1}}],[\"正常情况不会被回收\",{\"1\":{\"29\":1}}],[\"正常情况下\",{\"1\":{\"12\":1}}],[\"于是应用代码就永远都会持有更新后的有效指针\",{\"1\":{\"72\":1}}],[\"于是引用计数算法无法通知\",{\"1\":{\"27\":1}}],[\"修正指针\",{\"1\":{\"72\":1}}],[\"修正\",{\"1\":{\"72\":1}}],[\"给之后使用\",{\"1\":{\"70\":1}}],[\"给某个对象的成员变量赋值时\",{\"1\":{\"47\":1}}],[\"颜色指针具备强大的扩展性\",{\"1\":{\"71\":1}}],[\"颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量\",{\"1\":{\"71\":1}}],[\"颜色指针就会互换标志位\",{\"1\":{\"70\":1}}],[\"颜色指针\",{\"0\":{\"70\":1}}],[\"颜色指针等技术实现可并发收集垃圾的垃圾收集器\",{\"1\":{\"68\":1}}],[\"原来记录新旧对象关系的转发表就可以释放掉了\",{\"1\":{\"69\":1}}],[\"原始快照\",{\"1\":{\"46\":1}}],[\"反正它们都是要遍历所有对象的\",{\"1\":{\"69\":1}}],[\"反而会适得其反\",{\"1\":{\"66\":1}}],[\"合并到了下一次垃圾收集循环中的并发标记阶段里去完成\",{\"1\":{\"69\":1}}],[\"功能\",{\"1\":{\"69\":1}}],[\"功能之外\",{\"1\":{\"50\":1}}],[\"能力\",{\"1\":{\"69\":2}}],[\"能让使用者明确指定在一个长度为m毫秒的时间片段\",{\"1\":{\"56\":1}}],[\"自愈\",{\"1\":{\"69\":3}}],[\"自然可以获得很高的单线程收集效率\",{\"1\":{\"39\":1}}],[\"容量不固定\",{\"1\":{\"68\":1}}],[\"容量固定为32mb\",{\"1\":{\"68\":1}}],[\"容量固定为2mb\",{\"1\":{\"68\":1}}],[\"容纳的话\",{\"1\":{\"24\":1}}],[\"小型region\",{\"1\":{\"68\":1}}],[\"小三类\",{\"1\":{\"68\":1}}],[\"小于等于32g\",{\"1\":{\"21\":1}}],[\"zhihu\",{\"1\":{\"67\":1}}],[\"zgc目前有4中机制触发gc\",{\"1\":{\"74\":1}}],[\"zgc问题\",{\"1\":{\"73\":1}}],[\"zgc最大的问题是浮动垃圾\",{\"1\":{\"73\":1}}],[\"zgc最大只能支持16t的内存\",{\"1\":{\"72\":1}}],[\"zgc存在的问题\",{\"0\":{\"73\":1}}],[\"zgc使用了完全不同的读屏障\",{\"1\":{\"72\":1}}],[\"zgc使用了指针的第19\",{\"1\":{\"70\":1}}],[\"zgc之前的垃圾回收器在处理漏标时使用的都是写屏障\",{\"1\":{\"72\":1}}],[\"zgc只使用了读屏障\",{\"1\":{\"71\":1}}],[\"zgc就能完成收集\",{\"1\":{\"71\":1}}],[\"zgc很巧妙地把并发重映射阶段要做的工作\",{\"1\":{\"69\":1}}],[\"zgc将这种行为称为指针的\",{\"1\":{\"69\":1}}],[\"zgc每次回收都会扫描所有的region\",{\"1\":{\"69\":1}}],[\"zgc收集过程\",{\"0\":{\"69\":1}}],[\"zgc收集器能仅从引用上就明确得知一个对象是否处于重分配集之中\",{\"1\":{\"69\":1}}],[\"zgc收集器\",{\"0\":{\"65\":1}}],[\"zgc的停顿时间是在10ms以下\",{\"1\":{\"73\":1}}],[\"zgc的核心设计之一\",{\"1\":{\"70\":1}}],[\"zgc的颜色指针因为\",{\"1\":{\"69\":1}}],[\"zgc的region可分为大\",{\"1\":{\"68\":1}}],[\"zgc的目标\",{\"0\":{\"66\":1}}],[\"zgc内存布局\",{\"0\":{\"68\":1}}],[\"zgc是一款基于region内存布局的\",{\"1\":{\"68\":1}}],[\"zgc是根据azul的论文\",{\"1\":{\"65\":1}}],[\"zgc是jdk11开始引入的一个新的低延时垃圾收集器\",{\"1\":{\"65\":1}}],[\"zgc和shenandoah收集器\",{\"1\":{\"51\":1}}],[\"zgc\",{\"1\":{\"50\":1,\"65\":2,\"67\":1}}],[\"知乎\",{\"1\":{\"67\":1,\"73\":1}}],[\"具体被划分为\",{\"1\":{\"70\":1}}],[\"具体可参考r大在2018年知乎的回答\",{\"1\":{\"67\":1}}],[\"具体的优化策略可参见openjdk的wiki\",{\"1\":{\"8\":1}}],[\"事实上大部分系统的对象也是这种情况\",{\"1\":{\"67\":1}}],[\"事实上并不只是新生代\",{\"1\":{\"51\":1}}],[\"几百g以上用zgc\",{\"1\":{\"75\":1}}],[\"几百g甚至上t堆的停顿时间也是10ms以下\",{\"1\":{\"66\":1}}],[\"几十g堆的停顿时间是10ms以下\",{\"1\":{\"66\":1}}],[\"几乎不用\",{\"1\":{\"29\":1}}],[\"奠定未来gc的基础\",{\"1\":{\"66\":1}}],[\"支持tb量级的堆\",{\"1\":{\"66\":1}}],[\"支持最高tb级别内存的垃圾回收\",{\"1\":{\"65\":1}}],[\"扫描\",{\"1\":{\"65\":1}}],[\"~pliden\",{\"1\":{\"65\":1}}],[\"参考文章\",{\"1\":{\"65\":1}}],[\"参数使用\",{\"1\":{\"9\":1}}],[\"参数\",{\"1\":{\"9\":1}}],[\"参数信息\",{\"1\":{\"8\":1}}],[\"适用场景\",{\"1\":{\"64\":1}}],[\"适当提高该值\",{\"1\":{\"0\":1}}],[\"处理还是要花不少时间的\",{\"1\":{\"64\":1}}],[\"kafka类似的支撑高并发消息系统大家肯定不陌生\",{\"1\":{\"64\":1}}],[\"停顿时间是500ms以内\",{\"1\":{\"63\":1}}],[\"停止系统线程\",{\"1\":{\"60\":1}}],[\"建议值\",{\"1\":{\"63\":1}}],[\"建立回边计数器就是为了发现一个方法体内被频繁调用的循环\",{\"1\":{\"7\":1}}],[\"垃圾回收时间特别长\",{\"1\":{\"63\":1}}],[\"垃圾收集器\",{\"2\":{\"54\":1,\"80\":1}}],[\"垃圾收集场景中\",{\"1\":{\"51\":1}}],[\"垃圾收集算法细节之三色标记\",{\"1\":{\"44\":1}}],[\"垃圾收集子系统的压力将会下降很多\",{\"1\":{\"12\":1}}],[\"频繁触发mixed\",{\"1\":{\"62\":1}}],[\"达到了survivor区域的50\",{\"1\":{\"62\":1}}],[\"达到该值就会触发full\",{\"1\":{\"0\":1}}],[\"存活下来的对象过多\",{\"1\":{\"62\":1}}],[\"存活对象过多\",{\"1\":{\"61\":1}}],[\"了\",{\"1\":{\"62\":1}}],[\"意味着本次混合回收就结束了\",{\"1\":{\"61\":1}}],[\"又再次进行混合回收\",{\"1\":{\"61\":1}}],[\"过了一小段时间之后\",{\"1\":{\"61\":1}}],[\"总和超过了survivor区域的50\",{\"1\":{\"61\":1}}],[\"总消耗时间的比值\",{\"1\":{\"40\":1}}],[\"值配置整数\",{\"1\":{\"61\":1}}],[\"目前唯一有效的\",{\"1\":{\"73\":1}}],[\"目前一般线上环境运行良好的java应用minor\",{\"1\":{\"66\":1}}],[\"目标暂停时间\",{\"1\":{\"61\":1}}],[\"目的就是让这种对象在本轮gc清理中能存活下来\",{\"1\":{\"46\":1}}],[\"好空闲出来一批region来供下一次mixedgc使用\",{\"1\":{\"60\":1}}],[\"拷贝的过程中发现没有足够的空region能够承载拷贝对象就会触发一次fullgc\",{\"1\":{\"59\":1}}],[\"继续给新对象存放\",{\"1\":{\"58\":1}}],[\"younggc并不是说现有的eden区放满了就会马上触发\",{\"1\":{\"58\":1}}],[\"younggc\",{\"0\":{\"58\":1}}],[\"导致进入survivor区域后触发了动态年龄判定规则\",{\"1\":{\"62\":1}}],[\"导致系统运行很久\",{\"1\":{\"62\":1}}],[\"导致垃圾慢慢堆积\",{\"1\":{\"56\":1}}],[\"导致每次选出来的回收集只占堆内存很小的一部分\",{\"1\":{\"56\":1}}],[\"导致它们的引用计数器都不为0\",{\"1\":{\"27\":1}}],[\"毕竟g1是要冻结用户线程来复制对象的\",{\"1\":{\"56\":1}}],[\"必须是符合实际的\",{\"1\":{\"56\":1}}],[\"必须解决\",{\"1\":{\"46\":1}}],[\"期望值\",{\"1\":{\"56\":1}}],[\"毫无疑问\",{\"1\":{\"56\":1}}],[\"共同的关注点\",{\"1\":{\"56\":1}}],[\"降低停顿时间是g1\",{\"1\":{\"56\":1}}],[\"降低cms\",{\"1\":{\"43\":1}}],[\"清理和压缩整理\",{\"1\":{\"60\":1}}],[\"清理\",{\"1\":{\"56\":1}}],[\"清除​\",{\"1\":{\"42\":1}}],[\"清除算法\",{\"0\":{\"37\":1}}],[\"清除\",{\"1\":{\"35\":2,\"37\":1,\"38\":1,\"42\":1}}],[\"虽然g1可以不需要其他收集器配合就能独立管理整个gc堆\",{\"1\":{\"56\":1}}],[\"虽然我们对各个收集器进行比较\",{\"1\":{\"38\":1}}],[\"部分其他收集器原本需要停顿java线程来执行gc动作\",{\"1\":{\"56\":1}}],[\"7以后版本的java虚拟机中一个重要进化特征\",{\"1\":{\"56\":1}}],[\"形成浮动垃圾\",{\"1\":{\"56\":1}}],[\"暂时不分代的垃圾收集器\",{\"1\":{\"68\":1}}],[\"暂时\",{\"0\":{\"67\":1}}],[\"暂不处理\",{\"1\":{\"56\":1}}],[\"暂停所有其他线程\",{\"1\":{\"56\":3}}],[\"暂停所有的其他线程\",{\"1\":{\"42\":1}}],[\"保证了g1收集器在有限时间内可以尽可能高的收集效率\",{\"1\":{\"56\":1}}],[\"优先调整堆的大小让服务器自己来选择\",{\"1\":{\"75\":1}}],[\"优先选择回收价值最大的region\",{\"1\":{\"56\":1}}],[\"优化的规模与耗时\",{\"1\":{\"8\":1}}],[\"优化后的机器码执行效率更高\",{\"1\":{\"8\":1}}],[\"注\",{\"1\":{\"56\":1,\"65\":1}}],[\"注意\",{\"1\":{\"30\":1,\"35\":1}}],[\"时触发\",{\"1\":{\"74\":1}}],[\"时间是用户可控制的\",{\"1\":{\"56\":1}}],[\"时的开销\",{\"1\":{\"43\":1}}],[\"筛选回收阶段首先对各个region的回收价值和成本进行排序\",{\"1\":{\"56\":1}}],[\"筛选回收\",{\"1\":{\"56\":1}}],[\"筛选的条件是此对象是否有必要执行finalize\",{\"1\":{\"30\":1}}],[\"最多三次\",{\"1\":{\"74\":1}}],[\"最小容量可低至4mb\",{\"1\":{\"68\":1}}],[\"最糟糕的情况下吞吐量下降15\",{\"1\":{\"66\":1}}],[\"最大的gc停顿时间不超过10ms\",{\"1\":{\"66\":1}}],[\"最大年龄阈值\",{\"1\":{\"61\":1}}],[\"最终占满堆引发full\",{\"1\":{\"56\":1}}],[\"最终标记\",{\"1\":{\"56\":1}}],[\"最简单的做法就是一个指令就翻译一次成为机器码进行之心\",{\"1\":{\"6\":1}}],[\"与marked0配合使用\",{\"1\":{\"70\":1}}],[\"与cms的\",{\"1\":{\"56\":1}}],[\"与业务线程一起运行\",{\"1\":{\"56\":1}}],[\"与其他收集器的单线程相比\",{\"1\":{\"39\":1}}],[\"唯一不同的是对大对象的处理\",{\"1\":{\"56\":1}}],[\"之前的垃圾收集器进行分代区分是基于\",{\"1\":{\"67\":1}}],[\"之前说过\",{\"1\":{\"8\":1}}],[\"之所以能做到这一点是因为它的停顿时间主要跟root扫描有关\",{\"1\":{\"66\":1}}],[\"之后可能又会变成老年代\",{\"1\":{\"56\":1}}],[\"假如zgc全过程需要执行10分钟\",{\"1\":{\"73\":1}}],[\"假如逃逸分析能够证明一个对象不会被方法外部访问\",{\"1\":{\"11\":1}}],[\"假设50ms能够回收三到四个g内存\",{\"1\":{\"64\":1}}],[\"假设三四十g内存回收可能最快也要几秒钟\",{\"1\":{\"64\":1}}],[\"假设参数\",{\"1\":{\"62\":1}}],[\"假设年轻代现在有1000个region\",{\"1\":{\"56\":1}}],[\"他们都是\",{\"1\":{\"56\":1}}],[\"他也不可能像堆中那么豪横的使用内存空间\",{\"1\":{\"12\":1}}],[\"下图有连线的可以搭配使用\",{\"1\":{\"75\":1}}],[\"下图所示是zgc可以调优的参数\",{\"1\":{\"73\":1}}],[\"下\",{\"0\":{\"55\":1}}],[\"否则为0\",{\"1\":{\"51\":1}}],[\"卡页\",{\"1\":{\"51\":1}}],[\"卡表变脏上面已经说了\",{\"1\":{\"52\":1}}],[\"卡表是使用一个字节数组实现\",{\"1\":{\"51\":1}}],[\"卡表\",{\"1\":{\"51\":1}}],[\"关于卡表与记忆集的关系\",{\"1\":{\"51\":1}}],[\"关闭资源\",{\"1\":{\"30\":1}}],[\"典型的如g1\",{\"1\":{\"51\":1}}],[\"行为的垃圾收集器\",{\"1\":{\"51\":1}}],[\"到原本的字段里\",{\"1\":{\"72\":1}}],[\"到收集区\",{\"1\":{\"51\":1}}],[\"到发起调用的方法之中\",{\"1\":{\"9\":1}}],[\"记忆集与卡表\",{\"0\":{\"51\":1}}],[\"记录从旧对象到新对象的转向关系\",{\"1\":{\"69\":1}}],[\"记录从非收集区\",{\"1\":{\"51\":1}}],[\"记录指针是否已经被标记\",{\"1\":{\"69\":1}}],[\"记录对象是否一般标记\",{\"1\":{\"69\":1}}],[\"记录读取到的对象\",{\"1\":{\"50\":1}}],[\"记录原来的引用对象\",{\"1\":{\"48\":1}}],[\"记录那些内存块可用\",{\"1\":{\"18\":1}}],[\"我的理解\",{\"1\":{\"50\":1}}],[\"我们以前常说的对于eden区的young\",{\"1\":{\"64\":1}}],[\"我们可以使用g1收集器\",{\"1\":{\"64\":1}}],[\"我们可以利用写屏障\",{\"1\":{\"48\":1,\"49\":1}}],[\"我们可以通过以下一些方法提高内联发生的概率\",{\"1\":{\"9\":1}}],[\"我们能做的就是根据具体应用场景选择适合自己的垃圾收集器\",{\"1\":{\"38\":1}}],[\"我们更关注jvm在后端编译过程中如何提升执⾏的效率\",{\"1\":{\"5\":1}}],[\"区引用的变化\",{\"1\":{\"50\":1}}],[\"区别主要在于它可以和\",{\"1\":{\"41\":1}}],[\"工程实现中\",{\"1\":{\"50\":1}}],[\"深度遍历等等\",{\"1\":{\"50\":1}}],[\"深入理解jvm执行引擎\",{\"0\":{\"3\":1}}],[\"遍历方式可以是广度\",{\"1\":{\"50\":1}}],[\"缓存日志等方式进行实现\",{\"1\":{\"50\":1}}],[\"缓刑\",{\"1\":{\"30\":1}}],[\"队列\",{\"1\":{\"50\":1}}],[\"现代追踪式\",{\"1\":{\"50\":1}}],[\"获取旧值\",{\"1\":{\"48\":1}}],[\"赋值操作\",{\"1\":{\"47\":1}}],[\"新值\",{\"1\":{\"47\":1}}],[\"新生代内存最大空间\",{\"1\":{\"61\":1}}],[\"新生代内存初始空间\",{\"1\":{\"61\":1}}],[\"新生代\",{\"1\":{\"51\":1}}],[\"新生代采用复制算法​\",{\"1\":{\"39\":1,\"40\":1,\"41\":1}}],[\"新生代大小\",{\"1\":{\"0\":1}}],[\"某对象的成员变量\",{\"1\":{\"47\":1}}],[\"待下一轮gc的时候重新扫描\",{\"1\":{\"46\":1}}],[\"再将这些记录过的引用关系中的灰色对象为根\",{\"1\":{\"46\":1}}],[\"再将这些记录过的引用关系中的黑色对象为根\",{\"1\":{\"46\":1}}],[\"增量更新\",{\"1\":{\"46\":2,\"50\":1}}],[\"有两种解决方案\",{\"1\":{\"46\":1}}],[\"漏标会导致被引用的对象被当成垃圾误删除\",{\"1\":{\"46\":1}}],[\"漏标\",{\"0\":{\"46\":1},\"1\":{\"56\":1}}],[\"本次垃圾回收可能只能停顿200毫秒\",{\"1\":{\"56\":1}}],[\"本轮不会进行清除\",{\"1\":{\"45\":1}}],[\"本地方法栈的变量等等\",{\"1\":{\"28\":1}}],[\"本地线程分配缓冲\",{\"1\":{\"18\":1}}],[\"针对并发标记\",{\"1\":{\"45\":1}}],[\"被称之为\",{\"1\":{\"45\":1}}],[\"被标记为非垃圾对象\",{\"1\":{\"45\":1}}],[\"被销毁\",{\"1\":{\"45\":1}}],[\"浮动垃圾并不会影响垃圾回收的正确性\",{\"1\":{\"45\":1}}],[\"浮动垃圾\",{\"0\":{\"45\":1},\"1\":{\"45\":1}}],[\"写后操作\",{\"1\":{\"47\":1}}],[\"写前操作\",{\"1\":{\"47\":1}}],[\"写屏障\",{\"0\":{\"47\":1},\"1\":{\"47\":2,\"50\":2}}],[\"写\",{\"1\":{\"44\":2}}],[\"读取前操作\",{\"1\":{\"50\":1}}],[\"读屏障也会发现并修正指针\",{\"1\":{\"72\":1}}],[\"读屏障可以用于支持移动对象的并发执行等\",{\"1\":{\"50\":1}}],[\"读屏障是直接针对第一步\",{\"1\":{\"50\":1}}],[\"读屏障\",{\"0\":{\"50\":1},\"1\":{\"50\":2,\"69\":1}}],[\"读写屏障还有其他功能\",{\"1\":{\"50\":1}}],[\"读写屏障\",{\"0\":{\"46\":1}}],[\"读\",{\"1\":{\"44\":1}}],[\"开始后产生的新对象\",{\"1\":{\"45\":1}}],[\"开始做并发标记\",{\"1\":{\"44\":1}}],[\"开启用户线程\",{\"1\":{\"42\":1}}],[\"开启全部性能监控\",{\"1\":{\"8\":1}}],[\"请忽略\",{\"1\":{\"44\":1}}],[\"代码写法可能不规范\",{\"1\":{\"44\":1}}],[\"代表每次fullgc后都会压缩一次\",{\"1\":{\"43\":1}}],[\"若在分析结束的阶段\",{\"1\":{\"44\":1}}],[\"显然是不行的\",{\"1\":{\"64\":1}}],[\"显然在可达性分析刚刚开始的阶段\",{\"1\":{\"44\":1}}],[\"显然执⾏效率是⽐不上c\",{\"1\":{\"6\":1}}],[\"白色\",{\"1\":{\"44\":1}}],[\"灰色集合可以通过栈\",{\"1\":{\"50\":1}}],[\"灰色\",{\"1\":{\"44\":1}}],[\"且必须是2的n次幂\",{\"1\":{\"61\":1}}],[\"且这个对象的所有引用都已经扫描过\",{\"1\":{\"44\":1}}],[\"且gc压力会比较大\",{\"1\":{\"21\":1}}],[\"表示需要gc的region集合\",{\"1\":{\"70\":1}}],[\"表示该对象未指向重分配集\",{\"1\":{\"70\":1}}],[\"表示该元素变脏\",{\"1\":{\"51\":1}}],[\"表示对象尚未被垃圾收集器访问过\",{\"1\":{\"44\":1}}],[\"表示对象已经被垃圾收集器访问过\",{\"1\":{\"44\":2}}],[\"表示在初始标记的时候多线程执行\",{\"1\":{\"43\":1}}],[\"黑色集合一般都不会出现\",{\"1\":{\"50\":1}}],[\"黑色对象一旦新插入了指向白色对象的引用之后\",{\"1\":{\"46\":1}}],[\"黑色对象不可能直接\",{\"1\":{\"44\":1}}],[\"黑色的对象代表已经扫描过\",{\"1\":{\"44\":1}}],[\"黑色\",{\"1\":{\"44\":1}}],[\"按kafka这个并发量放满三四十g的eden区可能也就一两分钟\",{\"1\":{\"64\":1}}],[\"按照\",{\"1\":{\"44\":1}}],[\"按后退时\",{\"1\":{\"29\":1}}],[\"把gc\",{\"1\":{\"44\":1}}],[\"三色标记\",{\"0\":{\"44\":1},\"1\":{\"44\":1}}],[\"缩短stw\",{\"1\":{\"43\":2}}],[\"多核环境下的硬件优势\",{\"1\":{\"56\":1}}],[\"多标\",{\"0\":{\"45\":1},\"1\":{\"56\":1}}],[\"多标和漏标的情况就有可能发生\",{\"1\":{\"44\":1}}],[\"多少次fullgc之后压缩一次\",{\"1\":{\"43\":1}}],[\"多线程并发资源竞争是一个很复杂的场景\",{\"1\":{\"13\":1}}],[\"减少碎片\",{\"1\":{\"43\":1}}],[\"减少热点阈值或增加方法体阈值\",{\"1\":{\"9\":1}}],[\"用于并发引用有关\",{\"1\":{\"70\":1}}],[\"用于放置4mb或以上的大对象\",{\"1\":{\"68\":1}}],[\"用于放置大于等于256kb但小于4mb的对象\",{\"1\":{\"68\":1}}],[\"用于放置小于256kb的小对象\",{\"1\":{\"68\":1}}],[\"用范围更大的扫描成本换取省去g1中记忆集的维护成本\",{\"1\":{\"69\":1}}],[\"用户几乎无感知\",{\"1\":{\"64\":1}}],[\"用serial\",{\"1\":{\"42\":1}}],[\"用来判断是否需要对方法进行内联优化\",{\"1\":{\"9\":1}}],[\"系统一边运行\",{\"1\":{\"42\":1}}],[\"特定的位置有\",{\"1\":{\"77\":1}}],[\"特别是在并发标记和并发清理阶段会出现\",{\"1\":{\"42\":1}}],[\"特出的一种标记算法\",{\"1\":{\"38\":1}}],[\"低停顿\",{\"1\":{\"42\":1}}],[\"重定位过程相关的数据\",{\"1\":{\"71\":1}}],[\"重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用\",{\"1\":{\"69\":1}}],[\"重分配是zgc执行过程中的核心阶段\",{\"1\":{\"69\":1}}],[\"重复8次\",{\"1\":{\"61\":1}}],[\"重新深度扫描对象的话g1的代价会比cms高\",{\"1\":{\"50\":1}}],[\"重新扫描一次\",{\"1\":{\"46\":2}}],[\"重新标记漏标对象\",{\"1\":{\"56\":1}}],[\"重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"42\":1}}],[\"重新标记\",{\"1\":{\"42\":1}}],[\"重置本次gc过程中的标记数据\",{\"1\":{\"42\":1}}],[\"见下面三色标记算法详解\",{\"1\":{\"42\":1}}],[\"见下面详解\",{\"1\":{\"42\":1}}],[\"做重新标记\",{\"1\":{\"42\":1}}],[\"速度很快\",{\"1\":{\"42\":1}}],[\"直到下一次eden区放满\",{\"1\":{\"58\":1}}],[\"直到它收集结束\",{\"1\":{\"39\":1}}],[\"直接能引用的对象\",{\"1\":{\"42\":1}}],[\"初始标记\",{\"1\":{\"42\":1,\"56\":1}}],[\"初始化零值之后\",{\"1\":{\"20\":1}}],[\"初始化零值\",{\"0\":{\"19\":1}}],[\"整个过程分为四个步骤\",{\"1\":{\"42\":1}}],[\"整理​算法\",{\"1\":{\"39\":1,\"40\":1,\"41\":1}}],[\"整理算法实现\",{\"1\":{\"68\":1}}],[\"整理算法\",{\"0\":{\"38\":1}}],[\"整理\",{\"1\":{\"35\":2,\"40\":1}}],[\"基于正态分布统计\",{\"1\":{\"74\":1}}],[\"基于这种情况\",{\"1\":{\"0\":1}}],[\"基本可以满足之后数十年的发展\",{\"1\":{\"66\":1}}],[\"基本上\",{\"1\":{\"42\":1}}],[\"配合工作\",{\"1\":{\"41\":1}}],[\"真正意义上的并发收集器\",{\"1\":{\"41\":1}}],[\"模式下的虚拟机的首要选择\",{\"1\":{\"41\":1}}],[\"都会加上一个load\",{\"1\":{\"72\":1}}],[\"都会面临相同的问题\",{\"1\":{\"51\":1}}],[\"都是把要回收的region里的存活对象放入其他region\",{\"1\":{\"61\":1}}],[\"都在标记阶段\",{\"1\":{\"43\":1}}],[\"都可以优先考虑\",{\"1\":{\"40\":1}}],[\"都不能分解\",{\"1\":{\"11\":1}}],[\"资源的场合\",{\"1\":{\"40\":1}}],[\"等到下一轮gc再深度扫描\",{\"1\":{\"50\":1}}],[\"等并发扫描结束之后\",{\"1\":{\"46\":1}}],[\"等垃圾收集器的关注点更多的是用户线程的停顿时间\",{\"1\":{\"40\":1}}],[\"等级\",{\"1\":{\"8\":1}}],[\"高效率的利用\",{\"1\":{\"40\":1}}],[\"核数相同\",{\"1\":{\"40\":1}}],[\"控制参数\",{\"1\":{\"40\":1}}],[\"另一种用途是作为\",{\"1\":{\"39\":1}}],[\"另外两个暂停也同样不会随着堆大小而变化\",{\"1\":{\"65\":1}}],[\"另外一个region花50ms能回收20m垃圾\",{\"1\":{\"56\":1}}],[\"另外\",{\"1\":{\"6\":1,\"9\":2,\"45\":1,\"66\":1}}],[\"寻找最优秀的垃圾收集器的过程仍然在继续\",{\"1\":{\"39\":1}}],[\"带来的不良用户体验\",{\"1\":{\"39\":1}}],[\"老年代占用空间达到整堆内存阈值\",{\"1\":{\"61\":1}}],[\"老年代之间才有跨代引用的问题\",{\"1\":{\"51\":1}}],[\"老年代\",{\"1\":{\"51\":1}}],[\"老年代的对象引用着新生代的对象\",{\"1\":{\"51\":1}}],[\"老年代采用标记\",{\"1\":{\"39\":1,\"40\":1,\"41\":1}}],[\"老年代空间担保\",{\"0\":{\"26\":1}}],[\"更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程\",{\"1\":{\"39\":1}}],[\"更加没有万能的垃圾收集器\",{\"1\":{\"38\":1}}],[\"大体实现思想是当垃圾收集需要中断线程的时候\",{\"1\":{\"77\":1}}],[\"大部分工作jvm能很好的自动完成\",{\"1\":{\"73\":1}}],[\"大部分对象都是朝生夕死\",{\"1\":{\"67\":1}}],[\"大型region在zgc的实现中是不会被重分配的\",{\"1\":{\"68\":1}}],[\"大型region\",{\"1\":{\"68\":2}}],[\"大对象的判定规则就是一个大对象超过了一个region大小的50\",{\"1\":{\"56\":1}}],[\"大对象直接进入老年代\",{\"0\":{\"23\":1}}],[\"大家看名字就知道这个收集器是一个单线程收集器了\",{\"1\":{\"39\":1}}],[\"历史最悠久的垃圾收集器了\",{\"1\":{\"39\":1}}],[\"收集算法\",{\"1\":{\"40\":1}}],[\"收集算法出现了\",{\"1\":{\"36\":1}}],[\"收集器收集的速度逐渐跟不上分配器分配的速度\",{\"1\":{\"56\":1}}],[\"收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可\",{\"1\":{\"51\":1}}],[\"收集器外\",{\"1\":{\"41\":1}}],[\"收集器配合使用\",{\"1\":{\"41\":1}}],[\"收集器很类似\",{\"1\":{\"41\":1}}],[\"收集器其实跟\",{\"1\":{\"41\":1}}],[\"收集器其实就是\",{\"1\":{\"40\":1}}],[\"收集器\",{\"1\":{\"40\":1,\"41\":1}}],[\"收集器和\",{\"1\":{\"40\":1}}],[\"收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量\",{\"1\":{\"40\":1}}],[\"收集器关注点是吞吐量\",{\"1\":{\"40\":1}}],[\"收集器类似\",{\"1\":{\"40\":1}}],[\"收集器的多线程版本\",{\"1\":{\"40\":1}}],[\"收集器的后备方案\",{\"1\":{\"39\":1}}],[\"收集器的老年代版本\",{\"1\":{\"39\":1,\"40\":1}}],[\"收集器搭配使用\",{\"1\":{\"39\":1}}],[\"收集器是一种\",{\"1\":{\"42\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"42\":1}}],[\"收集器是\",{\"1\":{\"39\":1,\"40\":1}}],[\"收集器是最基本\",{\"1\":{\"39\":1}}],[\"收集器由于没有线程交互的开销\",{\"1\":{\"39\":1}}],[\"收集器有没有优于其他垃圾收集器的地方呢\",{\"1\":{\"39\":1}}],[\"串行或jvm自己选择\",{\"1\":{\"75\":1}}],[\"串行\",{\"1\":{\"39\":1}}],[\"试想一下\",{\"1\":{\"38\":1}}],[\"然后立即根据region上的转发表记录将访问转发到新复制的对象上\",{\"1\":{\"69\":1}}],[\"然后50ms的卡顿其实完全能够接受\",{\"1\":{\"64\":1}}],[\"然后这个region中的垃圾对象全部清理掉\",{\"1\":{\"61\":1}}],[\"然后系统继续运行\",{\"1\":{\"61\":1}}],[\"然后采用单线程进行标记\",{\"1\":{\"60\":1}}],[\"然后垃圾回收又被触发的情况\",{\"1\":{\"42\":1}}],[\"然后直接清理掉端边界以外的内存\",{\"1\":{\"38\":1}}],[\"然后再把使用的空间一次清理掉\",{\"1\":{\"36\":1}}],[\"效率不高\",{\"1\":{\"37\":1}}],[\"效率问题\",{\"1\":{\"37\":1}}],[\"效率高\",{\"1\":{\"27\":1}}],[\"统一回收所有未被标记的对象\",{\"1\":{\"37\":1}}],[\"倍以上\",{\"1\":{\"35\":1}}],[\"算法不同\",{\"1\":{\"56\":1}}],[\"算法会导致收集结束时会有大量空间碎片产生\",{\"1\":{\"42\":1}}],[\"算法会比复制算法慢\",{\"1\":{\"35\":1}}],[\"算法实现的收集器\",{\"1\":{\"56\":1}}],[\"算法实现的\",{\"1\":{\"42\":1,\"56\":1}}],[\"算法\",{\"1\":{\"40\":1}}],[\"算法一样\",{\"1\":{\"38\":1}}],[\"算法分为\",{\"1\":{\"37\":1}}],[\"算法进行垃圾收集\",{\"1\":{\"35\":1}}],[\"或超过5分钟时\",{\"1\":{\"74\":1}}],[\"或者是当年轻代gc过后\",{\"1\":{\"62\":1}}],[\"或\",{\"1\":{\"35\":2}}],[\"死去\",{\"1\":{\"35\":1}}],[\"近\",{\"1\":{\"35\":1}}],[\"堆分为新生代和老年代\",{\"1\":{\"35\":1}}],[\"堆中不存在该类的任何实例\",{\"1\":{\"31\":1}}],[\"堆中几乎放着所有的对象实例\",{\"1\":{\"26\":1}}],[\"上\",{\"0\":{\"34\":1}}],[\"无需了解跨代引用指针的全部细节\",{\"1\":{\"51\":1}}],[\"无须重新扫描一遍\",{\"1\":{\"44\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"42\":1}}],[\"无法在任何地方通过反射访问该类的方法\",{\"1\":{\"31\":1}}],[\"无用的类\",{\"1\":{\"31\":1}}],[\"该类对应的\",{\"1\":{\"31\":1}}],[\"该类所有的对象实例都已经被回收\",{\"1\":{\"31\":1}}],[\"已经被回收\",{\"1\":{\"31\":1}}],[\"加载该类的\",{\"1\":{\"31\":1}}],[\"加入一些处理\",{\"1\":{\"47\":1}}],[\"加入\",{\"1\":{\"9\":1}}],[\"类需要同时满足下面3个条件才能算是\",{\"1\":{\"31\":1}}],[\"类加载检查\",{\"0\":{\"17\":1}}],[\"update\",{\"1\":{\"46\":1}}],[\"uuid\",{\"1\":{\"30\":2}}],[\"usenix\",{\"1\":{\"65\":1}}],[\"userid=\",{\"1\":{\"30\":1}}],[\"user类需要重写finalize方法\",{\"1\":{\"30\":1}}],[\"user\",{\"1\":{\"29\":7,\"30\":2}}],[\"usecompressedoops\",{\"1\":{\"21\":1}}],[\"譬如设置为二十毫秒\",{\"1\":{\"56\":1}}],[\"譬如把自己赋值给某个类变量或对象的成员变量\",{\"1\":{\"30\":1}}],[\"譬如作为其他线程可访问对象的属性被引用\",{\"1\":{\"10\":1}}],[\"第二次标记\",{\"1\":{\"30\":1}}],[\"第一行代码我们尝试读取堆中的一个对象引用obj\",{\"1\":{\"72\":1}}],[\"第一次标记并进行一次筛选\",{\"1\":{\"30\":1}}],[\"第一部分用于存储对象自身的运行时数据\",{\"1\":{\"20\":1}}],[\"标记整理\",{\"1\":{\"56\":1}}],[\"标记能达到所有对象\",{\"1\":{\"56\":1}}],[\"标记阶段就会减少一些标记时间\",{\"1\":{\"43\":1}}],[\"标记过程仍然与\",{\"1\":{\"38\":1}}],[\"标记清除后会产生大量不连续的碎片\",{\"1\":{\"37\":1}}],[\"标记出所有需要回收的对象\",{\"1\":{\"37\":1}}],[\"标记存活的对象\",{\"1\":{\"37\":1}}],[\"标记\",{\"0\":{\"36\":1,\"37\":1,\"38\":1},\"1\":{\"35\":4,\"37\":1,\"38\":1,\"40\":1,\"42\":1,\"56\":1}}],[\"标记的前提是对象在进行可达性分析后发现没有与gc\",{\"1\":{\"30\":1}}],[\"标量替换也是不可或缺的\",{\"1\":{\"12\":1}}],[\"标量替换对逃逸程度的要求更高\",{\"1\":{\"11\":1}}],[\"标量替换\",{\"0\":{\"11\":1}}],[\"至少要经历再次标记过程\",{\"1\":{\"30\":1}}],[\"阶段会短暂的暂停\",{\"1\":{\"69\":1}}],[\"阶段\",{\"1\":{\"30\":1,\"37\":1}}],[\"非死不可\",{\"1\":{\"30\":1}}],[\"www\",{\"1\":{\"65\":1}}],[\"write\",{\"1\":{\"47\":2,\"48\":1,\"72\":1}}],[\"world停顿时间\",{\"1\":{\"56\":1}}],[\"world\",{\"1\":{\"39\":2,\"42\":1}}],[\"while\",{\"1\":{\"30\":1}}],[\"weakreference<user>\",{\"1\":{\"29\":2}}],[\"wiki\",{\"1\":{\"8\":1,\"65\":1}}],[\"很显然\",{\"1\":{\"64\":1}}],[\"很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间\",{\"1\":{\"56\":1}}],[\"很可能出现的结果就是由于停顿目标时间太短\",{\"1\":{\"56\":1}}],[\"很少用\",{\"1\":{\"29\":1}}],[\"很耗费开销\",{\"1\":{\"0\":1}}],[\"甚至会造成内存溢出\",{\"1\":{\"29\":1}}],[\"​标记\",{\"1\":{\"42\":1}}],[\"​\",{\"1\":{\"29\":4,\"41\":1,\"42\":1,\"51\":1}}],[\"​public\",{\"1\":{\"29\":3}}],[\"​​\",{\"1\":{\"0\":2,\"5\":1,\"6\":2,\"9\":2,\"16\":1,\"18\":2,\"20\":2,\"21\":1,\"26\":1,\"28\":1,\"34\":1,\"36\":1,\"37\":1,\"38\":2,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"44\":1,\"56\":3,\"66\":1,\"68\":1,\"69\":1,\"70\":1,\"72\":2,\"73\":1,\"75\":1}}],[\"普通的变量引用\",{\"1\":{\"29\":1}}],[\"弱引用跟没引用差不多\",{\"1\":{\"29\":1}}],[\"弱引用\",{\"1\":{\"29\":2}}],[\"软引用在实际中有重要的应用\",{\"1\":{\"29\":1}}],[\"软引用可用来实现内存敏感的高速缓存\",{\"1\":{\"29\":1}}],[\"软引用\",{\"1\":{\"29\":2}}],[\"强引用\",{\"1\":{\"29\":2}}],[\"静态变量\",{\"1\":{\"28\":1}}],[\"找到的对象都标记为非垃圾对象\",{\"1\":{\"28\":1}}],[\"rate\",{\"1\":{\"73\":1}}],[\"randomuuid\",{\"1\":{\"30\":2}}],[\"root\",{\"1\":{\"65\":1}}],[\"roots能达到的第一个对象\",{\"1\":{\"56\":1}}],[\"roots开始标记gc\",{\"1\":{\"56\":1}}],[\"roots可达性分析遍历对象过程中遇到的对象\",{\"1\":{\"44\":1}}],[\"roots的直接关联对象开始遍历整个对象图的过程\",{\"1\":{\"42\":1}}],[\"roots相连接的引用链\",{\"1\":{\"30\":1}}],[\"roots根节点\",{\"1\":{\"28\":1}}],[\"roots\",{\"1\":{\"28\":1,\"42\":1}}],[\"rednaxelafx\",{\"1\":{\"73\":1}}],[\"relocation\",{\"1\":{\"69\":1,\"70\":1}}],[\"relocate\",{\"1\":{\"69\":2}}],[\"region是指在一段代码片段中\",{\"1\":{\"78\":1}}],[\"region中的存活对象低于这个值时才会回收该region\",{\"1\":{\"61\":1}}],[\"region的集合\",{\"1\":{\"56\":1}}],[\"region\",{\"0\":{\"78\":1},\"1\":{\"56\":2,\"68\":3,\"78\":1}}],[\"remapped标识\",{\"1\":{\"70\":1}}],[\"remap\",{\"1\":{\"69\":1}}],[\"remark\",{\"1\":{\"48\":1,\"50\":1,\"56\":1}}],[\"remember\",{\"1\":{\"51\":1}}],[\"reference类型等\",{\"1\":{\"11\":1}}],[\"return\",{\"1\":{\"9\":4,\"13\":2,\"50\":1}}],[\"回收的的意义不大\",{\"1\":{\"61\":1}}],[\"回收所有的young和部分old\",{\"1\":{\"59\":1}}],[\"回收阶段占到几十到一百甚至接近两百毫秒都很正常\",{\"1\":{\"56\":1}}],[\"回收算法主要用的是复制算法\",{\"1\":{\"56\":1}}],[\"回收策略等等\",{\"1\":{\"40\":1}}],[\"回收器回收他们\",{\"1\":{\"27\":1}}],[\"回边计数器阈值=方法调用计数器阈值×\",{\"1\":{\"7\":1}}],[\"回边计数器在默认情况下的阈值是1070\",{\"1\":{\"7\":1}}],[\"回边计数器\",{\"1\":{\"7\":1}}],[\"相同性质的堆可以不连续\",{\"1\":{\"56\":1}}],[\"相互引用着对方之外\",{\"1\":{\"27\":1}}],[\"相比较32位存储\",{\"1\":{\"21\":1}}],[\"相比于c1编译器\",{\"1\":{\"8\":1}}],[\"其对应的卡表的元素标识就变成1\",{\"1\":{\"51\":1}}],[\"其并发标记时对漏标的处理方案如下\",{\"1\":{\"50\":1}}],[\"其实就是指在赋值操作前后\",{\"1\":{\"47\":1}}],[\"其底层代码大概长这样\",{\"1\":{\"47\":1}}],[\"其余行为\",{\"1\":{\"40\":1}}],[\"其余未标记的对象都是垃圾对象\",{\"1\":{\"28\":1}}],[\"其最主要的原因是它很难解决对象之间相互循环引用的问题\",{\"1\":{\"27\":1}}],[\"其中第一个是做根集合\",{\"1\":{\"65\":1}}],[\"其中一块区域\",{\"1\":{\"25\":1}}],[\"其中比率的值默认为140\",{\"1\":{\"7\":1}}],[\"其中前端编译是在\",{\"1\":{\"5\":1}}],[\"任何场景下都适用的完美收集器存在\",{\"1\":{\"38\":1}}],[\"任何计数为0的对象就是可回收对象\",{\"1\":{\"27\":1}}],[\"任何编程语言\",{\"1\":{\"5\":1}}],[\"引用计数\",{\"0\":{\"27\":1}}],[\"8默认使用\",{\"1\":{\"75\":1}}],[\"8默认就设置了\",{\"1\":{\"26\":1}}],[\"8g以上可以用g1\",{\"1\":{\"75\":1}}],[\"8g可以用parnew+cms\",{\"1\":{\"75\":1}}],[\"8gb以上的堆内存\",{\"1\":{\"63\":1}}],[\"80\",{\"1\":{\"43\":1}}],[\"8的eden内存\",{\"1\":{\"0\":1}}],[\"检查\",{\"1\":{\"26\":1}}],[\"检查这个虚拟机栈对应的线程中是否引用了这个对象\",{\"1\":{\"12\":1}}],[\"包括全局变量啊线程栈啊啥的里面的对象指针\",{\"1\":{\"65\":1}}],[\"包括移动对象的阶段\",{\"1\":{\"65\":1}}],[\"包括垃圾对象\",{\"1\":{\"26\":1}}],[\"包括启动速度较慢\",{\"1\":{\"8\":1}}],[\"年轻代和老年代都是\",{\"1\":{\"75\":1}}],[\"年轻代可能都占用了堆内存的60\",{\"1\":{\"62\":1}}],[\"年轻代中的eden和survivor对应的region也跟之前一样\",{\"1\":{\"56\":1}}],[\"年轻代每次minor\",{\"1\":{\"26\":1}}],[\"年龄1+年龄2+年龄n的多个年龄对象\",{\"1\":{\"61\":1}}],[\"年龄1+年龄2+年龄n的多个年龄对象总和超过了survivor区域的50\",{\"1\":{\"25\":1}}],[\"年龄就增加1岁\",{\"1\":{\"24\":1}}],[\"尽量把gc导致的停顿时间控制在我们指定的范围内\",{\"1\":{\"56\":1}}],[\"尽量多写小方法\",{\"1\":{\"9\":1}}],[\"尽管实现的方式不尽相同\",{\"1\":{\"50\":1}}],[\"尽早进入老年代\",{\"1\":{\"25\":1}}],[\"含\",{\"1\":{\"25\":1,\"61\":1}}],[\"例如浏览器的后退按钮\",{\"1\":{\"29\":1}}],[\"例如survivor区域里现在有一批对象\",{\"1\":{\"25\":1}}],[\"例如作为调用参数传递到其他地方中\",{\"1\":{\"22\":1}}],[\"一次gc的最大持续时间\",{\"1\":{\"74\":1}}],[\"一次gc检测周期时间\",{\"1\":{\"74\":1}}],[\"一次gc最大持续时间\",{\"1\":{\"74\":1}}],[\"一次只回收掉一部分的region\",{\"1\":{\"61\":1}}],[\"一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起\",{\"1\":{\"77\":1}}],[\"一旦某个region的存活对象被移走之后\",{\"1\":{\"71\":1}}],[\"一旦所有指针都被修正之后\",{\"1\":{\"69\":1}}],[\"一旦重分配集中某个region的存活对象都复制完毕后\",{\"1\":{\"69\":1}}],[\"一旦空闲出来的region数量达到了堆内存的5\",{\"1\":{\"61\":1}}],[\"一个region可能之前是年轻代\",{\"1\":{\"56\":1}}],[\"一个卡页中可包含多个对象\",{\"1\":{\"51\":1}}],[\"一个对象的finalize\",{\"1\":{\"30\":1}}],[\"一律记录下来\",{\"1\":{\"50\":1}}],[\"一边回收\",{\"1\":{\"42\":1}}],[\"一种用途是在\",{\"1\":{\"39\":1}}],[\"一批对象的总大小大于这块survivor区域内存大小的50\",{\"1\":{\"25\":1}}],[\"一般来说部署kafka需要用大内存机器\",{\"1\":{\"64\":1}}],[\"一般来说\",{\"1\":{\"56\":1}}],[\"一般region大小等于堆大小除以2048\",{\"1\":{\"56\":1}}],[\"一般cms的gc耗时\",{\"1\":{\"43\":1}}],[\"一般选择这种\",{\"1\":{\"37\":1}}],[\"一般将\",{\"1\":{\"35\":1}}],[\"一般可以设置成256m\",{\"1\":{\"0\":1}}],[\"一般建议将jvm参数\",{\"1\":{\"0\":1}}],[\"放对象的那块s区\",{\"1\":{\"25\":1}}],[\"放到缓存当中\",{\"1\":{\"6\":1}}],[\"来源\",{\"1\":{\"73\":1}}],[\"来缩短stop\",{\"1\":{\"56\":1}}],[\"来制定回收计划\",{\"1\":{\"56\":1}}],[\"来给大家解释下\",{\"1\":{\"44\":1}}],[\"来设置\",{\"1\":{\"24\":1}}],[\"来对java对象寻址\",{\"1\":{\"21\":1}}],[\"空间整合\",{\"1\":{\"56\":1}}],[\"空间问题\",{\"1\":{\"37\":1}}],[\"空间中\",{\"1\":{\"24\":1}}],[\"空闲列表\",{\"1\":{\"18\":1}}],[\"出生并经过第一次\",{\"1\":{\"24\":1}}],[\"哪些对象应放在老年代中\",{\"1\":{\"24\":1}}],[\"长期存活的对象进入老年代\",{\"0\":{\"24\":1}}],[\"此时会更新指针中marked0和marked1标志位\",{\"1\":{\"69\":1}}],[\"此时会进入stop\",{\"1\":{\"42\":1}}],[\"此时才触发年轻代gc\",{\"1\":{\"62\":1}}],[\"此时就会导致survivor区域放不下那么多的对象\",{\"1\":{\"62\":1}}],[\"此时就会立即停止混合回收\",{\"1\":{\"61\":1}}],[\"此时就会把年龄n\",{\"1\":{\"25\":1,\"61\":1}}],[\"此时大对象在s0和s1区域也无法存储\",{\"1\":{\"23\":1}}],[\"此参数在serial和parnew垃圾回收器下起作用\",{\"1\":{\"23\":1}}],[\"单线程\",{\"1\":{\"39\":1}}],[\"单位是字节\",{\"1\":{\"23\":1}}],[\"单独来看testinline\",{\"1\":{\"9\":1}}],[\"打印gc参数\",{\"1\":{\"22\":1}}],[\"打印内联决策\",{\"1\":{\"9\":1}}],[\"逃逸的对象无法进行栈上分配\",{\"1\":{\"22\":1}}],[\"逃逸分析是基础\",{\"1\":{\"12\":1}}],[\"逃逸分析\",{\"0\":{\"10\":1},\"1\":{\"22\":1}}],[\"它和g1一样\",{\"1\":{\"73\":1}}],[\"它表示这个对象只能通过finalizer才能引用\",{\"1\":{\"70\":1}}],[\"它默认的停顿目标为两百毫秒\",{\"1\":{\"56\":1}}],[\"它具备以下特点\",{\"1\":{\"56\":1}}],[\"它就变回灰色对象了\",{\"1\":{\"46\":1}}],[\"它使用的回收算法\",{\"1\":{\"42\":1}}],[\"它第一次实现了让垃圾收集线程与用户线程\",{\"1\":{\"42\":1}}],[\"它非常符合在注重用户体验的应用上使用\",{\"1\":{\"42\":1}}],[\"它是一个mark\",{\"1\":{\"65\":1}}],[\"它是安全存活的\",{\"1\":{\"44\":1}}],[\"它是\",{\"1\":{\"42\":1}}],[\"它是许多运行在\",{\"1\":{\"41\":1}}],[\"它是最基础的收集算法\",{\"1\":{\"37\":1}}],[\"它是最弱的一种引用关系\",{\"1\":{\"29\":1}}],[\"它主要有两大用途\",{\"1\":{\"39\":1}}],[\"它同样是一个单线程收集器\",{\"1\":{\"39\":1}}],[\"它简单而高效\",{\"1\":{\"39\":1}}],[\"它的状态是可以确定的\",{\"1\":{\"77\":1}}],[\"它的初始标记\",{\"1\":{\"69\":1}}],[\"它的停顿时间不会随着堆的增大而增长\",{\"1\":{\"66\":1}}],[\"它的目标之一是将stw控制在10ms左右的同时\",{\"1\":{\"65\":1}}],[\"它的运作过程相比于前面几种垃圾收集器来说更加复杂一些\",{\"1\":{\"42\":1}}],[\"它的\",{\"1\":{\"39\":1}}],[\"它可以作为一种可扩展的存储结构用来记录更多与对象标记\",{\"1\":{\"71\":1}}],[\"它可以将内存分为大小相同的两块\",{\"1\":{\"36\":1}}],[\"它可能被外部方法所引用\",{\"1\":{\"22\":1}}],[\"它不允许对象逃逸出方法范围内\",{\"1\":{\"11\":1}}],[\"填充对齐\",{\"1\":{\"21\":1}}],[\"使上次gc周期中修正的标志位失效\",{\"1\":{\"70\":1}}],[\"使其直接指向新对象\",{\"1\":{\"69\":1}}],[\"使得jvm只用32位地址就可以支持更大的内存配置\",{\"1\":{\"21\":1}}],[\"使用并发收集器\",{\"1\":{\"75\":1}}],[\"使用串行收集器\",{\"1\":{\"75\":1}}],[\"使用marked1\",{\"1\":{\"70\":1}}],[\"使用marked0\",{\"1\":{\"70\":1}}],[\"使用g1收集器\",{\"1\":{\"61\":1}}],[\"使用多个cpu\",{\"1\":{\"56\":1}}],[\"使用多线程和\",{\"1\":{\"40\":1}}],[\"使用原始快照方式进行处理\",{\"1\":{\"56\":1}}],[\"使用低位的32位地址\",{\"1\":{\"21\":1}}],[\"使用较大指针在主内存和缓存之间移动\",{\"1\":{\"21\":1}}],[\"使用\",{\"1\":{\"18\":1}}],[\"使用c2编译器来执行\",{\"1\":{\"8\":1}}],[\"使用c1来将字节码编译为本地机器码\",{\"1\":{\"8\":1}}],[\"使用jit实时编译的前提是需要识别出热点代码\",{\"1\":{\"7\":1}}],[\"使用java\",{\"1\":{\"6\":1}}],[\"取出到cpu寄存器后解码方式进行优化\",{\"1\":{\"21\":1}}],[\"执行过程中的不确定性\",{\"1\":{\"42\":1}}],[\"执行init方法\",{\"1\":{\"21\":1}}],[\"执行时间就有比较大的差距\",{\"1\":{\"13\":1}}],[\"偏向时间戳等\",{\"1\":{\"20\":1}}],[\"偏向线程id\",{\"1\":{\"20\":1}}],[\"线程栈的大小之类的而变化\",{\"1\":{\"65\":1}}],[\"线程栈的本地变量\",{\"1\":{\"28\":1}}],[\"线程持有的锁\",{\"1\":{\"20\":1}}],[\"线程进行回收\",{\"1\":{\"12\":1}}],[\"锁状态标志\",{\"1\":{\"20\":1}}],[\"锁消除\",{\"0\":{\"13\":1}}],[\"display\",{\"1\":{\"65\":1}}],[\"d\",{\"1\":{\"44\":12,\"47\":1,\"48\":1,\"49\":2,\"50\":3}}],[\"data\",{\"1\":{\"20\":1}}],[\"dosomething\",{\"1\":{\"72\":1}}],[\"do\",{\"1\":{\"9\":1}}],[\"healing\",{\"1\":{\"69\":2}}],[\"header\",{\"1\":{\"20\":1}}],[\"http\",{\"1\":{\"65\":1}}],[\"https\",{\"1\":{\"65\":2}}],[\"humongous区专门存放短期巨型对象\",{\"1\":{\"56\":1}}],[\"hotspot使用写屏障维护卡表状态\",{\"1\":{\"52\":1}}],[\"hotspot使用的卡页是2^9大小\",{\"1\":{\"51\":1}}],[\"hotspot使用一种叫做\",{\"1\":{\"51\":1}}],[\"hotspot\",{\"1\":{\"42\":1,\"50\":1}}],[\"hotspot虚拟机的对象头包括两部分信息\",{\"1\":{\"20\":1}}],[\"hotspot虚拟机在编译子系统中加入了分层编译的功能\",{\"1\":{\"8\":1}}],[\"hotspot虚拟机内置两个即时编译器\",{\"1\":{\"8\":1}}],[\"hotspot虚拟机并没有直接选择执行效率最高的编译执行模式\",{\"1\":{\"6\":1}}],[\"handlepromotionfailure\",{\"1\":{\"26\":1}}],[\"hashcode\",{\"1\":{\"20\":1}}],[\"主动触发\",{\"1\":{\"74\":1}}],[\"主动关闭锁清除后\",{\"1\":{\"13\":1}}],[\"主动关闭标量替换\",{\"1\":{\"11\":1}}],[\"主要时统计gc时间\",{\"1\":{\"74\":1}}],[\"主要使用标记\",{\"1\":{\"68\":1}}],[\"主要使用读屏障\",{\"1\":{\"68\":1}}],[\"主要使用复制算法\",{\"1\":{\"59\":1}}],[\"主要指mixed\",{\"1\":{\"56\":1}}],[\"主要针对配备多颗处理器及大容量内存的机器\",{\"1\":{\"56\":1}}],[\"主要优点\",{\"1\":{\"42\":1}}],[\"主要用到三色标记里的增量更新算法\",{\"1\":{\"42\":1}}],[\"主要保存对象类的路径\",{\"1\":{\"20\":1}}],[\"程序可以访问到这些对象默认的零值\",{\"1\":{\"19\":1}}],[\"向该线程的单独区域内进行内存分配\",{\"1\":{\"18\":1}}],[\"根据对象指针中这4位的信息\",{\"1\":{\"72\":1}}],[\"根据r大的说法\",{\"1\":{\"65\":1}}],[\"根据期望的gc停顿时间确定old区垃圾收集的优先顺序\",{\"1\":{\"59\":1}}],[\"根据用户所期望的gc停顿stw时间\",{\"1\":{\"56\":1}}],[\"根据老年代的特点\",{\"1\":{\"38\":1}}],[\"根据线程不同\",{\"1\":{\"18\":1}}],[\"根据程序访问情况\",{\"1\":{\"11\":1}}],[\"指向某个白色对象\",{\"1\":{\"44\":1}}],[\"指定分区大小\",{\"1\":{\"61\":1}}],[\"指定gc工作的线程数量\",{\"1\":{\"61\":1}}],[\"指定\",{\"1\":{\"56\":1}}],[\"指定收集线程数\",{\"1\":{\"40\":1}}],[\"指定元空间触发fullgc的初始阈值\",{\"1\":{\"0\":1}}],[\"指针压缩会失效\",{\"1\":{\"21\":1}}],[\"指针碰撞\",{\"1\":{\"18\":1}}],[\"为其他gc机制使用\",{\"1\":{\"74\":1}}],[\"为何\",{\"1\":{\"67\":1}}],[\"为50ms\",{\"1\":{\"64\":1}}],[\"为此\",{\"1\":{\"51\":1}}],[\"为什么g1用satb\",{\"1\":{\"50\":1}}],[\"为了实现上方便\",{\"1\":{\"65\":1}}],[\"为了简化例子\",{\"1\":{\"44\":1}}],[\"为了解决效率问题\",{\"1\":{\"36\":1}}],[\"为了做到这一点\",{\"1\":{\"24\":1}}],[\"为了减少临时对象在堆内分配的数量\",{\"1\":{\"22\":1}}],[\"为了减少在64位平台下的内存消耗\",{\"1\":{\"21\":1}}],[\"为了在程序启动响应速度与运行效率之间达到最佳平衡\",{\"1\":{\"8\":1}}],[\"为对象分配空间\",{\"1\":{\"18\":1}}],[\"则可能就要触发mixedgc了\",{\"1\":{\"61\":1}}],[\"则可以使用指针碰撞方法\",{\"1\":{\"18\":1}}],[\"则执行新生代和老年代的混合收集\",{\"1\":{\"61\":1}}],[\"则执行类加载过程\",{\"1\":{\"17\":1}}],[\"则region大小为2m\",{\"1\":{\"56\":1}}],[\"则按后退查看前面浏览过的页面时\",{\"1\":{\"29\":1}}],[\"则计数减1\",{\"1\":{\"27\":1}}],[\"则计数加1\",{\"1\":{\"27\":1}}],[\"则报oom\",{\"1\":{\"26\":2}}],[\"则会把这些软引用的对象回收掉\",{\"1\":{\"29\":1}}],[\"则会触发full\",{\"1\":{\"26\":1}}],[\"则会对老年代剩余可用空间大小和之前每一次minor\",{\"1\":{\"26\":1}}],[\"则无法进行内联\",{\"1\":{\"9\":2}}],[\"解析和初始化过程\",{\"1\":{\"17\":1}}],[\"解释器可能还要替编译器收集性能监控信息\",{\"1\":{\"8\":1}}],[\"解释器监控比率为33\",{\"1\":{\"7\":1}}],[\"解释器监控比率\",{\"1\":{\"7\":1}}],[\"解释执行与编译执行\",{\"0\":{\"6\":1}}],[\"先去检查这个指令的参数是否能够在类的常量池中定位到一个类的符号引用\",{\"1\":{\"17\":1}}],[\"两者最大的区别就是stringbuildr是线程不安全的\",{\"1\":{\"13\":1}}],[\"以便日后进一步提高性能\",{\"1\":{\"71\":1}}],[\"以前的垃圾回收器的gc信息都保存在对象头中\",{\"1\":{\"70\":1}}],[\"以及此速率下内存将要耗尽的时间点\",{\"1\":{\"74\":1}}],[\"以及大对象区\",{\"1\":{\"59\":1}}],[\"以及以前的版本中与\",{\"1\":{\"39\":1}}],[\"以极高概率满足gc停顿时间要求的同时\",{\"1\":{\"56\":1}}],[\"以java\",{\"1\":{\"50\":1}}],[\"以上的堆被存活对象占用\",{\"1\":{\"63\":1}}],[\"以上的对象都放入老年代\",{\"1\":{\"25\":1,\"61\":1}}],[\"以上无论是对引用关系记录的插入还是删除\",{\"1\":{\"46\":1}}],[\"以上代码分别测试了stringbuffer和stringbuilder的字符串构建方法\",{\"1\":{\"13\":1}}],[\"以字节为单位\",{\"1\":{\"0\":1}}],[\"barriers的存在\",{\"1\":{\"72\":1}}],[\"barriers\",{\"1\":{\"72\":1}}],[\"barrier\",{\"1\":{\"47\":2,\"48\":1,\"50\":2,\"72\":2}}],[\"beginning\",{\"1\":{\"46\":1}}],[\"b\",{\"1\":{\"27\":8,\"44\":6,\"47\":1,\"48\":1,\"50\":1}}],[\"bbbbbb\",{\"1\":{\"13\":2}}],[\"buffer\",{\"1\":{\"18\":1}}],[\"bufferstring\",{\"1\":{\"13\":2}}],[\"builderstring\",{\"1\":{\"13\":2}}],[\"场景举例\",{\"1\":{\"13\":1}}],[\"要回收的集合\",{\"1\":{\"56\":1}}],[\"要真正宣告一个对象死亡\",{\"1\":{\"30\":1}}],[\"要开启栈上分配\",{\"1\":{\"12\":1}}],[\"要知道某段代码是否是热点代码\",{\"1\":{\"7\":1}}],[\"拆分成最精简的标量\",{\"1\":{\"12\":1}}],[\"才能放到栈中\",{\"1\":{\"12\":1}}],[\"才会进入\",{\"1\":{\"9\":1}}],[\"也没有从堆中读取数据\",{\"1\":{\"72\":1}}],[\"也是目前最常用的一种方式\",{\"1\":{\"51\":1}}],[\"也会快速导致一些对象进入老年代中\",{\"1\":{\"62\":1}}],[\"也会将humongous区一并回收\",{\"1\":{\"56\":1}}],[\"也会对年轻代一起做标记\",{\"1\":{\"43\":1}}],[\"也会触发full\",{\"1\":{\"26\":1}}],[\"也许没回收完就再次触发full\",{\"1\":{\"42\":1}}],[\"也可以反过来\",{\"1\":{\"37\":1}}],[\"也并非是\",{\"1\":{\"30\":1}}],[\"也间接影响了应用的性能\",{\"1\":{\"22\":1}}],[\"也必须要对对象进行最大程度的瘦身\",{\"1\":{\"12\":1}}],[\"也就加大了编译执行的难度\",{\"1\":{\"9\":1}}],[\"也就是\",{\"1\":{\"31\":1,\"42\":1}}],[\"也就是需要使用invokevirtual指令调用\",{\"1\":{\"9\":1}}],[\"也就是说可以给年轻代分配个三四十g的内存用来支撑高并发处理\",{\"1\":{\"64\":1}}],[\"也就是说region的区域功能可能会动态变化\",{\"1\":{\"56\":1}}],[\"也就是说通过调用finalize方法自我救命的机会就一次\",{\"1\":{\"30\":1}}],[\"也就是说\",{\"1\":{\"6\":1,\"66\":1}}],[\"可使得g1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡\",{\"1\":{\"56\":1}}],[\"可预测的停顿\",{\"1\":{\"56\":1}}],[\"可能的最大分配速率\",{\"1\":{\"74\":1}}],[\"可能回收其中800个region刚好需要200ms\",{\"1\":{\"56\":1}}],[\"可能会横跨多个region来存放\",{\"1\":{\"56\":1}}],[\"可能会有导致已经标记过的对象状态发生改变\",{\"1\":{\"42\":1}}],[\"可能隶属于多个线程\",{\"1\":{\"12\":1}}],[\"可达性分析\",{\"0\":{\"28\":1},\"1\":{\"50\":1}}],[\"可通过zproactive参数配置\",{\"1\":{\"74\":1}}],[\"可通过zcollectioninterval参数配置\",{\"1\":{\"74\":1}}],[\"可通过\",{\"1\":{\"23\":1}}],[\"可以调优的参数都比较少\",{\"1\":{\"73\":1}}],[\"可以动态变化\",{\"1\":{\"68\":1}}],[\"可以有效解决大内存带来的垃圾回收时间过长问题\",{\"1\":{\"64\":1}}],[\"可以由用户指定期望的停顿时间是g1收集器很强大的一个功能\",{\"1\":{\"56\":1}}],[\"可以用jvm参数\",{\"1\":{\"56\":1}}],[\"可以节约老年代的空间\",{\"1\":{\"56\":1}}],[\"可以类比为java语言中hashmap与map的关系\",{\"1\":{\"51\":1}}],[\"可以参考aop的概念\",{\"1\":{\"47\":1}}],[\"可以与垃圾收集线程一起并发运行\",{\"1\":{\"42\":1}}],[\"可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择\",{\"1\":{\"40\":1}}],[\"可以给对象添加一个引用计数\",{\"1\":{\"27\":1}}],[\"可以进行干预内联行为\",{\"1\":{\"9\":1}}],[\"可以通过参数\",{\"1\":{\"24\":1}}],[\"可以通过对对象指针存入堆内存时压缩编码\",{\"1\":{\"21\":1}}],[\"可以通过添加参数\",{\"1\":{\"11\":1}}],[\"可以通过调整jvm参数\",{\"1\":{\"9\":1}}],[\"可以通过\",{\"1\":{\"7\":1,\"56\":2}}],[\"完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的\",{\"1\":{\"12\":1}}],[\"那基本上它就真的被回收了\",{\"1\":{\"30\":1}}],[\"那在第二次标记时它将移除出\",{\"1\":{\"30\":1}}],[\"那就必须扫描所有的虚拟机栈\",{\"1\":{\"12\":1}}],[\"那大量的对象就会随着方法的结束而自动销毁了\",{\"1\":{\"12\":1}}],[\"那让这个对象在栈上分配内存将会是一个很不错的主意\",{\"1\":{\"12\":1}}],[\"那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢\",{\"1\":{\"72\":1}}],[\"那么正常往下执行即可\",{\"1\":{\"72\":1}}],[\"那么程序还不能往下执行\",{\"1\":{\"72\":1}}],[\"那么程序真正执行的时候将可能不去创建这个对象\",{\"1\":{\"11\":1}}],[\"那么\",{\"1\":{\"72\":2}}],[\"那么设置\",{\"1\":{\"64\":1}}],[\"那么意味着整个系统每运行一两分钟就会因为young\",{\"1\":{\"64\":1}}],[\"那么存活下来的对象可能就会很多\",{\"1\":{\"62\":1}}],[\"那么增加年轻代的region\",{\"1\":{\"58\":1}}],[\"那么就会触发young\",{\"1\":{\"58\":1}}],[\"那么就只会回收800个region\",{\"1\":{\"56\":1}}],[\"那么就没有必要太过深⼊的去了解了\",{\"1\":{\"5\":1}}],[\"那么通过之前回收成本计算得知\",{\"1\":{\"56\":1}}],[\"那么年轻代就是200m左右内存\",{\"1\":{\"56\":1}}],[\"那么本轮gc不会回收这部分内存\",{\"1\":{\"45\":1}}],[\"那么我们的\",{\"1\":{\"38\":1}}],[\"那么垃圾收集器就是内存回收的具体实现\",{\"1\":{\"38\":1}}],[\"那么如何判断一个类是无用的类呢\",{\"1\":{\"31\":1}}],[\"那么此时大于等于这批对象年龄最大值的对象\",{\"1\":{\"25\":1}}],[\"那么内存回收时就必须能识别哪些对象应放在新生代\",{\"1\":{\"24\":1}}],[\"那么他内部的锁就不会存在竞争\",{\"1\":{\"13\":1}}],[\"那么堆中的同一个对象\",{\"1\":{\"12\":1}}],[\"那么这些变量就可以称为标量\",{\"1\":{\"11\":1}}],[\"那么具体调用的方法\",{\"1\":{\"9\":1}}],[\"那么server模式下的虚拟机回边计数器的阈值就为10700\",{\"1\":{\"7\":1}}],[\"那么jvm如何执行class的字节码文件呢\",{\"1\":{\"6\":1}}],[\"那么在不超过\",{\"1\":{\"0\":1}}],[\"并通过标记整理算法清除垃圾对象\",{\"1\":{\"70\":1}}],[\"并同时修正更新该引用的值\",{\"1\":{\"69\":1}}],[\"并为重分配集中的每个region维护一个转发表\",{\"1\":{\"69\":1}}],[\"并行与并发\",{\"1\":{\"56\":1}}],[\"并发重映射\",{\"1\":{\"69\":1}}],[\"并发重分配\",{\"1\":{\"69\":1}}],[\"并发重置\",{\"1\":{\"42\":1}}],[\"并发预备重分配\",{\"1\":{\"69\":1}}],[\"并发的gc线程数\",{\"1\":{\"43\":1}}],[\"并发收集\",{\"1\":{\"42\":1}}],[\"并发清理\",{\"1\":{\"42\":1}}],[\"并发标记也是遍历对象图做可达性分析的阶段\",{\"1\":{\"69\":1}}],[\"并发标记阶段就是从gc\",{\"1\":{\"42\":1}}],[\"并发标记\",{\"1\":{\"42\":1,\"56\":1,\"69\":1}}],[\"并发分配时解决办法\",{\"1\":{\"18\":1}}],[\"并记录下\",{\"1\":{\"42\":1}}],[\"并将对象年龄设为1\",{\"1\":{\"24\":1}}],[\"并检查这个类的符号引用所指向的类是否已加载\",{\"1\":{\"17\":1}}],[\"并由\",{\"1\":{\"12\":1}}],[\"并且不能超过1秒\",{\"1\":{\"75\":1}}],[\"并且没有停顿时间的要求\",{\"1\":{\"75\":1}}],[\"并且把堆里的这个指针\",{\"1\":{\"72\":1}}],[\"并且能被\",{\"1\":{\"24\":1}}],[\"并且这个对象可以被拆散\",{\"1\":{\"11\":1}}],[\"并且逻辑非常简单的方法\",{\"1\":{\"9\":1}}],[\"并且解释器不开启性能监控\",{\"1\":{\"8\":1}}],[\"并且设置的比初始值要大\",{\"1\":{\"0\":1}}],[\"栈上分配可以支持方法逃逸\",{\"1\":{\"12\":1}}],[\"栈上分配\",{\"0\":{\"12\":1}}],[\"end\",{\"1\":{\"69\":1}}],[\"events\",{\"1\":{\"65\":1}}],[\"eden区对应800个\",{\"1\":{\"56\":1}}],[\"eden\",{\"1\":{\"24\":1}}],[\"eliminatelocks​\",{\"1\":{\"13\":1}}],[\"eliminateallocations​\",{\"1\":{\"11\":1}}],[\"elision\",{\"0\":{\"13\":1}}],[\"escape\",{\"0\":{\"10\":1}}],[\"中型region\",{\"1\":{\"68\":1}}],[\"中\",{\"1\":{\"68\":1,\"70\":1}}],[\"中用于运行用户代码的时间与\",{\"1\":{\"40\":1}}],[\"中成功拯救自己\",{\"1\":{\"30\":1}}],[\"中每熬过一次\",{\"1\":{\"24\":1}}],[\"中间是指针作为内存临界标识\",{\"1\":{\"18\":1}}],[\"中所有对象都应该创建在堆上\",{\"1\":{\"12\":1}}],[\"中默认开启了标量替换\",{\"1\":{\"11\":1}}],[\"中后会发现\",{\"1\":{\"9\":1}}],[\"除了追求低停顿外\",{\"1\":{\"56\":1}}],[\"除了\",{\"1\":{\"41\":1}}],[\"除了使用多线程进行垃圾收集外\",{\"1\":{\"40\":1}}],[\"除了对象obja\",{\"1\":{\"27\":1}}],[\"除了可以让对象的成员变量在栈上分配和读写之外\",{\"1\":{\"11\":1}}],[\"除了第2层的统计信息外\",{\"1\":{\"8\":1}}],[\"去实际访问拆散后的成员变量\",{\"1\":{\"11\":1}}],[\"如下面的代码\",{\"1\":{\"72\":1}}],[\"如下面代码所示\",{\"1\":{\"27\":1}}],[\"如下图所示\",{\"1\":{\"70\":1}}],[\"如\",{\"1\":{\"47\":2}}],[\"如实际是32位的地址\",{\"1\":{\"21\":1}}],[\"如哈希码\",{\"1\":{\"20\":1}}],[\"如何选择垃圾回收器\",{\"0\":{\"75\":1}}],[\"如何更新卡表对应的标识为1\",{\"1\":{\"52\":1}}],[\"如何才能找到类的元信息\",{\"1\":{\"20\":1}}],[\"如何划分\",{\"1\":{\"18\":1}}],[\"如int的0值等\",{\"1\":{\"19\":1}}],[\"如上方法中\",{\"1\":{\"10\":1}}],[\"如果响应时间最重要\",{\"1\":{\"75\":1}}],[\"如果允许停顿时间超过1秒\",{\"1\":{\"75\":1}}],[\"如果是单核\",{\"1\":{\"75\":1}}],[\"如果是小于或参数未设置\",{\"1\":{\"26\":1}}],[\"如果内存小于100m\",{\"1\":{\"75\":1}}],[\"如果指针是good\",{\"1\":{\"72\":1}}],[\"如果指针是bad\",{\"1\":{\"72\":1}}],[\"如果这时候对象在gc时被移动了\",{\"1\":{\"72\":1}}],[\"如果这个对象覆盖了finalize方法\",{\"1\":{\"30\":1}}],[\"如果用户线程此时并发访问了位于重分配集中的对象\",{\"1\":{\"69\":1}}],[\"如果超过这个值\",{\"1\":{\"61\":1}}],[\"如果回收时间远远小于参数\",{\"1\":{\"58\":1}}],[\"如果回收完还没有足够的空间\",{\"1\":{\"26\":2}}],[\"如果region进行了垃圾回收\",{\"1\":{\"56\":1}}],[\"如果堆大小为4096m\",{\"1\":{\"56\":1}}],[\"如果由于方法运行结束导致部分局部变量\",{\"1\":{\"45\":1}}],[\"如果有接近1000个region都是老年代的region\",{\"1\":{\"61\":1}}],[\"如果有其他对象引用指向了黑色对象\",{\"1\":{\"44\":1}}],[\"如果有一种四海之内\",{\"1\":{\"38\":1}}],[\"如果在minor\",{\"1\":{\"43\":1}}],[\"如果不指定\",{\"1\":{\"43\":1}}],[\"如果不会逃逸可以将该对象在栈上分配内存\",{\"1\":{\"22\":1}}],[\"如果对于收集器运作不太了解的话\",{\"1\":{\"40\":1}}],[\"如果对象这时候还没逃脱\",{\"1\":{\"30\":1}}],[\"如果对象要在finalize\",{\"1\":{\"30\":1}}],[\"如果对象在\",{\"1\":{\"24\":1}}],[\"如果对象数量较多的时候\",{\"1\":{\"22\":1}}],[\"如果说收集算法是内存回收的方法论\",{\"1\":{\"38\":1}}],[\"如果需要标记的对象太多\",{\"1\":{\"37\":1}}],[\"如果将浏览过的网页存储到内存中会造成内存的大量浪费\",{\"1\":{\"29\":1}}],[\"如果将循环次数减少\",{\"1\":{\"9\":1}}],[\"如果该对象被引用\",{\"1\":{\"27\":1}}],[\"如果该空间小于年轻代所有剩余对象之和\",{\"1\":{\"26\":1}}],[\"如果比对结果为大于\",{\"1\":{\"26\":1}}],[\"如果设置了\",{\"1\":{\"26\":1}}],[\"如果设置了的话\",{\"1\":{\"0\":1}}],[\"如果新生代的eden区域无法存放\",{\"1\":{\"23\":1}}],[\"如果使用tlab\",{\"1\":{\"19\":1}}],[\"如果java内存绝对规整\",{\"1\":{\"18\":1}}],[\"如果没有被引用\",{\"1\":{\"27\":1}}],[\"如果没有\",{\"1\":{\"17\":1}}],[\"如果发生了线程逃逸\",{\"1\":{\"12\":1}}],[\"如果能使用栈上分配\",{\"1\":{\"12\":1}}],[\"如果能保证一个方法不会逃逸出方法或线程\",{\"1\":{\"10\":1}}],[\"如果确定一个对象不会逃逸出线程之外\",{\"1\":{\"12\":1}}],[\"如果把一个java对象拆散\",{\"1\":{\"11\":1}}],[\"如果被其他线程访问\",{\"1\":{\"10\":1}}],[\"如果被方法外部所引用或者作为参数传递给其他方法\",{\"1\":{\"10\":1}}],[\"如果一个网页在浏览结束时就进行内容的回收\",{\"1\":{\"29\":1}}],[\"如果一个方法没有发生逃逸\",{\"1\":{\"13\":1}}],[\"如果一个方法编译后的字节码大于这个值\",{\"1\":{\"9\":1}}],[\"如果一个方法编译后的字节码大小大于这个值\",{\"1\":{\"9\":1}}],[\"如果一个对象的属性无法再分解为更小的数据来表示了\",{\"1\":{\"11\":1}}],[\"如果一个热点方法编译后的字节码大于这个值\",{\"1\":{\"9\":1}}],[\"如果都取默认值\",{\"1\":{\"7\":1}}],[\"如果你不是想要专⻔去研究语⾔\",{\"1\":{\"5\":1}}],[\"如果释放了很少的空间\",{\"1\":{\"0\":1}}],[\"如果释放了大量的空间\",{\"1\":{\"0\":1}}],[\"对比距上次gc的间隔时间跟\",{\"1\":{\"74\":1}}],[\"对region回收都是基于复制算法进行的\",{\"1\":{\"61\":1}}],[\"对应大概是100个region\",{\"1\":{\"56\":1}}],[\"对cpu资源敏感\",{\"1\":{\"42\":1}}],[\"对堆垃圾回收前的第一步就是要判断哪些对象已经死亡\",{\"1\":{\"26\":1}}],[\"对堆内存进行回收\",{\"1\":{\"26\":2}}],[\"对于这种情况\",{\"1\":{\"64\":1}}],[\"对于kafka来说\",{\"1\":{\"64\":1}}],[\"对于读写屏障\",{\"1\":{\"50\":1}}],[\"对于大部分处理器\",{\"1\":{\"21\":1}}],[\"对于8g内存的系统来说\",{\"1\":{\"0\":1}}],[\"对象的引用关系不会发生变化\",{\"1\":{\"78\":1}}],[\"对象的哈希码\",{\"1\":{\"20\":1}}],[\"对象地址\",{\"1\":{\"70\":1}}],[\"对象分配和晋升的速度变化非常大\",{\"1\":{\"63\":1}}],[\"对象间的引用可能发生变化\",{\"1\":{\"44\":1}}],[\"对象没有在任何地方被引用\",{\"1\":{\"31\":1}}],[\"对象将直接被回收\",{\"1\":{\"30\":1}}],[\"对象作为起点\",{\"1\":{\"28\":1}}],[\"对象动态年龄判断机制一般是在minor\",{\"1\":{\"25\":1}}],[\"对象动态年龄判断\",{\"0\":{\"25\":1}}],[\"对象晋升到老年代的年龄阈值\",{\"1\":{\"24\":1}}],[\"对象以8字节整数倍来对齐填充都是最高效的存取方式\",{\"1\":{\"21\":1}}],[\"对象指针在堆中是32位\",{\"1\":{\"21\":1}}],[\"对象头的另外一部分是类型指针\",{\"1\":{\"20\":1}}],[\"对象头\",{\"1\":{\"20\":1}}],[\"对象头除外\",{\"1\":{\"19\":1}}],[\"对象在\",{\"1\":{\"24\":1}}],[\"对象在内存中存储的布局可以分为3块区域\",{\"1\":{\"20\":1}}],[\"对象在方法中创建后\",{\"1\":{\"10\":1}}],[\"对象gc分代年龄信息等\",{\"1\":{\"20\":1}}],[\"对象所需的内存大小\",{\"1\":{\"18\":1}}],[\"对象所占用的内存空间就可以随栈帧出栈而销毁\",{\"1\":{\"12\":1}}],[\"对象加载完成过后\",{\"1\":{\"18\":1}}],[\"编译器很难在编译时得出绝对正确的结论\",{\"1\":{\"9\":1}}],[\"看情况使用final\",{\"1\":{\"9\":1}}],[\"让更多的方法可以进行内联\",{\"1\":{\"9\":1}}],[\"让编译出来的机器码运行效率更高\",{\"1\":{\"8\":1}}],[\"成为热点方法后\",{\"1\":{\"9\":1}}],[\"成为热点代码\",{\"1\":{\"9\":1}}],[\"避免存活对象太多快速进入老年代\",{\"1\":{\"62\":1}}],[\"避免因为老年代空间不够的gc开销\",{\"1\":{\"56\":1}}],[\"避免把整个老年代加入gcroots扫描范围\",{\"1\":{\"51\":1}}],[\"避免写大方法\",{\"1\":{\"9\":1}}],[\"避免发生真实的方法调用\",{\"1\":{\"9\":1}}],[\"从局部上来看是基于\",{\"1\":{\"56\":1}}],[\"从第一步标记的对象开始\",{\"1\":{\"56\":1}}],[\"从gc\",{\"1\":{\"56\":1}}],[\"从它的名字就可以看出它是一款优秀的垃圾收集器\",{\"1\":{\"42\":1}}],[\"从名字中的\",{\"1\":{\"42\":1}}],[\"从这些节点开始向下搜索引用的对象\",{\"1\":{\"28\":1}}],[\"从这几个相关参数可以看到\",{\"1\":{\"9\":1}}],[\"从而避免真实的调用\",{\"1\":{\"9\":1}}],[\"通过软件方式设计的\",{\"1\":{\"65\":1}}],[\"通过参数\",{\"1\":{\"56\":1}}],[\"通过这个指令可以看到哪些方法进行了内联\",{\"1\":{\"9\":1}}],[\"通常的做法是直接全部当成黑色\",{\"1\":{\"45\":1}}],[\"通常指那些只包含一两行语句\",{\"1\":{\"9\":1}}],[\"通常要编译出优化程度越高的代码\",{\"1\":{\"8\":1}}],[\"通常认为将java文件编译成class的字节码文件乘坐前端编译\",{\"1\":{\"4\":1}}],[\"通常是元空间发生了大小调整\",{\"1\":{\"0\":1}}],[\"good\",{\"1\":{\"72\":1}}],[\"garbage\",{\"1\":{\"56\":1}}],[\"g1可以调节停顿时间\",{\"1\":{\"66\":1}}],[\"g1垃圾回收器天生适合这种大jvm内存的场景\",{\"1\":{\"64\":1}}],[\"g1垃圾收集分类\",{\"0\":{\"57\":1}}],[\"g1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样\",{\"1\":{\"56\":1}}],[\"g1垃圾收集器\",{\"0\":{\"56\":1}}],[\"g1heapwastepercent\",{\"1\":{\"61\":1}}],[\"g1heapregionsize\",{\"1\":{\"61\":1}}],[\"g1heapregionsize​手动指定region大小\",{\"1\":{\"56\":1}}],[\"g1mixedgccounttarget\",{\"1\":{\"61\":1}}],[\"g1mixedgclivethresholdpercent\",{\"1\":{\"61\":1}}],[\"g1maxnewsizepercent\",{\"1\":{\"61\":1}}],[\"g1maxnewsizepercent​调整\",{\"1\":{\"56\":1}}],[\"g1newsizepercent\",{\"1\":{\"61\":1}}],[\"g1newsizepercent设置新生代初始占比\",{\"1\":{\"56\":1}}],[\"g1计算回收时间接近参数\",{\"1\":{\"58\":1}}],[\"g1会计算下现在eden区回收大概要多久时间\",{\"1\":{\"58\":1}}],[\"g1从整体来看是基于\",{\"1\":{\"56\":1}}],[\"g1能充分利用cpu\",{\"1\":{\"56\":1}}],[\"g1被视为jdk1\",{\"1\":{\"56\":1}}],[\"g1在处理多标和漏标的方式为\",{\"1\":{\"56\":1}}],[\"g1当然会优先选择后面这个region回收\",{\"1\":{\"56\":1}}],[\"g1收集器仍然可以通过并发的方式让java程序继续执行\",{\"1\":{\"56\":1}}],[\"g1收集器在后台维护了一个优先列表\",{\"1\":{\"56\":1}}],[\"g1收集器一次gc\",{\"1\":{\"56\":1}}],[\"g1因为内部实现太复杂暂时没实现并发回收\",{\"1\":{\"56\":1}}],[\"g1因为很多对象都位于不同的region\",{\"1\":{\"50\":1}}],[\"g1采用复制算法回收几乎不会有太多内存碎片\",{\"1\":{\"56\":1}}],[\"g1有专门分配大对象的region叫humongous区\",{\"1\":{\"56\":1}}],[\"g1保留了年轻代和老年代的概念\",{\"1\":{\"56\":1}}],[\"g1将java堆划分为多个大小相等的独立区域\",{\"1\":{\"56\":1}}],[\"g1\",{\"1\":{\"50\":1,\"56\":1,\"75\":1}}],[\"gc则可以有效降低这种情况下对堆大小\",{\"1\":{\"73\":1}}],[\"gc周期2\",{\"1\":{\"70\":1}}],[\"gc周期1\",{\"1\":{\"70\":1}}],[\"gc一样采用分代机制\",{\"1\":{\"67\":1}}],[\"gc一般都需要100ms以上\",{\"1\":{\"66\":1}}],[\"gc停顿时间在10ms左右\",{\"1\":{\"66\":1}}],[\"gc卡顿几秒钟没法处理新消息\",{\"1\":{\"64\":1}}],[\"gc是很快的\",{\"1\":{\"64\":1}}],[\"gc过程中空出来的region是否充足阈值\",{\"1\":{\"61\":1}}],[\"gc反而降低性能\",{\"1\":{\"56\":1}}],[\"gc的时候除了收集年轻代和老年代之外\",{\"1\":{\"56\":1}}],[\"gcroot\",{\"1\":{\"45\":1}}],[\"gc就干掉了很多对垃圾对象\",{\"1\":{\"43\":1}}],[\"gc标记阶段\",{\"1\":{\"43\":1}}],[\"gc前启动一次minor\",{\"1\":{\"43\":1}}],[\"gc会直接回收掉\",{\"1\":{\"29\":1}}],[\"gc之后需要存放到老年代的对象大小仍然超过了老年代剩余可用空间大小\",{\"1\":{\"26\":1}}],[\"gc之后触发的\",{\"1\":{\"25\":1}}],[\"gc后进入老年代对象的平均大小进行比较\",{\"1\":{\"26\":1}}],[\"gc时\",{\"1\":{\"26\":1,\"51\":1}}],[\"gc分代年龄\",{\"1\":{\"20\":1}}],[\"gc\",{\"1\":{\"12\":1,\"23\":1,\"24\":2,\"26\":2,\"27\":1,\"28\":2,\"42\":2,\"43\":1,\"51\":1,\"56\":1,\"58\":2,\"62\":1,\"65\":1}}],[\"gc进行类型卸载\",{\"1\":{\"0\":1}}],[\"gettrivialvalue\",{\"1\":{\"9\":1}}],[\"fullgc\",{\"0\":{\"60\":1}}],[\"fullgc之后做压缩整理\",{\"1\":{\"43\":1}}],[\"full\",{\"1\":{\"56\":1,\"65\":1}}],[\"finalizable标识\",{\"1\":{\"70\":1}}],[\"finalize\",{\"1\":{\"30\":1}}],[\"finalize方法是对象脱逃死亡命运的最后一次机会\",{\"1\":{\"30\":1}}],[\"first的由来\",{\"1\":{\"56\":1}}],[\"first\",{\"1\":{\"56\":1}}],[\"fieldb不是对象引用\",{\"1\":{\"72\":1}}],[\"fielda也是一个对象时才会加上读屏障\",{\"1\":{\"72\":1}}],[\"fielda并赋给引用o\",{\"1\":{\"72\":1}}],[\"field\",{\"1\":{\"47\":9,\"48\":2,\"50\":6}}],[\"failure\",{\"1\":{\"42\":1}}],[\"freqinlinesize=size\",{\"1\":{\"9\":1}}],[\"found\",{\"1\":{\"81\":1}}],[\"foo\",{\"1\":{\"9\":2}}],[\"forward\",{\"1\":{\"69\":1}}],[\"for\",{\"1\":{\"9\":2,\"13\":2,\"69\":1}}],[\"设置jvm参数即可\",{\"1\":{\"73\":1}}],[\"设置的值很大\",{\"1\":{\"62\":1}}],[\"设置不同的期望停顿时间\",{\"1\":{\"56\":1}}],[\"设置对象头\",{\"0\":{\"20\":1}}],[\"设置堆的最大可用大小\",{\"1\":{\"0\":1}}],[\"设置堆的初始可用大小\",{\"1\":{\"0\":1}}],[\"设定的值\",{\"1\":{\"58\":2}}],[\"设定要进行内联的琐碎方法的最大字节数\",{\"1\":{\"9\":1}}],[\"设定热点方法进行内联的最大字节数\",{\"1\":{\"9\":1}}],[\"设定内联方法的最大字节数\",{\"1\":{\"9\":1}}],[\"启用zgc比较简单\",{\"1\":{\"73\":1}}],[\"启用cms\",{\"1\":{\"43\":1}}],[\"启用方法内联\",{\"1\":{\"9\":1}}],[\"启动快\",{\"1\":{\"8\":1}}],[\"提高用户体验\",{\"1\":{\"40\":1}}],[\"提供多个跟inline内联相关参数\",{\"1\":{\"9\":1}}],[\"提前编译出来放到缓存当中\",{\"1\":{\"6\":1}}],[\"接下来jvm就会加上一个读屏障\",{\"1\":{\"72\":1}}],[\"接下来\",{\"1\":{\"9\":1}}],[\"的需求\",{\"1\":{\"73\":1}}],[\"的话会跟不上\",{\"1\":{\"73\":1}}],[\"的开销\",{\"1\":{\"72\":1}}],[\"的假设\",{\"1\":{\"67\":1}}],[\"的运作过程大致分为以下几个步骤\",{\"1\":{\"56\":1}}],[\"的方式实现记忆集\",{\"1\":{\"51\":1}}],[\"的指针集合\",{\"1\":{\"51\":1}}],[\"的数据结构\",{\"1\":{\"51\":1}}],[\"的垃圾回收器几乎都借鉴了三色标记的算法思想\",{\"1\":{\"50\":1}}],[\"的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作\",{\"1\":{\"39\":1}}],[\"的集合\",{\"1\":{\"30\":1}}],[\"的\",{\"1\":{\"30\":1}}],[\"的参数是否设置\",{\"1\":{\"26\":1}}],[\"的代码复制到test\",{\"1\":{\"9\":1}}],[\"的情况下\",{\"1\":{\"0\":1}}],[\"是因为实现复杂度还是另有考虑\",{\"1\":{\"67\":1}}],[\"是一款面向服务器的垃圾收集器\",{\"1\":{\"56\":1}}],[\"是否访问过\",{\"1\":{\"44\":1}}],[\"是否需要即时编译\",{\"1\":{\"7\":1}}],[\"是两个单独的方法但是当出现方法内联\",{\"1\":{\"9\":1}}],[\">>>>>>>>\",{\"1\":{\"9\":1}}],[\"large\",{\"1\":{\"68\":1}}],[\"lang\",{\"1\":{\"31\":1}}],[\"legacy\",{\"1\":{\"65\":1}}],[\"list\",{\"1\":{\"30\":3}}],[\"list<object>\",{\"1\":{\"30\":1}}],[\"load\",{\"1\":{\"50\":3,\"72\":1}}],[\"local\",{\"1\":{\"18\":1,\"73\":1}}],[\"lockelisiondemo\",{\"1\":{\"13\":1}}],[\"lock\",{\"0\":{\"13\":1}}],[\"long\",{\"1\":{\"9\":1,\"11\":1,\"13\":2}}],[\"l\",{\"1\":{\"9\":2}}],[\"not\",{\"1\":{\"81\":1}}],[\"net\",{\"1\":{\"65\":2}}],[\"new\",{\"1\":{\"9\":1,\"10\":2,\"13\":2,\"27\":2,\"29\":5,\"30\":3,\"44\":4,\"47\":5}}],[\"newratio\",{\"1\":{\"0\":1}}],[\"number\",{\"1\":{\"56\":1}}],[\"null\",{\"1\":{\"9\":1,\"44\":2,\"47\":1,\"48\":1}}],[\"tb级别的堆内存支持\",{\"1\":{\"66\":1}}],[\"targetsurvivorratio\",{\"1\":{\"61\":1}}],[\"targetsurvivorratio可以指定\",{\"1\":{\"25\":1}}],[\"table\",{\"1\":{\"51\":1,\"69\":1}}],[\"the\",{\"1\":{\"39\":2,\"42\":1,\"46\":1,\"56\":1}}],[\"this\",{\"1\":{\"30\":1}}],[\"threecolorremark\",{\"1\":{\"44\":1}}],[\"thread\",{\"1\":{\"18\":1}}],[\"throwable\",{\"1\":{\"30\":1}}],[\"throws\",{\"1\":{\"30\":1}}],[\"true\",{\"1\":{\"30\":1}}],[\"trivial\",{\"1\":{\"9\":1}}],[\"tlabsize来指定缓冲区大小\",{\"1\":{\"18\":1}}],[\"tlab\",{\"1\":{\"18\":1}}],[\"tostring\",{\"1\":{\"13\":2,\"30\":2}}],[\"t\",{\"1\":{\"10\":9}}],[\"test\",{\"1\":{\"27\":1}}],[\"test2\",{\"1\":{\"10\":1}}],[\"test1方法内的t对象就没有被方法外部引用\",{\"1\":{\"10\":1}}],[\"test1\",{\"1\":{\"10\":1}}],[\"testinline\",{\"1\":{\"9\":2}}],[\"tieredstopatlevel=1可以指定使用那一层编译器\",{\"1\":{\"8\":1}}],[\"o\",{\"1\":{\"72\":1}}],[\"o这行代码并没有从堆中读取数据\",{\"1\":{\"72\":1}}],[\"oracle官方提到了它最大的优点是\",{\"1\":{\"66\":1}}],[\"org\",{\"1\":{\"65\":1}}],[\"oop\",{\"1\":{\"47\":6,\"48\":2,\"50\":5}}],[\"oomtest\",{\"1\":{\"30\":2}}],[\"old垃圾收集器来回收\",{\"1\":{\"42\":1}}],[\"old\",{\"1\":{\"39\":1,\"40\":2,\"48\":2,\"50\":2}}],[\"override\",{\"1\":{\"30\":1}}],[\"out\",{\"1\":{\"9\":2,\"13\":2,\"30\":1}}],[\"objb\",{\"1\":{\"27\":1}}],[\"obj=\",{\"1\":{\"9\":1}}],[\"obj\",{\"1\":{\"9\":5,\"72\":1}}],[\"object\",{\"1\":{\"9\":2,\"72\":1}}],[\"openjdk\",{\"1\":{\"8\":1,\"65\":2}}],[\"实际可以超过该值\",{\"1\":{\"56\":1}}],[\"实际上\",{\"1\":{\"9\":1}}],[\"实例数据\",{\"1\":{\"20\":1}}],[\"实时编译\",{\"1\":{\"9\":1}}],[\"复制算法\",{\"0\":{\"36\":1}}],[\"复制\",{\"1\":{\"9\":1,\"36\":1,\"56\":1}}],[\"发生方法内联的前提是要让这个方法循环足够的次数\",{\"1\":{\"9\":1}}],[\"<\",{\"1\":{\"9\":2,\"13\":2}}],[\"id\",{\"1\":{\"30\":1}}],[\"if条件永远为false\",{\"1\":{\"9\":1}}],[\"if\",{\"1\":{\"9\":1}}],[\"i++\",{\"1\":{\"9\":2,\"13\":2,\"30\":1}}],[\"i\",{\"1\":{\"9\":4,\"13\":4,\"30\":1}}],[\"initiatingheapoccupancypercent\",{\"1\":{\"61\":1}}],[\"initiatingheapoccupancypercent​设置的值时则触发\",{\"1\":{\"59\":1}}],[\"init\",{\"1\":{\"56\":1}}],[\"incremental\",{\"1\":{\"46\":1}}],[\"instance\",{\"1\":{\"20\":1}}],[\"int\",{\"1\":{\"9\":16,\"13\":2,\"30\":2}}],[\"inlinesmallcode=size\",{\"1\":{\"9\":1}}],[\"inlinedemo\",{\"1\":{\"9\":1}}],[\"inline\",{\"0\":{\"9\":1},\"1\":{\"9\":1}}],[\"次\",{\"1\":{\"9\":1}}],[\"超过则触发\",{\"1\":{\"74\":1}}],[\"超过1秒\",{\"1\":{\"63\":1}}],[\"超过方法调用计数器的阈值\",{\"1\":{\"9\":1}}],[\"超过了设定的某一个阈值\",{\"1\":{\"7\":1}}],[\"=null\",{\"1\":{\"9\":1}}],[\"=\",{\"1\":{\"9\":4,\"10\":2,\"13\":6,\"27\":4,\"29\":3,\"30\":3,\"44\":8,\"47\":2,\"48\":2,\"49\":1,\"50\":2,\"72\":1}}],[\"allocation\",{\"1\":{\"73\":1}}],[\"allcation\",{\"1\":{\"18\":1}}],[\"azul\",{\"1\":{\"65\":1}}],[\"at\",{\"1\":{\"46\":1}}],[\"arraylist<>\",{\"1\":{\"30\":1}}],[\"args\",{\"1\":{\"9\":2,\"13\":1,\"30\":1,\"44\":1}}],[\"a\",{\"1\":{\"27\":10,\"44\":7,\"47\":1,\"48\":1,\"49\":1,\"50\":1}}],[\"age\",{\"1\":{\"24\":1}}],[\"aaaaa\",{\"1\":{\"13\":2}}],[\"append\",{\"1\":{\"13\":4}}],[\"analysis\",{\"0\":{\"10\":1}}],[\"add\",{\"1\":{\"9\":1,\"30\":2,\"48\":1,\"50\":1}}],[\"add2\",{\"1\":{\"9\":3}}],[\"add1\",{\"1\":{\"9\":2}}],[\"vm里的实现还是有三个非常短暂的safepoint\",{\"1\":{\"65\":1}}],[\"vm为例\",{\"1\":{\"50\":1}}],[\"vee05\",{\"1\":{\"65\":1}}],[\"version就可以看到当前使用的是那种模式\",{\"1\":{\"6\":1}}],[\"value\",{\"1\":{\"47\":6,\"48\":2,\"50\":2}}],[\"void\",{\"1\":{\"9\":4,\"10\":2,\"13\":1,\"27\":1,\"30\":2,\"44\":1,\"47\":2,\"48\":1,\"50\":1}}],[\"slow\",{\"1\":{\"72\":1}}],[\"slides\",{\"1\":{\"65\":1}}],[\"small\",{\"1\":{\"68\":1}}],[\"s0对应100个\",{\"1\":{\"56\":1}}],[\"shenandoah优化成多线程收集了\",{\"1\":{\"60\":1}}],[\"shenandoah可以看成是g1的升级版本\",{\"1\":{\"56\":1}}],[\"shenandoah就实现了并发收集\",{\"1\":{\"56\":1}}],[\"shenandoah\",{\"1\":{\"50\":1}}],[\"safe\",{\"0\":{\"77\":1,\"78\":1},\"1\":{\"78\":3}}],[\"satb相对增量更新效率会高\",{\"1\":{\"50\":1}}],[\"satb\",{\"1\":{\"46\":1,\"50\":1}}],[\"savet\",{\"1\":{\"10\":1}}],[\"snapshot\",{\"1\":{\"46\":1}}],[\"sweep\",{\"1\":{\"42\":2}}],[\"scavenge\",{\"1\":{\"39\":1,\"40\":4}}],[\"self\",{\"1\":{\"69\":2}}],[\"set\",{\"1\":{\"48\":1,\"50\":1,\"51\":1,\"56\":1,\"65\":1,\"69\":1,\"70\":1}}],[\"setage\",{\"1\":{\"10\":2}}],[\"server\",{\"1\":{\"41\":1}}],[\"serial\",{\"1\":{\"39\":5,\"40\":2,\"41\":1}}],[\"softreference<user>\",{\"1\":{\"29\":2}}],[\"something\",{\"1\":{\"9\":1}}],[\"survivor区域里的一批对象\",{\"1\":{\"61\":1}}],[\"survivor区的填充容量\",{\"1\":{\"61\":1}}],[\"survivor\",{\"1\":{\"24\":3}}],[\"survivorratio\",{\"1\":{\"0\":1}}],[\"sb\",{\"1\":{\"13\":8}}],[\"s2\",{\"1\":{\"13\":4}}],[\"s1对应100个\",{\"1\":{\"56\":1}}],[\"s1\",{\"1\":{\"13\":4}}],[\"system\",{\"1\":{\"9\":4,\"13\":6,\"30\":1}}],[\"store\",{\"1\":{\"47\":2}}],[\"stop\",{\"1\":{\"39\":2}}],[\"stw\",{\"1\":{\"42\":1,\"56\":3}}],[\"statudy\",{\"0\":{\"83\":1}}],[\"static关键字修饰方法\",{\"1\":{\"9\":1}}],[\"static\",{\"1\":{\"9\":4,\"13\":3,\"29\":3,\"30\":1,\"44\":1}}],[\"start\",{\"1\":{\"69\":1}}],[\"starttime2\",{\"1\":{\"13\":2}}],[\"starttime\",{\"1\":{\"13\":2}}],[\"stringbuilder耗时\",{\"1\":{\"13\":3}}],[\"stringbuilder\",{\"1\":{\"13\":2}}],[\"stringbuffer耗时\",{\"1\":{\"13\":3}}],[\"stringbuffer\",{\"1\":{\"13\":2}}],[\"string\",{\"1\":{\"9\":2,\"13\":7,\"30\":1,\"44\":1}}],[\"内完成垃圾收集\",{\"1\":{\"56\":1}}],[\"内存使用会多出1\",{\"1\":{\"21\":1}}],[\"内存分配完成后\",{\"1\":{\"19\":1}}],[\"内存占用多\",{\"1\":{\"8\":1}}],[\"内联优化\",{\"1\":{\"9\":1}}],[\"+cmsparallelremarkenabled\",{\"1\":{\"43\":1}}],[\"+cmsparallellnitialmarkenabled\",{\"1\":{\"43\":1}}],[\"+cmsscavengebeforeremark\",{\"1\":{\"43\":1}}],[\"+eliminateallocations\",{\"1\":{\"22\":1}}],[\"+unlockexperimentalvmoptions\",{\"1\":{\"73\":1}}],[\"+unlockdiagnosticvmoptions\",{\"1\":{\"9\":2}}],[\"+usezgc\",{\"1\":{\"73\":1}}],[\"+useg1gc\",{\"0\":{\"56\":1},\"1\":{\"61\":1}}],[\"+usecmsinitiatingoccupancyonly\",{\"1\":{\"43\":1}}],[\"+usecmscompactatfullcollection\",{\"1\":{\"43\":1}}],[\"+usecmscompactatfullcollection可以让jvm在执行完标记清除后再做整理\",{\"1\":{\"42\":1}}],[\"+useconcmarksweepgc\",{\"1\":{\"43\":1}}],[\"+usetlab参数来关闭和开启本地线程分配缓冲\",{\"1\":{\"18\":1}}],[\"+inline\",{\"1\":{\"9\":1}}],[\"+printgcdetails\",{\"1\":{\"22\":1}}],[\"+printinlining\",{\"1\":{\"9\":2}}],[\"+printcompilation\",{\"1\":{\"9\":1}}],[\"+\",{\"1\":{\"9\":2,\"13\":2,\"21\":1,\"30\":2,\"50\":2}}],[\"p\",{\"1\":{\"72\":1}}],[\"point是针对正在执行线程设计的\",{\"1\":{\"78\":1}}],[\"point\",{\"0\":{\"77\":1}}],[\"pointers的4个颜色位\",{\"1\":{\"72\":1}}],[\"pointers\",{\"1\":{\"70\":1}}],[\"post\",{\"1\":{\"47\":1}}],[\"pgc在azul\",{\"1\":{\"65\":1}}],[\"pgc虽然算法上可以做成完全并发\",{\"1\":{\"65\":1}}],[\"pgc简单来说是\",{\"1\":{\"65\":1}}],[\"p46\",{\"1\":{\"65\":1}}],[\"pdf\",{\"1\":{\"65\":2}}],[\"path\",{\"1\":{\"72\":1}}],[\"pause\",{\"1\":{\"69\":2}}],[\"papers\",{\"1\":{\"65\":1}}],[\"partial\",{\"1\":{\"51\":1}}],[\"param\",{\"1\":{\"47\":2}}],[\"parallelgcthreads\",{\"1\":{\"40\":1,\"61\":1}}],[\"parallel\",{\"1\":{\"39\":1,\"40\":7,\"41\":1,\"75\":1}}],[\"parnew\",{\"1\":{\"41\":1}}],[\"padding\",{\"1\":{\"20\":1}}],[\"prepare\",{\"1\":{\"69\":1}}],[\"pre\",{\"1\":{\"47\":1,\"48\":1,\"50\":2}}],[\"pretenuresizethreshold参数设置大对象阈值\",{\"1\":{\"23\":1}}],[\"protected\",{\"1\":{\"30\":1}}],[\"println\",{\"1\":{\"9\":2,\"13\":2,\"30\":1}}],[\"private\",{\"1\":{\"9\":4,\"10\":2}}],[\"public\",{\"1\":{\"9\":7,\"13\":4,\"27\":3,\"30\":2,\"44\":2}}],[\"per大大毫无遮掩地表示当前的zgc如果遇到非常高的对象分配速率\",{\"1\":{\"73\":1}}],[\"performancetacticindex\",{\"1\":{\"8\":2}}],[\"permsize代表永久代的初始容量\",{\"1\":{\"0\":1}}],[\"permsize参数意思不一样\",{\"1\":{\"0\":1}}],[\"进一步减少频繁创建栈帧的性能开销\",{\"1\":{\"9\":1}}],[\"进行内联优化\",{\"1\":{\"9\":1}}],[\"进行简单的优化\",{\"1\":{\"8\":1}}],[\"进行优化的耗时也更长等\",{\"1\":{\"8\":1}}],[\"即周期结束标识为10\",{\"1\":{\"70\":1}}],[\"即周期结束标识为01\",{\"1\":{\"70\":1}}],[\"即颜色指针\",{\"1\":{\"70\":1}}],[\"即发生引用字段赋值时\",{\"1\":{\"52\":1}}],[\"即512字节\",{\"1\":{\"51\":1}}],[\"即代表不可达\",{\"1\":{\"44\":1}}],[\"即将被回收\",{\"1\":{\"30\":1}}],[\"即将回收\",{\"1\":{\"30\":1}}],[\"即使在可达性分析算法中不可达的对象\",{\"1\":{\"30\":1}}],[\"即使程序员写的代码不够优化\",{\"1\":{\"8\":1}}],[\"即不能再被任何途径使用的对象\",{\"1\":{\"26\":1}}],[\"即8字节\",{\"1\":{\"21\":1}}],[\"即为属性赋值\",{\"1\":{\"21\":1}}],[\"即对象按照程序员意愿进行初始化\",{\"1\":{\"21\":1}}],[\"即对象指向它的类元数据的指针\",{\"1\":{\"20\":1}}],[\"即一部分空闲的和已使用的相互交错\",{\"1\":{\"18\":1}}],[\"即左边都是内存\",{\"1\":{\"18\":1}}],[\"即jvm将java堆内一部分区域划分给这个对象使用\",{\"1\":{\"18\":1}}],[\"即1\",{\"1\":{\"0\":1}}],[\"50\",{\"1\":{\"63\":1}}],[\"5倍左右\",{\"1\":{\"21\":1}}],[\"5\",{\"0\":{\"21\":1},\"1\":{\"8\":1,\"39\":1}}],[\"同时也无法支持32位的操作系统\",{\"1\":{\"70\":1}}],[\"同时gc线程开始对未标记的区域做清扫\",{\"1\":{\"42\":1}}],[\"同时工作\",{\"1\":{\"42\":1}}],[\"同时启动会更慢\",{\"1\":{\"8\":1}}],[\"同时收集器会对该值进行调整\",{\"1\":{\"0\":1}}],[\"虚引用也称为幽灵引用或者幻影引用\",{\"1\":{\"29\":1}}],[\"虚引用\",{\"1\":{\"29\":2}}],[\"虚方法调用版本等全部信息\",{\"1\":{\"8\":1}}],[\"虚拟机的记录操作都是通过写屏障实现的\",{\"1\":{\"46\":1}}],[\"虚拟机的设计者们当然知道\",{\"1\":{\"39\":1}}],[\"虚拟机第一款真正意义上的并发收集器\",{\"1\":{\"42\":1}}],[\"虚拟机就不会实现那么多不同的垃圾收集器了\",{\"1\":{\"38\":1}}],[\"虚拟机给每个对象一个对象年龄\",{\"1\":{\"24\":1}}],[\"虚拟机采用分代的算法进行对象管理和垃圾收集\",{\"1\":{\"24\":1}}],[\"虚拟机采用cas+重新分配方式保证更新时的原子性来保证并发时的内存分配\",{\"1\":{\"18\":1}}],[\"虚拟机不会将一个对象完整的分配到栈上\",{\"1\":{\"22\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"20\":1}}],[\"虚拟机需要对对象设置对象头\",{\"1\":{\"20\":1}}],[\"虚拟机需要将分配的空间都初始化为零值\",{\"1\":{\"19\":1}}],[\"虚拟机会维护一个列表\",{\"1\":{\"18\":1}}],[\"虚拟机会对新生对象分配内存操作\",{\"1\":{\"18\":1}}],[\"虚拟机执行new方法指令时\",{\"1\":{\"17\":1}}],[\"虚拟机执⾏\",{\"1\":{\"5\":1}}],[\"虚拟机中的内联过程却远没有想象中那么容易\",{\"1\":{\"9\":1}}],[\"虚拟机没有太⼤的关系\",{\"1\":{\"5\":1}}],[\"虚拟机之外执⾏\",{\"1\":{\"5\":1}}],[\"还得考虑每次gc过后的存活对象有多少\",{\"1\":{\"62\":1}}],[\"还能建立可预测的停顿时间模型\",{\"1\":{\"56\":1}}],[\"还具备高吞吐量性能特征\",{\"1\":{\"56\":1}}],[\"还有性能的考虑\",{\"1\":{\"50\":1}}],[\"还有并发清理\",{\"1\":{\"45\":1}}],[\"还可以为后续进一步的优化手段创建条件\",{\"1\":{\"11\":1}}],[\"还会占用更多的codecache\",{\"1\":{\"9\":1}}],[\"还会收集如分支跳转\",{\"1\":{\"8\":1}}],[\"还需要解释执行来帮助提供一些信息支持\",{\"1\":{\"6\":1}}],[\"仍然是白色的对象\",{\"1\":{\"44\":1}}],[\"仍然还有停顿\",{\"1\":{\"39\":1}}],[\"仍然使用c1编译器来执行\",{\"1\":{\"8\":1}}],[\"仍使用c1编译器来执行\",{\"1\":{\"8\":1}}],[\"不直接对线程操作\",{\"1\":{\"77\":1}}],[\"不如说是标记指针\",{\"1\":{\"69\":1}}],[\"不像c4\",{\"1\":{\"67\":1}}],[\"不区分年轻代和老年代\",{\"1\":{\"67\":1}}],[\"不分代\",{\"0\":{\"67\":1}}],[\"不可能\",{\"1\":{\"64\":1}}],[\"不会马上做young\",{\"1\":{\"58\":1}}],[\"不能异想天开\",{\"1\":{\"56\":1}}],[\"不过会根据线程的多少啊\",{\"1\":{\"65\":1}}],[\"不过\",{\"1\":{\"56\":1}}],[\"不过到了zgc\",{\"1\":{\"56\":1}}],[\"不管是年轻代或是老年代\",{\"1\":{\"56\":1}}],[\"不用直接进老年代\",{\"1\":{\"56\":1}}],[\"不经过灰色对象\",{\"1\":{\"44\":1}}],[\"不同的垃圾收集器会略微有点不同\",{\"1\":{\"24\":1}}],[\"不需要手动启用指针压缩\",{\"1\":{\"21\":1}}],[\"不存在线程竞争\",{\"1\":{\"13\":1}}],[\"不开启性能监控\",{\"1\":{\"8\":1}}],[\"不限制\",{\"1\":{\"0\":1}}],[\"纯解释执行\",{\"1\":{\"8\":1}}],[\"性能\",{\"1\":{\"8\":1}}],[\"描述\",{\"1\":{\"8\":1}}],[\"划分出不同的编译层次\",{\"1\":{\"8\":1}}],[\"分代收集\",{\"1\":{\"56\":1}}],[\"分代收集理论\",{\"0\":{\"35\":1}}],[\"分配速率\",{\"1\":{\"74\":1}}],[\"分配给这个对象\",{\"1\":{\"18\":1}}],[\"分配内存\",{\"0\":{\"18\":1}}],[\"分层编译根据编译器编译\",{\"1\":{\"8\":1}}],[\"分别被称为\",{\"1\":{\"8\":1}}],[\"所截获\",{\"1\":{\"69\":1}}],[\"所有期望的引用都能被重新标记\",{\"1\":{\"70\":1}}],[\"所有标志都变成了未标记\",{\"1\":{\"70\":1}}],[\"所有涉及部分区域收集\",{\"1\":{\"51\":1}}],[\"所有的对象都是白色的\",{\"1\":{\"44\":1}}],[\"所有使用过的内存都在一边\",{\"1\":{\"18\":1}}],[\"所谓的写屏障\",{\"1\":{\"47\":1}}],[\"所谓吞吐量就是\",{\"1\":{\"40\":1}}],[\"所谓对象之间的相互引用问题\",{\"1\":{\"27\":1}}],[\"所分配内存仅仅是把指针向空闲一边移动所需大小的相等的距离\",{\"1\":{\"18\":1}}],[\"所花费的时间便会越长\",{\"1\":{\"8\":1}}],[\"所以只能在下次gc的时候进行回收\",{\"1\":{\"73\":1}}],[\"所以只有第一次访问旧对象会变慢\",{\"1\":{\"69\":1}}],[\"所以受限于目前的硬件\",{\"1\":{\"72\":1}}],[\"所以会导致配置zgc的应用的吞吐量会变低\",{\"1\":{\"72\":1}}],[\"所以gc正常工作的时候除了会在自己的线程上吃点cpu之外并不会显著干扰应用的运行\",{\"1\":{\"65\":1}}],[\"所以g1选择satb不深度扫描对象\",{\"1\":{\"50\":1}}],[\"所以这个重映射操作并不是很迫切\",{\"1\":{\"69\":1}}],[\"所以这个暂停就不会随着gc堆的大小而变化\",{\"1\":{\"65\":1}}],[\"所以这个sychronized没有起作用\",{\"1\":{\"13\":1}}],[\"所以这里的优化核心还是在于调节\",{\"1\":{\"62\":1}}],[\"所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的\",{\"1\":{\"56\":1}}],[\"所以通常想要检查锁是否存在多线程竞争比较困难\",{\"1\":{\"13\":1}}],[\"所以对于选择哪种\",{\"1\":{\"50\":1}}],[\"所以在后续的垃圾收集器设计中停顿时间在不断缩短\",{\"1\":{\"39\":1}}],[\"所以我们必须选择\",{\"1\":{\"35\":1}}],[\"所以可以选择复制算法\",{\"1\":{\"35\":1}}],[\"所以\",{\"1\":{\"12\":2}}],[\"所以没有办法提前维护出一个完整的字节码缓存\",{\"1\":{\"6\":1}}],[\"所以与\",{\"1\":{\"5\":1}}],[\"由于一个线程的栈的大小通常不会太大\",{\"1\":{\"22\":1}}],[\"由于即时编译器编译本地代码需要占用程序运行时间\",{\"1\":{\"8\":1}}],[\"由于调整元空间大小需要fullgc\",{\"1\":{\"0\":1}}],[\"比较简单\",{\"1\":{\"37\":1}}],[\"比较适合资源相对充裕的服务器\",{\"1\":{\"8\":1}}],[\"比较适合一些小巧的桌面应用\",{\"1\":{\"8\":1}}],[\"比如gc等\",{\"1\":{\"77\":1}}],[\"比如64g\",{\"1\":{\"64\":1}}],[\"比如我们之前说的堆默认有2048个region\",{\"1\":{\"61\":1}}],[\"比如一个region花200ms能回收10m垃圾\",{\"1\":{\"56\":1}}],[\"比如说老年代此时有1000个region都满了\",{\"1\":{\"56\":1}}],[\"比如按照上面算的\",{\"1\":{\"56\":1}}],[\"比如堆大小为4096m\",{\"1\":{\"56\":1}}],[\"比如写屏障可以用于记录跨代\",{\"1\":{\"50\":1}}],[\"比如白色\",{\"1\":{\"50\":1}}],[\"比如新增引用\",{\"1\":{\"49\":1}}],[\"比如引用消失\",{\"1\":{\"48\":1}}],[\"比如在新生代中\",{\"1\":{\"35\":1}}],[\"比如像这样的方法\",{\"1\":{\"9\":1}}],[\"比如\",{\"1\":{\"9\":1}}],[\"比如如下代码\",{\"1\":{\"9\":1}}],[\"比率\",{\"1\":{\"7\":1}}],[\"但程序运行中会存在sleep或者中断的线程\",{\"1\":{\"78\":1}}],[\"但与其说是标记对象\",{\"1\":{\"69\":1}}],[\"但它的实际容量完全有可能小于中型region\",{\"1\":{\"68\":1}}],[\"但必须为2mb的整数倍\",{\"1\":{\"68\":1}}],[\"但zgc目前实现起来太麻烦\",{\"1\":{\"67\":1}}],[\"但azul\",{\"1\":{\"65\":1}}],[\"但应用运行时间一长就不行了\",{\"1\":{\"56\":1}}],[\"但如果我们把停顿时间调得非常低\",{\"1\":{\"56\":1}}],[\"但g1\",{\"1\":{\"56\":1}}],[\"但不包括gc堆里的对象指针\",{\"1\":{\"65\":1}}],[\"但不再是物理隔离了\",{\"1\":{\"56\":1}}],[\"但不能支持线程逃逸\",{\"1\":{\"12\":1}}],[\"但这个对象上至少存在一个引用还没有被扫描过\",{\"1\":{\"44\":1}}],[\"但并非为了挑选出一个最好的收集器\",{\"1\":{\"38\":1}}],[\"但后续步骤不是直接对可回收对象回收\",{\"1\":{\"38\":1}}],[\"但minor\",{\"1\":{\"26\":1}}],[\"但使用64位进行存储\",{\"1\":{\"21\":1}}],[\"但有一种情况比较简单\",{\"1\":{\"13\":1}}],[\"但实际上两个编译器不是相互取代而是相互协作的关系\",{\"1\":{\"8\":1}}],[\"但也相应的\",{\"1\":{\"8\":1}}],[\"但翻译出来的机器码优化程度不高\",{\"1\":{\"8\":1}}],[\"但是zgc的总的执行时间还是远远大于这个时间的\",{\"1\":{\"73\":1}}],[\"但是zgc中对象引用存在\",{\"1\":{\"69\":1}}],[\"但是转发表还得留着不能释放掉\",{\"1\":{\"69\":1}}],[\"但是如果调的过低的话\",{\"1\":{\"66\":1}}],[\"但是gc过程中所有的阶段都设计为可以并发的\",{\"1\":{\"65\":1}}],[\"但是gc做完后发现释放不出空间存放新的对象\",{\"1\":{\"29\":1}}],[\"但是还是保留了分代的概念\",{\"1\":{\"56\":1}}],[\"但是因为只回收一部分region\",{\"1\":{\"56\":1}}],[\"但是因为根据预期停顿时间\",{\"1\":{\"56\":1}}],[\"但是最多新生代的占比不会超过60\",{\"1\":{\"56\":1}}],[\"但是推荐默认的计算方式\",{\"1\":{\"56\":1}}],[\"但是不推荐\",{\"1\":{\"56\":1}}],[\"但是需要知道如何让卡表变脏\",{\"1\":{\"52\":1}}],[\"但是有其他体现颜色的地方\",{\"1\":{\"50\":1}}],[\"但是它有下面几个明显的缺点\",{\"1\":{\"42\":1}}],[\"但是一般不推荐修改\",{\"1\":{\"40\":1}}],[\"但是会带来两个明显的问题\",{\"1\":{\"37\":1}}],[\"但是他们因为互相引用对方\",{\"1\":{\"27\":1}}],[\"但是目前主流的虚拟机中并没有选择这个算法来管理内存\",{\"1\":{\"27\":1}}],[\"但是\",{\"1\":{\"9\":1,\"39\":1}}],[\"但是jvm也不清楚程序员会写出什么样的代码\",{\"1\":{\"6\":1}}],[\"但是这种方式需要在上层语言和机器码之间经过中间⼀层jvm字节码的转换\",{\"1\":{\"6\":1}}],[\"占用较大带宽\",{\"1\":{\"21\":1}}],[\"占用资源更多\",{\"1\":{\"8\":1}}],[\"占用内存小\",{\"1\":{\"8\":1}}],[\"占整个堆内存的1\",{\"1\":{\"0\":1}}],[\"简称c1编译器和c2编译器\",{\"1\":{\"8\":1}}],[\"服务端编译器\",{\"1\":{\"8\":1}}],[\"客户端编译器\",{\"1\":{\"8\":1}}],[\"客户端编译器和服务端编译器\",{\"0\":{\"8\":1}}],[\"阈值计算公式\",{\"1\":{\"7\":2}}],[\"当线程运行到这些位置时\",{\"1\":{\"77\":1}}],[\"当加上读屏障时\",{\"1\":{\"72\":1}}],[\"当老年代占有率达到了参数\",{\"1\":{\"59\":1}}],[\"当老年代使用达到该比例时会触发fullgc\",{\"1\":{\"43\":1}}],[\"当读取成员变量时\",{\"1\":{\"50\":1}}],[\"当这一块的内存使用完后\",{\"1\":{\"36\":1}}],[\"当这个方法调用次数非常多\",{\"1\":{\"7\":1}}],[\"当前虚拟机的垃圾收集都采用分代收集算法\",{\"1\":{\"35\":1}}],[\"当前放对象的survivor区域里\",{\"1\":{\"25\":1}}],[\"当前代码中\",{\"1\":{\"13\":1}}],[\"当它的年龄增加到一定程度\",{\"1\":{\"24\":1}}],[\"当对象a的成员变量的引用发生变化时\",{\"1\":{\"49\":1}}],[\"当对象b的成员变量的引用发生变化时\",{\"1\":{\"48\":1}}],[\"当对象没有覆盖finalize方法\",{\"1\":{\"30\":1}}],[\"当对象没有被引用的时候\",{\"1\":{\"22\":1}}],[\"当对象需要大量且连续的空间时\",{\"1\":{\"23\":1}}],[\"当一个对象在方法中被定义后\",{\"1\":{\"22\":1}}],[\"当堆内存大于32g时\",{\"1\":{\"21\":1}}],[\"当堆内存小于4g时\",{\"1\":{\"21\":1}}],[\"当内存大于4g时\",{\"1\":{\"21\":1}}],[\"当无法进行本地线程分配缓冲时\",{\"1\":{\"18\":1}}],[\"当java堆内存并不是规整的\",{\"1\":{\"18\":1}}],[\"当jvm检测到一个加锁的代码不会出现锁竞争时\",{\"1\":{\"13\":1}}],[\"当使用jvm参数\",{\"1\":{\"13\":1}}],[\"当然satb可能造成更多的浮动垃圾\",{\"1\":{\"50\":1}}],[\"当然通过参数\",{\"1\":{\"42\":1}}],[\"当然也可以用参数\",{\"1\":{\"40\":1,\"56\":1}}],[\"当然有\",{\"1\":{\"39\":1}}],[\"当然\",{\"1\":{\"9\":1}}],[\"当识别出热点代码后\",{\"1\":{\"8\":1}}],[\"当再次执行时\",{\"1\":{\"6\":1}}],[\"每秒处理几万甚至几十万消息时很正常的\",{\"1\":{\"64\":1}}],[\"每个对象有64位的指针\",{\"1\":{\"70\":1}}],[\"每个大型region中只会存放一个大对象\",{\"1\":{\"68\":1}}],[\"每个region是2m\",{\"1\":{\"56\":1}}],[\"每个元素对应着其标识的内存区域一块特定大小的内存块\",{\"1\":{\"51\":1}}],[\"每个线程的栈大小\",{\"1\":{\"0\":1}}],[\"每款垃圾回收器都有自己的想法\",{\"1\":{\"50\":1}}],[\"每次从堆内对象的引用类型中读取一个指针时\",{\"1\":{\"72\":1}}],[\"每次根据允许的收集时间\",{\"1\":{\"56\":1}}],[\"每次使用其中的一块\",{\"1\":{\"36\":1}}],[\"每次收集都会有大量对象\",{\"1\":{\"35\":1}}],[\"每当某个方法被调用一次时\",{\"1\":{\"7\":1}}],[\"热点代码在被jit即时编译的过程中\",{\"1\":{\"8\":1}}],[\"热点代码识别\",{\"0\":{\"7\":1}}],[\"热点探测\",{\"1\":{\"7\":1}}],[\"会存在上一次垃圾回收还没执行完\",{\"1\":{\"42\":1}}],[\"会和服务抢资源\",{\"1\":{\"42\":1}}],[\"会直接进入老年代\",{\"1\":{\"23\":1}}],[\"会直接从缓存中获取机器码直接执行\",{\"1\":{\"6\":1}}],[\"会触发minor\",{\"1\":{\"23\":1}}],[\"会给gc带来较大压力\",{\"1\":{\"22\":1}}],[\"会对这个对象的锁进行锁消除\",{\"1\":{\"13\":1}}],[\"会对代码进行一些优化\",{\"1\":{\"8\":1}}],[\"会默认使用混合模式\",{\"1\":{\"6\":1}}],[\"因为zgc调优参数并不多\",{\"1\":{\"73\":1}}],[\"因为目前主板地址总线最宽只有48bit\",{\"1\":{\"72\":1}}],[\"因为使用了读屏障\",{\"1\":{\"71\":1}}],[\"因为可能还有访问在使用这个转发表\",{\"1\":{\"69\":1}}],[\"因为复制一个大对象的代价非常高昂\",{\"1\":{\"68\":1}}],[\"因为内存太大\",{\"1\":{\"64\":1}}],[\"因为不需要在重新标记阶段再次深度扫描被删除引用对象\",{\"1\":{\"50\":1}}],[\"因为标记期间应用线程还在继续跑\",{\"1\":{\"44\":1}}],[\"因为用户程序继续运行\",{\"1\":{\"42\":1}}],[\"因为直到现在为止还没有最好的垃圾收集器出现\",{\"1\":{\"38\":1}}],[\"因为虚拟机栈是对应一个线程的\",{\"1\":{\"12\":1}}],[\"因为编译执行需要识别热点代码\",{\"1\":{\"6\":1}}],[\"因此jvm引入安全区域\",{\"1\":{\"78\":1}}],[\"因此gc也不是随时都能立即触发的\",{\"1\":{\"77\":1}}],[\"因此zgc无法使用指针压缩\",{\"1\":{\"70\":1}}],[\"因此zgc可以支持2^42=4tb内存\",{\"1\":{\"70\":1}}],[\"因此\",{\"1\":{\"13\":1}}],[\"因此他不会逃逸\",{\"1\":{\"10\":1}}],[\"因此也被称为服务端编译器\",{\"1\":{\"8\":1}}],[\"因此也被称为客户端编译器\",{\"1\":{\"8\":1}}],[\"因此在hotspot中\",{\"1\":{\"6\":1}}],[\"在这个区域内进行gc都是安全的\",{\"1\":{\"78\":1}}],[\"在这个期间由于对象分配速率很高\",{\"1\":{\"73\":1}}],[\"在耗尽之前触发gc\",{\"1\":{\"74\":1}}],[\"在堆内存达到10\",{\"1\":{\"74\":1}}],[\"在堆内为每个线程划分出一块单独区域\",{\"1\":{\"18\":1}}],[\"在标记和移动阶段\",{\"1\":{\"72\":1}}],[\"在标记完成后统一回收所有被标记的对象\",{\"1\":{\"37\":1}}],[\"在每个gc周期开始\",{\"1\":{\"70\":1}}],[\"在半导体现有的发展情况下\",{\"1\":{\"66\":1}}],[\"在保证他的年轻代gc别太频繁的同时\",{\"1\":{\"62\":1}}],[\"在混合回收的时候\",{\"1\":{\"61\":1}}],[\"在一次回收过程中指定做几次筛选回收\",{\"1\":{\"61\":1}}],[\"在一般应用中\",{\"1\":{\"12\":1}}],[\"在下次垃圾回收时再处理\",{\"1\":{\"56\":1}}],[\"在回收时间有限情况下\",{\"1\":{\"56\":1}}],[\"在g1中\",{\"1\":{\"56\":1}}],[\"在系统运行中\",{\"1\":{\"56\":1}}],[\"在新生代可以引入记录集\",{\"1\":{\"51\":1}}],[\"在新生代做gcroots可达性扫描过程中可能会碰到跨代引用的对象\",{\"1\":{\"51\":1}}],[\"在并发扫描结束之后\",{\"1\":{\"46\":1}}],[\"在并发标记过程中\",{\"1\":{\"45\":1}}],[\"在并发标记的过程中\",{\"1\":{\"44\":1}}],[\"在并发标记和并发清理阶段又产生垃圾\",{\"1\":{\"42\":1}}],[\"在重新标记的时候多线程执行\",{\"1\":{\"43\":1}}],[\"在cms\",{\"1\":{\"43\":1}}],[\"在注重吞吐量以及\",{\"1\":{\"40\":1}}],[\"在寄存器中是35位\",{\"1\":{\"21\":1}}],[\"在64位系统中\",{\"1\":{\"21\":1}}],[\"在分配时查找一块空间足够的可用内存\",{\"1\":{\"18\":1}}],[\"在加载完成便可以确定\",{\"1\":{\"18\":1}}],[\"在触发了jit时\",{\"1\":{\"13\":1}}],[\"在它的append和tostring方法都加了sychronized同步锁\",{\"1\":{\"13\":1}}],[\"在内存不紧张的情况下\",{\"1\":{\"9\":1}}],[\"在编程中\",{\"1\":{\"9\":1}}],[\"在编译过程中\",{\"1\":{\"8\":2}}],[\"在编译时不可避免的需要进行编译优化\",{\"1\":{\"8\":1}}],[\"在编译执行识别热点代码的过程中\",{\"1\":{\"6\":1}}],[\"在jvm中32位地址可以支持4g内存\",{\"1\":{\"21\":1}}],[\"在jvm运行参数确定的前提下\",{\"1\":{\"7\":1}}],[\"在jdk8中\",{\"1\":{\"9\":1}}],[\"在解释时\",{\"1\":{\"8\":1}}],[\"在hotspot虚拟机中\",{\"1\":{\"8\":1,\"20\":1}}],[\"在hotspot中使方法调用计数器和回边计数器来实现\",{\"1\":{\"7\":1}}],[\"在字节码中遇到的向后跳转的指令称之为回边\",{\"1\":{\"7\":1}}],[\"在应用启动过程中发生大量fullgc\",{\"1\":{\"0\":1}}],[\"需要等到所有线程运行到安全点时才能触发\",{\"1\":{\"77\":1}}],[\"需要\",{\"1\":{\"72\":1}}],[\"需要把各个region中的对象拷贝到别的region中\",{\"1\":{\"59\":1}}],[\"需要重新构建\",{\"1\":{\"29\":1}}],[\"需要依靠gc进行回收内存\",{\"1\":{\"22\":1}}],[\"需要额外的codecache存储编译的代码\",{\"1\":{\"6\":1}}],[\"需要进行机器编译\",{\"1\":{\"6\":1}}],[\"兼顾效率和运行成本\",{\"1\":{\"6\":1}}],[\"而添加分代或者thread\",{\"1\":{\"73\":1}}],[\"而不必等待整个堆中所有指向该region的引用都被修正后才能清理\",{\"1\":{\"71\":1}}],[\"而不是让大对象直接进入老年代的region中\",{\"1\":{\"56\":1}}],[\"而不是单纯的使用其中一种模式\",{\"1\":{\"6\":1}}],[\"而zgc的gc信息保存在指针中\",{\"1\":{\"70\":1}}],[\"而root数量和堆大小是没有任何关系的\",{\"1\":{\"66\":1}}],[\"而cms对增量引用的根对象会做深度扫描\",{\"1\":{\"50\":1}}],[\"而老年代的对象存活几率是比较高的\",{\"1\":{\"35\":1}}],[\"而是原子类型\",{\"1\":{\"72\":1}}],[\"而是让所有存活的对象向一端移动\",{\"1\":{\"38\":1}}],[\"而是使用标量替换的方法进\",{\"1\":{\"22\":1}}],[\"而是默认采用了混合模式\",{\"1\":{\"6\":1}}],[\"而stringbuilder则没加\",{\"1\":{\"13\":1}}],[\"而stringbuffer是线程安全的\",{\"1\":{\"13\":1}}],[\"而瘦身的方式\",{\"1\":{\"12\":1}}],[\"而栈是一个非常小的内存结构\",{\"1\":{\"12\":1}}],[\"而堆内存是对应整个java进程的\",{\"1\":{\"12\":1}}],[\"而改为直接创建它的若干个被这个方法使用的成员变量来代替\",{\"1\":{\"11\":1}}],[\"而test2方法中的t就逃逸到其他方法了\",{\"1\":{\"10\":1}}],[\"而进行jit时\",{\"1\":{\"8\":1}}],[\"而且不需要stw\",{\"1\":{\"72\":1}}],[\"而且停顿用户线程将大幅提高收集效率\",{\"1\":{\"56\":1}}],[\"而且一个大对象如果太大\",{\"1\":{\"56\":1}}],[\"而且没有额外的空间对它进行分配担保\",{\"1\":{\"35\":1}}],[\"而且\",{\"1\":{\"9\":1}}],[\"而且想要编译出优化程度更高的代码\",{\"1\":{\"8\":1}}],[\"而且在class编译时会对原文件进行一定优化\",{\"1\":{\"4\":1}}],[\"故而退而求其次\",{\"1\":{\"6\":1}}],[\"后面3行代码都不需要加读屏障\",{\"1\":{\"72\":1}}],[\"后面会介绍到\",{\"1\":{\"41\":1}}],[\"后续则会自动调整\",{\"1\":{\"43\":1}}],[\"后仍然能够存活\",{\"1\":{\"24\":1}}],[\"后可以看到以下的执行日志\",{\"1\":{\"9\":1}}],[\"后执行的方式称为编译执行\",{\"1\":{\"6\":1}}],[\"后端编译\",{\"0\":{\"5\":1}}],[\"将创建大量的新对象\",{\"1\":{\"73\":1}}],[\"将这些region组成重分配集\",{\"1\":{\"69\":1}}],[\"将一个region中的存活对象复制到另一个region中\",{\"1\":{\"56\":1}}],[\"将a新的成员变量引用对象d记录下来\",{\"1\":{\"49\":1}}],[\"将b原来成员变量的引用对象d记录下来\",{\"1\":{\"48\":1}}],[\"将白色对象直接标记为黑色\",{\"1\":{\"46\":1}}],[\"将对象用weakreference软引用类型的对象包裹\",{\"1\":{\"29\":1}}],[\"将对象用softreference软引用类型的对象包裹\",{\"1\":{\"29\":1}}],[\"将对象拆分后\",{\"1\":{\"11\":1}}],[\"将\",{\"1\":{\"28\":1}}],[\"将被移动到\",{\"1\":{\"24\":1}}],[\"将该对象成员变量分解若干个被这个方法使用的成员变量所代替\",{\"1\":{\"22\":1}}],[\"将foo\",{\"1\":{\"9\":1}}],[\"将那些运行频率高的热点代码进行提前编译\",{\"1\":{\"6\":1}}],[\"将那些字节码指令\",{\"1\":{\"6\":1}}],[\"将class的字节码文件解释编译成机器码供计算机执行\",{\"1\":{\"5\":1}}],[\"维护了一个codecache\",{\"1\":{\"6\":1}}],[\"jfokus\",{\"1\":{\"65\":1}}],[\"j\",{\"1\":{\"30\":2}}],[\"jdk\",{\"1\":{\"75\":2}}],[\"jdk11中删除了cms垃圾收集器\",{\"1\":{\"75\":1}}],[\"jdk13就把最大支持堆内存从4t扩大到了16t\",{\"1\":{\"72\":1}}],[\"jdk1\",{\"1\":{\"26\":1,\"39\":1}}],[\"jdk8\",{\"1\":{\"11\":1,\"40\":1}}],[\"jdk8中提供的\",{\"1\":{\"8\":1}}],[\"java的引用类型一般分为四种\",{\"1\":{\"29\":1}}],[\"java对象一般在堆上进行分配\",{\"1\":{\"22\":1}}],[\"java中的int\",{\"1\":{\"11\":1}}],[\"java\",{\"1\":{\"9\":1,\"31\":2,\"35\":1,\"38\":1,\"65\":2}}],[\"java被\",{\"1\":{\"6\":1}}],[\"jit就能针对该对象进行优化\",{\"1\":{\"10\":1}}],[\"jit\",{\"1\":{\"9\":1}}],[\"jit会运用很多经典的编译优化技术来实现对字节码指令的优化\",{\"1\":{\"8\":1}}],[\"jvm就可以安全的进行一些操作\",{\"1\":{\"77\":1}}],[\"jvm是如何判断对象被移动过呢\",{\"1\":{\"72\":1}}],[\"jvm源码里target\",{\"1\":{\"56\":1}}],[\"jvm目标是不超过2048个region\",{\"1\":{\"56\":1}}],[\"jvm仅在第一次使用设定值\",{\"1\":{\"43\":1}}],[\"jvm的垃圾收集器\",{\"0\":{\"34\":1,\"55\":1}}],[\"jvm通过逃逸分析确定该对象不会被外部访问\",{\"1\":{\"22\":1}}],[\"jvm会不停的给年轻代增加更多的region\",{\"1\":{\"56\":1}}],[\"jvm会计算老年代剩余可用空间\",{\"1\":{\"26\":1}}],[\"jvm会强制使用64位\",{\"1\":{\"21\":1}}],[\"jvm会默认去掉高位的0\",{\"1\":{\"21\":1}}],[\"jvm会在编译时将这个无用的锁消除掉\",{\"1\":{\"13\":1}}],[\"jvm默认启用了指针压缩功能\",{\"1\":{\"21\":1}}],[\"jvm默认开启\",{\"1\":{\"18\":1}}],[\"jvm使用cas方式分配内存\",{\"1\":{\"18\":1}}],[\"jvm对象创建及内存分配机制\",{\"0\":{\"16\":1}}],[\"jvm虚拟机就可以将deadcode移除来进行优化\",{\"1\":{\"9\":1}}],[\"jvm也能保证一个不错的执行效率\",{\"1\":{\"8\":1}}],[\"jvm只负责进行翻译和执行\",{\"1\":{\"8\":1}}],[\"jvm为了加快运行速度\",{\"1\":{\"6\":1}}],[\"jvm执行引擎如何执行一段java代码已经在class文件中确定了\",{\"1\":{\"6\":1}}],[\"jvm在执行时\",{\"1\":{\"5\":1}}],[\"jvm\",{\"0\":{\"82\":1},\"1\":{\"5\":4,\"9\":1,\"12\":1},\"2\":{\"1\":1,\"2\":1,\"14\":1,\"15\":1,\"32\":1,\"33\":1,\"53\":1,\"54\":1,\"79\":1,\"80\":1}}],[\"jvm内存模型\",{\"0\":{\"0\":1}}],[\"些直接面向本地机器指令编程的语言的\",{\"1\":{\"6\":1}}],[\"cr\",{\"1\":{\"65\":1}}],[\"click\",{\"1\":{\"65\":1}}],[\"cleanup\",{\"1\":{\"56\":1}}],[\"classloader\",{\"1\":{\"31\":1}}],[\"class文件中已经保留了每一行java代码对应的字节码\",{\"1\":{\"6\":1}}],[\"class\",{\"1\":{\"5\":1,\"9\":2,\"13\":1,\"27\":2,\"30\":1,\"31\":1,\"44\":5}}],[\"card\",{\"1\":{\"51\":1}}],[\"cardtable\",{\"1\":{\"51\":1}}],[\"cas\",{\"1\":{\"18\":1}}],[\"color了\",{\"1\":{\"72\":1}}],[\"color的依据是什么呢\",{\"1\":{\"72\":1}}],[\"color还是good\",{\"1\":{\"72\":1}}],[\"color\",{\"1\":{\"72\":2}}],[\"colored\",{\"1\":{\"70\":1}}],[\"collection\",{\"1\":{\"56\":1}}],[\"com\",{\"1\":{\"67\":1}}],[\"compact\",{\"1\":{\"65\":1}}],[\"compdemo\",{\"1\":{\"9\":5}}],[\"compilethreshold​来设定\",{\"1\":{\"7\":1}}],[\"concgcthreads\",{\"1\":{\"43\":1}}],[\"concurrent\",{\"1\":{\"42\":2,\"56\":1,\"69\":4}}],[\"cpu或者cpu核心\",{\"1\":{\"56\":1}}],[\"cpu\",{\"1\":{\"40\":5}}],[\"cms回收阶段是跟用户线程一起并发执行的\",{\"1\":{\"56\":1}}],[\"cms就一块老年代区域\",{\"1\":{\"50\":1}}],[\"cms用增量更新\",{\"1\":{\"50\":1}}],[\"cmsinitiatingoccupancyfraction设定的值\",{\"1\":{\"43\":1}}],[\"cmsinitiatingoccupancyfraction\",{\"1\":{\"43\":1}}],[\"cmsfullgcsbeforecompaction\",{\"1\":{\"43\":1}}],[\"cms\",{\"1\":{\"39\":1,\"40\":1,\"41\":2,\"42\":2,\"50\":1,\"56\":1}}],[\"cms收集器默认6岁\",{\"1\":{\"24\":1}}],[\"currenttimemillis\",{\"1\":{\"9\":2,\"13\":4}}],[\"c2编译器会对字节码进行更加激进的优化\",{\"1\":{\"8\":1}}],[\"c2编译器会更加激进的对字节码进行优化\",{\"1\":{\"8\":1}}],[\"c2相当于一个高级编译\",{\"1\":{\"8\":1}}],[\"c1会对字节码做简单和可靠的优化\",{\"1\":{\"8\":1}}],[\"c1相当于一个初级编译\",{\"1\":{\"8\":1}}],[\"c++开发者吐槽执⾏速度慢的根源\",{\"1\":{\"6\":1}}],[\"c++那\",{\"1\":{\"6\":1}}],[\"c\",{\"1\":{\"6\":1,\"44\":4}}],[\"和marked1配合用于辅助gc\",{\"1\":{\"70\":1}}],[\"和最终标记\",{\"1\":{\"69\":1}}],[\"和g1一样\",{\"1\":{\"69\":1}}],[\"和原始快照\",{\"1\":{\"46\":1}}],[\"和执行构造方法\",{\"1\":{\"21\":1}}],[\"和对齐填充\",{\"1\":{\"20\":1}}],[\"和foo\",{\"1\":{\"9\":1}}],[\"和\",{\"1\":{\"6\":2,\"8\":1,\"27\":1,\"37\":1,\"40\":1,\"56\":1}}],[\"称为\",{\"1\":{\"51\":1}}],[\"称为后端编译\",{\"1\":{\"5\":1}}],[\"称之为解释执行\",{\"1\":{\"6\":1}}],[\"⾄于编译的过程\",{\"1\":{\"5\":1}}],[\"就只剩44位了\",{\"1\":{\"72\":1}}],[\"就只能在运行这一行代码时才能确定\",{\"1\":{\"9\":1}}],[\"就能知道当前对象是bad\",{\"1\":{\"72\":1}}],[\"就将这个要删除的引用记录下来\",{\"1\":{\"46\":1}}],[\"就将这个新插入的引用记录下来\",{\"1\":{\"46\":1}}],[\"就将还存活的对象复制到另一块去\",{\"1\":{\"36\":1}}],[\"就减轻了垃圾回收的压力\",{\"1\":{\"22\":1}}],[\"就称之为逃逸\",{\"1\":{\"22\":1}}],[\"就称之为标量替换\",{\"1\":{\"11\":1}}],[\"就称之为线程逃逸\",{\"1\":{\"10\":1}}],[\"就无法进行内联\",{\"1\":{\"9\":1}}],[\"就是根据上一段提到的colored\",{\"1\":{\"72\":1}}],[\"就是利用上面提到的颜色指针\",{\"1\":{\"72\":1}}],[\"就是当灰色对象要删除指向白色对象的引用关系时\",{\"1\":{\"46\":1}}],[\"就是当黑色对象插入新的指向白色对象的引用关系时\",{\"1\":{\"46\":1}}],[\"就是分析对象动态作用域\",{\"1\":{\"22\":1}}],[\"就是去掉对象的mark标志位中的补充信息\",{\"1\":{\"12\":1}}],[\"就是死代码\",{\"1\":{\"9\":1}}],[\"就是记录统计方法的调用次数\",{\"1\":{\"7\":1}}],[\"就看不到方法内联了\",{\"1\":{\"9\":1}}],[\"就成为编译优化技术\",{\"1\":{\"8\":1}}],[\"就可以直接进入老年代了\",{\"1\":{\"25\":1}}],[\"就可以认为是热点代码\",{\"1\":{\"7\":1}}],[\"就可以提交到\",{\"1\":{\"5\":1}}],[\"就会进入老年代中\",{\"1\":{\"62\":1}}],[\"就会被放入humongous中\",{\"1\":{\"56\":1}}],[\"就会被晋升到老年代中\",{\"1\":{\"24\":1}}],[\"就会记录一下该方法的调用次数\",{\"1\":{\"7\":1}}],[\"就会触发即时编译\",{\"1\":{\"7\":1}}],[\"就适当降低该值\",{\"1\":{\"0\":1}}],[\"⽂件\",{\"1\":{\"5\":1}}],[\"规范的\",{\"1\":{\"5\":1}}],[\"只是简单标记\",{\"1\":{\"50\":1}}],[\"只是需要等到下一轮垃圾回收中才被清除\",{\"1\":{\"45\":1}}],[\"只是根据对象存活周期的不同将内存分为几块\",{\"1\":{\"35\":1}}],[\"只使用设定的回收阈值\",{\"1\":{\"43\":1}}],[\"只有它能与\",{\"1\":{\"41\":1}}],[\"只有一个main线程顺序执行代码\",{\"1\":{\"13\":1}}],[\"只需要付出少量对象的复制成本就可以完成每次垃圾收集\",{\"1\":{\"35\":1}}],[\"只要一个大对象超过了1m\",{\"1\":{\"56\":1}}],[\"只要筛选本收集区的卡表中变脏的元素加入gcroots里\",{\"1\":{\"51\":1}}],[\"只要有一个对象的字段存在跨代指针\",{\"1\":{\"51\":1}}],[\"只要重新与引用链上的任何的一个对象建立关联即可\",{\"1\":{\"30\":1}}],[\"只要能够编译出满⾜\",{\"1\":{\"5\":1}}],[\"只受限于本地物理内存大小\",{\"1\":{\"0\":1}}],[\"这些只能等到下次gc才能回收的对象就是浮动垃圾\",{\"1\":{\"73\":1}}],[\"这些对象很难进入当次gc\",{\"1\":{\"73\":1}}],[\"这些代替的成员变量在栈帧或寄存器上分配空间\",{\"1\":{\"22\":1}}],[\"这使得理论上只要还有一个空闲region\",{\"1\":{\"71\":1}}],[\"这使得在大部分情况下\",{\"1\":{\"8\":1}}],[\"这次访问将会被预置的内存屏障\",{\"1\":{\"69\":1}}],[\"这可以简化理解为\",{\"1\":{\"46\":1}}],[\"这是g1相对于cms的另一个大优势\",{\"1\":{\"56\":1}}],[\"这是严重bug\",{\"1\":{\"46\":1}}],[\"这是百分比\",{\"1\":{\"43\":1}}],[\"这也预示着虽然名字叫作\",{\"1\":{\"68\":1}}],[\"这也就是它的名字garbage\",{\"1\":{\"56\":1}}],[\"这也算是浮动垃圾的一部分\",{\"1\":{\"45\":1}}],[\"这也是长久以前\",{\"1\":{\"6\":1}}],[\"这部分对象在标记和回收期间可能也会变为垃圾\",{\"1\":{\"45\":1}}],[\"这部分本应该回收但是没有回收到的内存\",{\"1\":{\"45\":1}}],[\"这里就涉及到一个问题\",{\"1\":{\"64\":1}}],[\"这里设置的\",{\"1\":{\"56\":1}}],[\"这里我们引入\",{\"1\":{\"44\":1}}],[\"这里可以看出\",{\"1\":{\"6\":1}}],[\"这就要看具体的实现策略了\",{\"1\":{\"29\":1}}],[\"这样\",{\"1\":{\"70\":2}}],[\"这样合并就节省了一次遍历对象图的开销\",{\"1\":{\"69\":1}}],[\"这样整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾\",{\"1\":{\"64\":1}}],[\"这样的话在回收过程就会不断空出来新的region\",{\"1\":{\"61\":1}}],[\"这样可以让系统不至于单次停顿时间过长\",{\"1\":{\"61\":1}}],[\"这样就算gc把对象移动了\",{\"1\":{\"72\":1}}],[\"这样就能扫描到白色的对象\",{\"1\":{\"46\":1}}],[\"这样就使每次的内存回收都是对内存区间的一半进行回收\",{\"1\":{\"36\":1}}],[\"这样就不会因为没有一大块连续空间导致对象内存不够分配\",{\"1\":{\"22\":1}}],[\"这样我们就可以根据各个年代的特点选择合适的垃圾收集算法\",{\"1\":{\"35\":1}}],[\"这样该对象所占用的内存空间就可以随栈帧出栈而销毁\",{\"1\":{\"22\":1}}],[\"这样两个方法耗时是差不多的\",{\"1\":{\"13\":1}}],[\"这一步速度很快\",{\"1\":{\"56\":1}}],[\"这一步操作保证了java里对象实例不赋值默认值也可以直接使用\",{\"1\":{\"19\":1}}],[\"这一步可提前至tlab分配时进行\",{\"1\":{\"19\":1}}],[\"这时再做gc进行标记存活的对象\",{\"1\":{\"70\":1}}],[\"这时候它们暂时处于\",{\"1\":{\"30\":1}}],[\"这时要将堆中的对象挪到虚拟机栈中\",{\"1\":{\"12\":1}}],[\"这时就可以向jit提交针对该方法的热点编译请求\",{\"1\":{\"7\":1}}],[\"这三种优化措施中\",{\"1\":{\"12\":1}}],[\"这对解释执行阶段的速度也有所影响\",{\"1\":{\"8\":1}}],[\"这两个词可以看出\",{\"1\":{\"42\":1}}],[\"这两个对象之间再无任何引用\",{\"1\":{\"27\":1}}],[\"这两个编译器存在已久\",{\"1\":{\"8\":1}}],[\"这两个计数器都有一个明确的阈值\",{\"1\":{\"7\":1}}],[\"这个屏障会把读出的指针更新到对象的新地址上\",{\"1\":{\"72\":1}}],[\"这个region立即就能够被释放和重用掉\",{\"1\":{\"71\":1}}],[\"这个region就可以立即释放用于新对象的分配\",{\"1\":{\"69\":1}}],[\"这个参数的值\",{\"1\":{\"62\":1}}],[\"这个参数标识最后的混合回收阶段会执行8次\",{\"1\":{\"61\":1}}],[\"这个参数需要配合\",{\"1\":{\"9\":1}}],[\"这个过程要把重分配集中的存活对象复制到新的region上\",{\"1\":{\"69\":1}}],[\"这个过程是非常耗时的\",{\"1\":{\"60\":1}}],[\"这个过程耗时较长但是不需要停顿用户线程\",{\"1\":{\"42\":1}}],[\"这个停顿时间再怎么低也得有个限度\",{\"1\":{\"56\":1}}],[\"这个对象也有可能是浮动垃圾\",{\"1\":{\"46\":1}}],[\"这个对象是那个类\",{\"1\":{\"20\":1}}],[\"这个gcroot引用的对象之前又被扫描过\",{\"1\":{\"45\":1}}],[\"这个条件标记成以下三种颜色\",{\"1\":{\"44\":1}}],[\"这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些region\",{\"1\":{\"69\":1}}],[\"这个阶段其实也可以做到与用户程序一起并发执行\",{\"1\":{\"56\":1}}],[\"这个阶段如果有新增对象会被标记为黑色不做任何处理\",{\"1\":{\"42\":1}}],[\"这个阶段的停顿时间一般会比初始标记阶段的时间稍长\",{\"1\":{\"42\":1}}],[\"这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢\",{\"1\":{\"29\":1}}],[\"这个方法实现简单\",{\"1\":{\"27\":1}}],[\"这个规则其实是希望那些可能是长期存活的对象\",{\"1\":{\"25\":1}}],[\"这个优化措施主要针对synchronized关键字\",{\"1\":{\"13\":1}}],[\"这个也是经过逃逸分析后可以直接进行的优化措施\",{\"1\":{\"13\":1}}],[\"这个性能开销是难以接受的\",{\"1\":{\"12\":1}}],[\"这个阈值默认是10000次\",{\"1\":{\"7\":1}}],[\"这个行为称之为\",{\"1\":{\"7\":1}}],[\"这个跟早期jdk版本的\",{\"1\":{\"0\":1}}],[\"这种线程无法响应jvm的中断请求\",{\"1\":{\"78\":1}}],[\"这种情况下它的执行还会很快吗\",{\"1\":{\"64\":1}}],[\"这种使用region划分内存空间以及有优先级的区域回收方式\",{\"1\":{\"56\":1}}],[\"这种不会像cms那样回收完因为有很多内存碎片还需要整理一次\",{\"1\":{\"56\":1}}],[\"这种如果又去对老年代再去扫描效率太低了\",{\"1\":{\"51\":1}}],[\"这种浮动垃圾只能等到下一次gc再清理了\",{\"1\":{\"42\":1}}],[\"这种算法没有什么新的思想\",{\"1\":{\"35\":1}}],[\"这种叫方法逃逸\",{\"1\":{\"10\":1}}],[\"这种先编译\",{\"1\":{\"6\":1}}],[\"这种优化不会提高执行效率\",{\"1\":{\"4\":1}}],[\"这⾥就暂时略过\",{\"1\":{\"5\":1}}],[\"前端编译\",{\"0\":{\"4\":1}}],[\"05\",{\"0\":{\"55\":1}}],[\"04\",{\"0\":{\"34\":1}}],[\"03\",{\"0\":{\"16\":1}}],[\"0\",{\"1\":{\"8\":1,\"9\":2,\"13\":2,\"30\":2}}],[\"02\",{\"0\":{\"3\":1}}],[\"01\",{\"0\":{\"0\":1}}],[\"‍\",{\"1\":{\"0\":1,\"7\":1,\"13\":1,\"31\":1,\"70\":1}}],[\"medium\",{\"1\":{\"68\":1}}],[\"method\",{\"1\":{\"9\":1}}],[\"metaspacesize设置成一样的值\",{\"1\":{\"0\":1}}],[\"metaspacesiz\",{\"1\":{\"0\":1}}],[\"mixedgc不是fullgc\",{\"1\":{\"59\":1}}],[\"mixedgc\",{\"0\":{\"59\":1},\"1\":{\"61\":1}}],[\"minor\",{\"1\":{\"24\":2}}],[\"mode\",{\"1\":{\"42\":1}}],[\"major\",{\"1\":{\"66\":1}}],[\"marked0标识\",{\"1\":{\"70\":1}}],[\"marked1标识\",{\"1\":{\"70\":1}}],[\"marking\",{\"1\":{\"56\":1}}],[\"mark\",{\"1\":{\"42\":2,\"56\":1,\"69\":3}}],[\"maxgcpausemills\",{\"1\":{\"58\":2,\"62\":2,\"64\":1}}],[\"maxgcpausemillis\",{\"1\":{\"56\":1,\"61\":1}}],[\"maxgcpausemillis指定\",{\"1\":{\"56\":1}}],[\"maxtenuringthreshold\",{\"1\":{\"24\":1,\"61\":1}}],[\"maxtrivialsize=size\",{\"1\":{\"9\":1}}],[\"maxinlinesize=size\",{\"1\":{\"9\":1}}],[\"maxmetaspacesize和\",{\"1\":{\"0\":1}}],[\"maxmetaspacesize\",{\"1\":{\"0\":2}}],[\"main\",{\"1\":{\"9\":2,\"13\":1,\"30\":1,\"44\":1,\"65\":1}}],[\"1位\",{\"1\":{\"70\":4}}],[\"18位\",{\"1\":{\"70\":1}}],[\"1mb~32mb\",{\"1\":{\"61\":1}}],[\"1521\",{\"1\":{\"13\":1}}],[\"1049\",{\"1\":{\"13\":1}}],[\"1039\",{\"1\":{\"13\":1}}],[\"10\",{\"1\":{\"10\":2,\"35\":1}}],[\"100000000\",{\"1\":{\"13\":2}}],[\"10000000\",{\"1\":{\"9\":1}}],[\"1000000\",{\"1\":{\"9\":1}}],[\"100000\",{\"1\":{\"9\":1}}],[\"100\",{\"1\":{\"7\":1}}],[\"10的新生代内存\",{\"1\":{\"0\":1}}],[\"1\",{\"0\":{\"17\":1,\"23\":1,\"39\":1},\"1\":{\"0\":1,\"8\":2,\"9\":2,\"18\":1,\"29\":1,\"30\":1,\"44\":1,\"56\":2,\"75\":2}}],[\"元空间无固定初始大小\",{\"1\":{\"0\":1}}],[\"元空间最大值\",{\"1\":{\"0\":1}}],[\"元空间设置参数有两个\",{\"1\":{\"0\":1}}],[\"30\",{\"1\":{\"74\":1}}],[\"3\",{\"0\":{\"19\":1,\"25\":1,\"41\":1},\"1\":{\"0\":1,\"8\":2,\"9\":2,\"44\":1}}],[\"20\",{\"1\":{\"74\":1}}],[\"2018\",{\"1\":{\"65\":1}}],[\"22位\",{\"1\":{\"70\":1}}],[\"2的35次方=32g\",{\"1\":{\"21\":1}}],[\"2的32次方\",{\"1\":{\"21\":1}}],[\"2461\",{\"1\":{\"13\":1}}],[\"2\",{\"0\":{\"18\":1,\"24\":1,\"39\":1,\"40\":2,\"41\":1,\"42\":1},\"1\":{\"0\":1,\"8\":2,\"9\":2,\"18\":3,\"29\":1,\"30\":1,\"44\":1}}],[\"默认为不使用\",{\"1\":{\"74\":1}}],[\"默认为15岁\",{\"1\":{\"24\":1}}],[\"默认5\",{\"1\":{\"61\":1}}],[\"默认50\",{\"1\":{\"61\":1}}],[\"默认45\",{\"1\":{\"61\":1}}],[\"默认15\",{\"1\":{\"61\":1}}],[\"默认就是百分比\",{\"1\":{\"61\":1}}],[\"默认整堆5\",{\"1\":{\"61\":1}}],[\"默认200ms\",{\"1\":{\"61\":1}}],[\"默认2表示新生代占年老代的1\",{\"1\":{\"0\":1}}],[\"默认将整堆划分为2048个分区\",{\"1\":{\"61\":1}}],[\"默认8次\",{\"1\":{\"61\":1}}],[\"默认85\",{\"1\":{\"61\":1}}],[\"默认8\",{\"1\":{\"56\":1}}],[\"默认8表示一个survivor区占用1\",{\"1\":{\"0\":1}}],[\"默认年轻代占5\",{\"1\":{\"56\":1}}],[\"默认的新生代和老年代收集器\",{\"1\":{\"40\":1}}],[\"默认的收集线程数跟\",{\"1\":{\"40\":1}}],[\"默认是92\",{\"1\":{\"43\":1}}],[\"默认是0\",{\"1\":{\"43\":1}}],[\"默认是关闭的\",{\"1\":{\"9\":1}}],[\"默认是21m左右\",{\"1\":{\"0\":1}}],[\"默认值是6bytes\",{\"1\":{\"9\":1}}],[\"默认值是325bytes\",{\"1\":{\"9\":1}}],[\"默认值是35byt\",{\"1\":{\"9\":1}}],[\"默认值是1000bytes\",{\"1\":{\"9\":1}}],[\"默认开启\",{\"1\":{\"9\":1,\"21\":1,\"74\":1}}],[\"默认\",{\"1\":{\"0\":1}}],[\"默认物理内存的1\",{\"1\":{\"0\":2}}],[\"404\",{\"1\":{\"81\":1}}],[\"4g以下可以用parallel\",{\"1\":{\"75\":1}}],[\"49\",{\"1\":{\"74\":1}}],[\"4位是颜色位\",{\"1\":{\"72\":1}}],[\"42位\",{\"1\":{\"70\":1}}],[\"42\",{\"1\":{\"9\":1}}],[\"4\",{\"0\":{\"20\":1,\"26\":1,\"42\":1},\"1\":{\"0\":1,\"8\":2,\"9\":1,\"75\":1}}],[\"64\",{\"1\":{\"0\":1}}],[\"x4\",{\"1\":{\"9\":3}}],[\"x3\",{\"1\":{\"9\":3}}],[\"x2\",{\"1\":{\"9\":4}}],[\"x1+x2+x3+x4\",{\"1\":{\"9\":1}}],[\"x1+x2\",{\"1\":{\"9\":1}}],[\"x1\",{\"1\":{\"9\":4}}],[\"xx\",{\"0\":{\"56\":1},\"1\":{\"0\":9,\"7\":1,\"8\":1,\"9\":10,\"11\":1,\"13\":1,\"18\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"40\":1,\"42\":1,\"43\":10,\"56\":5,\"58\":2,\"59\":1,\"61\":12,\"62\":2,\"64\":1,\"73\":2}}],[\"xmn\",{\"1\":{\"0\":1}}],[\"xmx\",{\"1\":{\"0\":1}}],[\"xms\",{\"1\":{\"0\":1}}],[\"xss\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
