const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":246,\"nextId\":246,\"documentIds\":{\"0\":\"1\",\"1\":\"1@0\",\"2\":\"2\",\"3\":\"2#前端编译\",\"4\":\"2#后端编译\",\"5\":\"2#解释执行与编译执行\",\"6\":\"2#热点代码识别\",\"7\":\"2#客户端编译器和服务端编译器\",\"8\":\"2#方法内联-inline\",\"9\":\"2#逃逸分析-escape-analysis\",\"10\":\"2#标量替换\",\"11\":\"2#栈上分配\",\"12\":\"2#锁消除-lock-elision\",\"13\":\"2@0\",\"14\":\"3\",\"15\":\"3#_1、类加载检查\",\"16\":\"3#_2、分配内存\",\"17\":\"3#_3、初始化零值\",\"18\":\"3#_4、设置对象头\",\"19\":\"3#_5、执行-init-方法\",\"20\":\"3#栈上分配-xx-doescapeanalysis\",\"21\":\"3#_1、大对象直接进入老年代\",\"22\":\"3#_2、长期存活的对象进入老年代\",\"23\":\"3#_3、对象动态年龄判断\",\"24\":\"3#_4、老年代空间担保\",\"25\":\"3#引用计数\",\"26\":\"3#可达性分析\",\"27\":\"3#常见引用类型\",\"28\":\"3#finalize-方法最终判定对象是否存活\",\"29\":\"3#如何判断一个类是无用的类\",\"30\":\"3@0\",\"31\":\"4\",\"32\":\"4#分代收集理论\",\"33\":\"4#标记-复制算法\",\"34\":\"4#标记-清除算法\",\"35\":\"4#标记-整理算法\",\"36\":\"4#_2-1-serial-收集器-xx-useserialgc-xx-useserialoldgc\",\"37\":\"4#_2-2-parallel-scavenge-收集器-xx-useparallelgc-年轻代-xx-useparalleloldgc-老年代\",\"38\":\"4#_2-3-parnew-收集器-xx-useparnewgc\",\"39\":\"4#_2-4-cms-收集器-xx-useconcmarksweepgc-old\",\"40\":\"4#cms的相关核心参数\",\"41\":\"4#三色标记\",\"42\":\"4#多标-浮动垃圾\",\"43\":\"4#漏标-读写屏障\",\"44\":\"4#写屏障\",\"45\":\"4#写屏障实现satb\",\"46\":\"4#写屏障实现增量更新\",\"47\":\"4#读屏障\",\"48\":\"4#记忆集与卡表\",\"49\":\"4#卡表的维护\",\"50\":\"4@0\",\"51\":\"5\",\"52\":\"5#g1垃圾收集器-xx-useg1gc\",\"53\":\"5#g1垃圾收集分类\",\"54\":\"5#younggc\",\"55\":\"5#mixedgc\",\"56\":\"5#fullgc\",\"57\":\"5#g1收集器参数设置\",\"58\":\"5#g1垃圾收集器优化建议\",\"59\":\"5#什么场景适合使用g1\",\"60\":\"5#每秒几十万并发的系统如何优化jvm\",\"61\":\"5#zgc收集器-xx-usezgc\",\"62\":\"5#zgc的目标\",\"63\":\"5#不分代-暂时\",\"64\":\"5#zgc内存布局\",\"65\":\"5#zgc收集过程\",\"66\":\"5#颜色指针\",\"67\":\"5#三大优势\",\"68\":\"5#读屏障\",\"69\":\"5#zgc存在的问题\",\"70\":\"5#zgc触发时机\",\"71\":\"5#如何选择垃圾回收器\",\"72\":\"5#安全点与安全区域\",\"73\":\"5#安全点-safe-point\",\"74\":\"5#安全区域-safe-region\",\"75\":\"5@0\",\"76\":\"6\",\"77\":\"6#前置启动程序\",\"78\":\"6#jmap\",\"79\":\"6#jmap-histo\",\"80\":\"6#jmap-heap\",\"81\":\"6#导出堆内对象信息\",\"82\":\"6#jstack\",\"83\":\"6#jstack-pid\",\"84\":\"6#jstack找出占用cpu最高的线程\",\"85\":\"6#jinfo\",\"86\":\"6#jinfo-flags-pid\",\"87\":\"6#jinfo-sysprops-pid\",\"88\":\"6#jstat\",\"89\":\"6#jvm运行情况预估\",\"90\":\"6#年轻代对象增长的速率\",\"91\":\"6#young-gc的触发频率和每次耗时\",\"92\":\"6#每次young-gc后有多少对象存活和进入老年代\",\"93\":\"6#full-gc的触发频率和每次耗时\",\"94\":\"6#优化思路\",\"95\":\"6#内存泄漏的一些事\",\"96\":\"6@0\",\"97\":\"7\",\"98\":\"7#一、索引的本质\",\"99\":\"7#hash-索引\",\"100\":\"7#mysql-底层为什么不使用二叉树\",\"101\":\"7#mysql-底层为什么不使用红黑树-二叉平衡树\",\"102\":\"7#mysql-底层为什么不使用-b-tree\",\"103\":\"7#b-tree\",\"104\":\"7#b-树和-b-树的不同点\",\"105\":\"7#b-数是如何查询数据的\",\"106\":\"7#b-树叶子节点之间为何使用双向指针互相连接\",\"107\":\"7#mysql-一页的大小是-16k\",\"108\":\"7#二、索引存储\",\"109\":\"7#索引存储的位置\",\"110\":\"7#myisam-索引文件和数据文件存储\",\"111\":\"7#myisam-数据查询\",\"112\":\"7#innodb-索引文件和数据文件存储\",\"113\":\"7#myisam-和-innodb-引擎存储数据的区别\",\"114\":\"7#为什么-innodb-表必须建立主键-并且推荐使用整型的自增主键\",\"115\":\"7#为什么推荐使用自增主键\",\"116\":\"7#为什么非主键索引-二级索引-结构叶子节点存储的是主键值\",\"117\":\"7#三、联合索引-复合索引-a-b-c\",\"118\":\"7#索引最左前缀原理\",\"119\":\"7@0\",\"120\":\"8\",\"121\":\"8#数据准备\",\"122\":\"8#举一个不容易理解的综合例子\",\"123\":\"8#_1、联合索引第一个字段用范围不会走索引\",\"124\":\"8#_2、强制走索引\",\"125\":\"8#_3、覆盖索引优化\",\"126\":\"8#_4、in和or在表数据量比较大的情况会走索引-在表记录不多的情况下会选择全表扫描\",\"127\":\"8#_5、like-kk-一般情况都会走索引\",\"128\":\"8#为什么范围查找mysql没有用索引下推优化\",\"129\":\"8#mysql如何选择合适的索引\",\"130\":\"8#常见sql深入优化\",\"131\":\"8#order-by与group-by优化\",\"132\":\"8#索引设计原则\",\"133\":\"8#_1、代码先行-索引后上\",\"134\":\"8#_2、联合索引尽量覆盖查询条件\",\"135\":\"8#_3、不在小基数字段上建立索引\",\"136\":\"8#_4、长字符串我们可以采用前缀索引\",\"137\":\"8#_5、where与order-by冲突时优先where\",\"138\":\"8#_6、基于慢sql查询做优化\",\"139\":\"8#索引设计实战\",\"140\":\"8@0\",\"141\":\"9\",\"142\":\"9#分页查询-limit-start-end\",\"143\":\"9#优化\",\"144\":\"9#当主键连续且自增-并且根据主键排序时\",\"145\":\"9#主键不连续\",\"146\":\"9#根据非主键字段排序的分页\",\"147\":\"9#join关联优化\",\"148\":\"9#nested-loop-join-嵌套循环连接-nlj\",\"149\":\"9#block-nested-loop-join-基于块的嵌套循环连接-bnl\",\"150\":\"9#为什么不用嵌套循环连接-nlj-呢\",\"151\":\"9#优化方法\",\"152\":\"9#in和exists\",\"153\":\"9#count-语句\",\"154\":\"9#count-1\",\"155\":\"9#count\",\"156\":\"9#常见查询优化方法\",\"157\":\"9#查询mysql自己维护的总行数\",\"158\":\"9#show-table-status\",\"159\":\"9#将总数维护到缓存中如redis\",\"160\":\"9#维护相应数据到数据库表中\",\"161\":\"9@0\",\"162\":\"10\",\"163\":\"10#概述\",\"164\":\"10#事务及acid属性\",\"165\":\"10#并发事务带来的问题\",\"166\":\"10#数据库锁分类\",\"167\":\"10#锁分类\",\"168\":\"10#表锁\",\"169\":\"10#添加读锁的情况\",\"170\":\"10#添加写锁情况\",\"171\":\"10#行锁\",\"172\":\"10#事务的隔离级别\",\"173\":\"10#读未提交\",\"174\":\"10#读已提交\",\"175\":\"10#可重复读\",\"176\":\"10#串行化\",\"177\":\"10#间隙锁\",\"178\":\"10#临键锁-next-key-locks\",\"179\":\"10#结论\",\"180\":\"10#锁分析\",\"181\":\"10#_1、通过检查innodb-row-lock状态变量来分析系统上的行锁的争夺情况\",\"182\":\"10#_2、查看infomation-schema库中锁相关表\",\"183\":\"10#死锁\",\"184\":\"10#锁优化建议\",\"185\":\"10@0\",\"186\":\"11\",\"187\":\"11#mvcc多版本控制机制\",\"188\":\"11#undo日志版本链和read-veiw机制\",\"189\":\"11#比对方式\",\"190\":\"11#innodb引擎sql执行的bufferpool缓存机制\",\"191\":\"11#设计原因\",\"192\":\"11@0\",\"193\":\"12\",\"194\":\"12#mysql-内部结构\",\"195\":\"12#service-层\",\"196\":\"12#连接器\",\"197\":\"12#查询缓存\",\"198\":\"12#词法分析器\",\"199\":\"12#优化器\",\"200\":\"12#执行器\",\"201\":\"12#引擎层\",\"202\":\"12#innodb-底层原理与-mysql-日志机制\",\"203\":\"12#设计原因\",\"204\":\"12#redo-log-重做日志关键参数\",\"205\":\"12#redo-log-写入磁盘过程分析\",\"206\":\"12#binlog二进制归档日志\",\"207\":\"12@0\",\"208\":\"13\",\"209\":\"13#数据库表设计-范式化\",\"210\":\"13#第一范式\",\"211\":\"13#第二范式\",\"212\":\"13#第三范式\",\"213\":\"13#反范式化设计\",\"214\":\"13#总结\",\"215\":\"13#范式化设计的优缺点\",\"216\":\"13#优点\",\"217\":\"13#缺点\",\"218\":\"13#反范式化设计的优缺点\",\"219\":\"13#优点-1\",\"220\":\"13#缺点-1\",\"221\":\"13#实际工作中的反范式化\",\"222\":\"13#_1-缓存和汇总\",\"223\":\"13#_2-计数器表\",\"224\":\"13#_3-字段类型优化\",\"225\":\"13#_4-mysql索引\",\"226\":\"13#按结构分\",\"227\":\"13#按物理角度分\",\"228\":\"13#mrr\",\"229\":\"13#如何创建高性能索引\",\"230\":\"13#索引列的类型大小尽可能小\",\"231\":\"13#利用索引离散化选择和前缀索引\",\"232\":\"13#前缀索引\",\"233\":\"13#只为用于搜索、排序、分组的列创建索引\",\"234\":\"13#尽可能设计三星索引\",\"235\":\"13#主键尽量是不改变的\",\"236\":\"13@0\",\"237\":\"14\",\"238\":\"14#filesort文件排序方式\",\"239\":\"14#单路排序的详细过程\",\"240\":\"14#双路排序的详细过程\",\"241\":\"14@0\",\"242\":\"15\",\"243\":\"16\",\"244\":\"17\",\"245\":\"18\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,60],\"1\":[null,null,1],\"2\":[2],\"3\":[1,4],\"4\":[1,22],\"5\":[1,45],\"6\":[1,38],\"7\":[1,87],\"8\":[3,159],\"9\":[4,23],\"10\":[1,26],\"11\":[1,38],\"12\":[4,72],\"13\":[null,null,1],\"14\":[2,1],\"15\":[2,7],\"16\":[2,43],\"17\":[2,9],\"18\":[2,29],\"19\":[2,42],\"20\":[1,28],\"21\":[2,12],\"22\":[2,33],\"23\":[2,18],\"24\":[2,29],\"25\":[1,33],\"26\":[1,12],\"27\":[1,39],\"28\":[1,75],\"29\":[1,18],\"30\":[null,null,1],\"31\":[4,1],\"32\":[1,27],\"33\":[2,10],\"34\":[2,20],\"35\":[2,24],\"36\":[2,45],\"37\":[1,51],\"38\":[2,24],\"39\":[2,84],\"40\":[1,42],\"41\":[1,62],\"42\":[2,21],\"43\":[2,34],\"44\":[1,30],\"45\":[1,23],\"46\":[1,7],\"47\":[1,71],\"48\":[1,50],\"49\":[1,6],\"50\":[null,null,2],\"51\":[4],\"52\":[4,208],\"53\":[1],\"54\":[1,13],\"55\":[1,12],\"56\":[1,7],\"57\":[1,68],\"58\":[1,24],\"59\":[1,8],\"60\":[1,33],\"61\":[2,58],\"62\":[1,24],\"63\":[3,16],\"64\":[1,31],\"65\":[1,65],\"66\":[1,50],\"67\":[1,13],\"68\":[1,73],\"69\":[1,93],\"70\":[1,32],\"71\":[1,26],\"72\":[1],\"73\":[4,19],\"74\":[4,11],\"75\":[null,null,2],\"76\":[2],\"77\":[1,4],\"78\":[1,3],\"79\":[2,28],\"80\":[2,8],\"81\":[1,30],\"82\":[1,2],\"83\":[2,47],\"84\":[1,54],\"85\":[1,1],\"86\":[3,2],\"87\":[3,2],\"88\":[1,47],\"89\":[1,14],\"90\":[1,18],\"91\":[1,10],\"92\":[1,19],\"93\":[1,8],\"94\":[1,9],\"95\":[1,17],\"96\":[null,null,1],\"97\":[2],\"98\":[2,48],\"99\":[2,34],\"100\":[2,31],\"101\":[4,52],\"102\":[4,15],\"103\":[1,20],\"104\":[4,18],\"105\":[2,37],\"106\":[2,27],\"107\":[3,129],\"108\":[2],\"109\":[1,17],\"110\":[2,8],\"111\":[2,22],\"112\":[2,9],\"113\":[4,28],\"114\":[5,26],\"115\":[1,32],\"116\":[3,41],\"117\":[7,7],\"118\":[1,32],\"119\":[null,null,1],\"120\":[2],\"121\":[1,81],\"122\":[1],\"123\":[2,21],\"124\":[2,35],\"125\":[2,15],\"126\":[3,24],\"127\":[4,58],\"128\":[2,11],\"129\":[1,219],\"130\":[1],\"131\":[3,88],\"132\":[1],\"133\":[3,6],\"134\":[2,9],\"135\":[2,15],\"136\":[2,38],\"137\":[3,13],\"138\":[2,3],\"139\":[1,108],\"140\":[null,null,1],\"141\":[2],\"142\":[4,12],\"143\":[1,3],\"144\":[2,16],\"145\":[1,32],\"146\":[1,36],\"147\":[1],\"148\":[6,44],\"149\":[7,39],\"150\":[1,40],\"151\":[1,48],\"152\":[1,31],\"153\":[2,29],\"154\":[1,13],\"155\":[1,13],\"156\":[1],\"157\":[1,7],\"158\":[1,8],\"159\":[1,4],\"160\":[1,3],\"161\":[null,null,1],\"162\":[2],\"163\":[1,9],\"164\":[1,24],\"165\":[1,26],\"166\":[1,15],\"167\":[1,33],\"168\":[1,11],\"169\":[1,8],\"170\":[1,19],\"171\":[1,8],\"172\":[1,27],\"173\":[1,32],\"174\":[1,24],\"175\":[1,27],\"176\":[1,17],\"177\":[1,31],\"178\":[5,19],\"179\":[1,11],\"180\":[1],\"181\":[4,23],\"182\":[3,36],\"183\":[1,13],\"184\":[1,11],\"185\":[null,null,1],\"186\":[2],\"187\":[1,13],\"188\":[2,30],\"189\":[1,52],\"190\":[1,23],\"191\":[1,15],\"192\":[null,null,1],\"193\":[2],\"194\":[2,17],\"195\":[2,15],\"196\":[1,53],\"197\":[1,84],\"198\":[1,52],\"199\":[1,15],\"200\":[1,22],\"201\":[1,17],\"202\":[4,44],\"203\":[1,18],\"204\":[3,55],\"205\":[3,94],\"206\":[1,63],\"207\":[null,null,1],\"208\":[2],\"209\":[2,46],\"210\":[1,12],\"211\":[1,18],\"212\":[1,18],\"213\":[1,7],\"214\":[1],\"215\":[1],\"216\":[1,13],\"217\":[1,6],\"218\":[1],\"219\":[1,4],\"220\":[1,4],\"221\":[1],\"222\":[2,22],\"223\":[2,40],\"224\":[2,4],\"225\":[2],\"226\":[1,6],\"227\":[1,2],\"228\":[1,22],\"229\":[1],\"230\":[1,14],\"231\":[1,15],\"232\":[1,53],\"233\":[1,25],\"234\":[1,9],\"235\":[1,6],\"236\":[null,null,1],\"237\":[2],\"238\":[1,35],\"239\":[1,23],\"240\":[1,69],\"241\":[null,null,1],\"242\":[1,3],\"243\":[1],\"244\":[1],\"245\":[1]},\"averageFieldLength\":[1.6773899324724697,31.350843373854698,0.6196383543448123],\"storedFields\":{\"0\":{\"h\":\"01-JVM内存模型\",\"t\":[\"​​\",\"​​\",\"-Xss：每个线程的栈大小\",\"-Xms：设置堆的初始可用大小，默认物理内存的1/64\",\"-Xmx：设置堆的最大可用大小，默认物理内存的1/4\",\"-Xmn：新生代大小\",\"-XX:NewRatio：默认2表示新生代占年老代的1/2，占整个堆内存的1/3\",\"-XX:SurvivorRatio：默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存\",\"元空间设置参数有两个：\",\"-XX:MaxMetaspaceSize ：元空间最大值，默认-1，不限制，只受限于本地物理内存大小\",\"-XX:MetaspaceSiz：指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的-XX:PermSize参数意思不一样，-XX:PermSize代表永久代的初始容量。\",\"由于调整元空间大小需要Fullgc，很耗费开销。在应用启动过程中发生大量Fullgc，通常是元空间发生了大小调整，基于这种情况，一般建议将JVM参数-XX:MaxMetaspaceSize和-XX:MetaspaceSize设置成一样的值，并且设置的比初始值要大，对于8G内存的系统来说，一般可以设置成256M。\",\"‍\"]},\"1\":{\"c\":[\"JVM\"]},\"2\":{\"h\":\"02-深入理解JVM执行引擎\"},\"3\":{\"h\":\"前端编译\",\"t\":[\"通常认为将java文件编译成class的字节码文件乘坐前端编译。而且在class编译时会对原文件进行一定优化，这种优化不会提高执行效率。\"]},\"4\":{\"h\":\"后端编译\",\"t\":[\"jvm在执行时，将class的字节码文件解释编译成机器码供计算机执行，称为后端编译\",\"​​\",\"其中前端编译是在 JVM 虚拟机之外执⾏，所以与 JVM 虚拟机没有太⼤的关系。任何编程语言，只要能够编译出满⾜ JVM 规范的 Class ⽂件，就可以提交到 JVM 虚拟机执⾏。⾄于编译的过程，如果你不是想要专⻔去研究语⾔，那么就没有必要太过深⼊的去了解了。这⾥就暂时略过。我们更关注JVM在后端编译过程中如何提升执⾏的效率。\"]},\"5\":{\"h\":\"解释执行与编译执行\",\"t\":[\"class文件中已经保留了每一行java代码对应的字节码，也就是说，jvm执行引擎如何执行一段java代码已经在class文件中确定了，\",\"​​\",\"那么jvm如何执行class的字节码文件呢，最简单的做法就是一个指令就翻译一次成为机器码进行之心，称之为解释执行 但是这种方式需要在上层语言和机器码之间经过中间⼀层JVM字节码的转换，显然执⾏效率是⽐不上C 和 C++那 些直接面向本地机器指令编程的语言的，这也是长久以前， Java被 C 和 C++开发者吐槽执⾏速度慢的根源\",\"JVM为了加快运行速度，维护了一个CodeCache，将那些字节码指令，提前编译出来放到缓存当中。当再次执行时，会直接从缓存中获取机器码直接执行，这种先编译，后执行的方式称为编译执行\",\"但是JVM也不清楚程序员会写出什么样的代码，所以没有办法提前维护出一个完整的字节码缓存，故而退而求其次，将那些运行频率高的热点代码进行提前编译，放到缓存当中\",\"使用java -version就可以看到当前使用的是那种模式\",\"​​\",\"这里可以看出，HotSpot虚拟机并没有直接选择执行效率最高的编译执行模式，而是默认采用了混合模式，兼顾效率和运行成本。因为编译执行需要识别热点代码，需要进行机器编译，需要额外的CodeCache存储编译的代码，另外，在编译执行识别热点代码的过程中，还需要解释执行来帮助提供一些信息支持，因此在HotSpot中，会默认使用混合模式，而不是单纯的使用其中一种模式。\"]},\"6\":{\"h\":\"热点代码识别\",\"t\":[\"使用JIT实时编译的前提是需要识别出热点代码，要知道某段代码是否是热点代码，是否需要即时编译，这个行为称之为“热点探测”。在HotSpot中使方法调用计数器和回边计数器来实现，在JVM运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器的计数一旦溢出阈值，就会触发即时编译\",\"方法调用计数器： 就是记录统计方法的调用次数，每当某个方法被调用一次时，就会记录一下该方法的调用次数，当这个方法调用次数非常多，超过了设定的某一个阈值，就可以认为是热点代码。这时就可以向JIT提交针对该方法的热点编译请求。这个阈值默认是10000次，可以通过-XX:CompileThreshold​来设定\",\"‍\",\"回边计数器： 作用是统计一个方法中循环体代码执行的次数，在字节码中遇到的向后跳转的指令称之为回边，建立回边计数器就是为了发现一个方法体内被频繁调用的循环。回边计数器在默认情况下的阈值是1070\",\"阈值计算公式\",\"阈值计算公式：回边计数器阈值=方法调用计数器阈值×(比率-解释器监控比率)/100 其中比率的值默认为140，解释器监控比率为33，如果都取默认值，那么server模式下的虚拟机回边计数器的阈值就为10700。\"]},\"7\":{\"h\":\"客户端编译器和服务端编译器\",\"t\":[\"当识别出热点代码后，在编译时不可避免的需要进行编译优化，在HotSpot虚拟机中，热点代码在被JIT即时编译的过程中，JIT会运用很多经典的编译优化技术来实现对字节码指令的优化，让编译出来的机器码运行效率更高。\",\"HotSpot虚拟机内置两个即时编译器，这两个编译器存在已久，分别被称为“客户端编译器”和“服务端编译器”，简称C1编译器和C2编译器。\",\"C1相当于一个初级编译。在编译过程中，C1会对字节码做简单和可靠的优化，耗时短以达到更快编译的速度。启动快，占用内存小，但翻译出来的机器码优化程度不高，比较适合一些小巧的桌面应用，因此也被称为客户端编译器。\",\"C2相当于一个高级编译。在编译过程中，C2编译器会更加激进的对字节码进行优化，优化后的机器码执行效率更高。但也相应的，占用资源更多，包括启动速度较慢、内存占用多、进行优化的耗时也更长等。比较适合资源相对充裕的服务器，因此也被称为服务端编译器。\",\"但实际上两个编译器不是相互取代而是相互协作的关系。由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot虚拟机在编译子系统中加入了分层编译的功能，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次。\",\"等级\",\"描述\",\"性能\",\"0\",\"纯解释执行，并且解释器不开启性能监控\",\"1\",\"1\",\"使用C1来将字节码编译为本地机器码，进行简单的优化，不开启性能监控\",\"4\",\"2\",\"仍然使用C1编译器来执行，仅开启方法计数器和回边计数器\",\"3\",\"3\",\"仍使用C1编译器来执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部信息\",\"2\",\"4\",\"使用C2编译器来执行，相比于C1编译器，C2编译器会对字节码进行更加激进的优化，同时启动会更慢、耗时更长\",\"5\",\"JDK8中提供的-XX:TieredStopAtLevel=1可以指定使用那一层编译器。\",\"之前说过，在解释时，JVM只负责进行翻译和执行，而进行JIT时，会对代码进行一些优化，这使得在大部分情况下，即使程序员写的代码不够优化，JVM也能保证一个不错的执行效率，就成为编译优化技术。\",\"参数信息\",\"具体的优化策略可参见OpenJDK的WIKI：PerformanceTacticIndex - PerformanceTacticIndex - OpenJDK Wiki\"]},\"8\":{\"h\":\"方法内联(InLine)\",\"t\":[\"方法内联就是将目标方法的执行代码复制到调用该方法的地方，从而避免真实的调用，进一步减少频繁创建栈帧的性能开销。\",\"​​\",\"比如如下代码\",\"public class CompDemo { private int add1(int x1,int x2,int x3,int x4){ return add2(x1,x2)+ add2(x3,x4); } private int add2(int x1, int x2){ return x1+x2; } //内联优化 private int add(int x1,int x2,int x3,int x4){ return x1+x2+x3+x4; } public static void main(String[] args) { CompDemo compDemo = new CompDemo(); //超过方法调用计数器的阈值 100000 次，才会进入 JIT 实时编译，进行内联优化。 for (int i = 0; i < 1000000; i++) { compDemo.add1(1,2,3,4); } } } \",\"加入 JVM 参数：-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining 后可以看到以下的执行日志\",\"​​\",\"当然，发生方法内联的前提是要让这个方法循环足够的次数，成为热点代码。比如，如果将循环次数减少，就看不到方法内联了。\",\"方法内联的优化本质就是把目标方法的代码原封不动的“复制”到发起调用的方法之中，避免发生真实的方法调用。但是，实际上，Java 虚拟机中的内联过程却远没有想象中那么容易。而且，方法内联往往还是很多后续优化手段的基础。\",\"public class InlineDemo { public static void foo(Object obj){ if(obj !=null){ System.out.println(\\\"do something\\\"); } } //方法内联之后会继续进行无用代码消除 public static void testInline(){ Object obj= null; foo(obj); } public static void main(String[] args) { long l = System.currentTimeMillis(); for (int i = 0; i < 10000000; i++) { testInline(); } System.out.println(\\\">>>>>>>>\\\"+(System.currentTimeMillis()-l)); } } \",\"单独来看testInline()和foo(obj)是两个单独的方法但是当出现方法内联，将foo(obj)的代码复制到test Inline()中后会发现，if条件永远为false，就是死代码，接下来，JVM虚拟机就可以将DeadCode移除来进行优化\",\"在JDK8中，提供多个跟InLine内联相关参数，可以进行干预内联行为\",\"-XX:+Inline 启用方法内联。默认开启。\",\"-XX:InlineSmallCode=size 用来判断是否需要对方法进行内联优化。如果一个方法编译后的字节码大小大于这个值，就无法进行内联。默认值是1000bytes。\",\"-XX:MaxInlineSize=size 设定内联方法的最大字节数。如果一个方法编译后的字节码大于这个值，则无法进行内联。默认值是35byt\",\"-XX:FreqInlineSize=size 设定热点方法进行内联的最大字节数。如果一个热点方法编译后的字节码大于这个值，则无法进行内联。默认值是325bytes。\",\"-XX:MaxTrivialSize=size 设定要进行内联的琐碎方法的最大字节数(Trivial Method：通常指那些只包含一两行语句，并且逻辑非常简单的方法。比如像这样的方法，默认值是6bytes。\",\"public int getTrivialValue() { return 42; } \",\"-XX:+PrintInlining 打印内联决策，通过这个指令可以看到哪些方法进行了内联。默认是关闭的。另外，这个参数需要配合-XX:+UnlockDiagnosticVMOptions 参数使用。\",\"从这几个相关参数可以看到，我们可以通过以下一些方法提高内联发生的概率。\",\"1 、在编程中，尽量多写小方法，避免写大方法。方法太大不光会导致方法无法内联，另外，成为热点方法后，还会占用更多的CodeCache。\",\"2 、在内存不紧张的情况下，可以通过调整JVM参数，减少热点阈值或增加方法体阈值，让更多的方法可以进行内联。\",\"3 、看情况使用final, private,static关键字修饰方法。方法如果需要继承(也就是需要使用invokevirtual指令调用)，那么具体调用的方法，就只能在运行这一行代码时才能确定，编译器很难在编译时得出绝对正确的结论，也就加大了编译执行的难度。\"]},\"9\":{\"h\":\"逃逸分析(Escape Analysis)\",\"t\":[\"对象在方法中创建后，如果被方法外部所引用或者作为参数传递给其他方法，这种叫方法逃逸。如果被其他线程访问，譬如作为其他线程可访问对象的属性被引用，就称之为线程逃逸。\",\"private void test1(){ T t = new T(); t.setAge(10); } private void test2(){ T t = new T(); t.setAge(10); saveT(t); } \",\"如上方法中，test1方法内的t对象就没有被方法外部引用，因此他不会逃逸，而test2方法中的t就逃逸到其他方法了\",\"如果能保证一个方法不会逃逸出方法或线程，JIT就能针对该对象进行优化\"]},\"10\":{\"h\":\"标量替换\",\"t\":[\"如果一个对象的属性无法再分解为更小的数据来表示了(java中的int、long、reference类型等)，都不能分解，那么这些变量就可以称为标量。如果把一个java对象拆散，根据程序访问情况，去实际访问拆散后的成员变量，就称之为标量替换。\",\"假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。JDK8 中默认开启了标量替换，可以通过添加参数 -XX:-EliminateAllocations​ 主动关闭标量替换。\"]},\"11\":{\"h\":\"栈上分配\",\"t\":[\"正常情况下，JVM 中所有对象都应该创建在堆上，并由 GC 线程进行回收。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。\",\"这三种优化措施中，逃逸分析是基础。因为虚拟机栈是对应一个线程的，而堆内存是对应整个Java进程的。如果发生了线程逃逸，那么堆中的同一个对象，可能隶属于多个线程，这时要将堆中的对象挪到虚拟机栈中，那就必须扫描所有的虚拟机栈，检查这个虚拟机栈对应的线程中是否引用了这个对象。这个性能开销是难以接受的。\",\"而栈是一个非常小的内存结构，他也不可能像堆中那么豪横的使用内存空间，所以，也必须要对对象进行最大程度的瘦身，才能放到栈中。而瘦身的方式，就是去掉对象的mark标志位中的补充信息，拆分成最精简的标量。所以，要开启栈上分配，标量替换也是不可或缺的。\"]},\"12\":{\"h\":\"锁消除(lock elision)\",\"t\":[\"这个也是经过逃逸分析后可以直接进行的优化措施。\",\"这个优化措施主要针对synchronized关键字，当JVM检测到一个加锁的代码不会出现锁竞争时，会对这个对象的锁进行锁消除\",\"场景举例\",\"多线程并发资源竞争是一个很复杂的场景，所以通常想要检查锁是否存在多线程竞争比较困难。 但有一种情况比较简单，如果一个方法没有发生逃逸，那么他内部的锁就不会存在竞争。\",\"public class LockElisionDemo { public static String BufferString(String s1,String s2){ StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString(); } public static String BuilderString(String s1, String s2){ StringBuilder sb = new StringBuilder(); sb.append(s1); sb.append(s2); return sb.toString(); } public static void main(String[] args) { long startTime = System.currentTimeMillis(); for (int i = 0; i < 100000000; i++) { BufferString(\\\"aaaaa\\\",\\\"bbbbbb\\\"); } System.out.println(\\\"StringBuffer耗时：\\\"+(System.currentTimeMillis()-startTime)); long startTime2 = System.currentTimeMillis(); for (int i = 0; i < 100000000; i++) { BuilderString(\\\"aaaaa\\\",\\\"bbbbbb\\\"); } System.out.println(\\\"StringBuilder耗时：\\\"+(System.currentTimeMillis()-startTime2)); } } \",\"以上代码分别测试了StringBuffer和StringBuilder的字符串构建方法。两者最大的区别就是StringBuildr是线程不安全的，而StringBuffer是线程安全的，在它的append和toString方法都加了sychronized同步锁，而StringBuilder则没加。\",\"当前代码中，只有一个main线程顺序执行代码，不存在线程竞争，所以这个sychronized没有起作用，因此，在触发了JIT时，JVM会在编译时将这个无用的锁消除掉，这样两个方法耗时是差不多的。\",\"StringBuffer耗时：1521 StringBuilder耗时：1039 \",\"当使用JVM参数 -XX:-EliminateLocks​ 主动关闭锁清除后，执行时间就有比较大的差距\",\"StringBuffer耗时：2461 StringBuilder耗时：1049 \",\"‍\"]},\"13\":{\"c\":[\"JVM\"]},\"14\":{\"h\":\"03-JVM对象创建及内存分配机制\",\"t\":[\"​​\"]},\"15\":{\"h\":\"1、类加载检查\",\"t\":[\"虚拟机执行new方法指令时，先去检查这个指令的参数是否能够在类的常量池中定位到一个类的符号引用，并检查这个类的符号引用所指向的类是否已加载、解析和初始化过程。如果没有，则执行类加载过程。\"]},\"16\":{\"h\":\"2、分配内存\",\"t\":[\"对象加载完成过后，虚拟机会对新生对象分配内存操作；对象所需的内存大小，在加载完成便可以确定，为对象分配空间，即JVM将java堆内一部分区域划分给这个对象使用。\",\"2.1 如何划分：\",\"指针碰撞： 如果java内存绝对规整，所有使用过的内存都在一边，则可以使用指针碰撞方法，即左边都是内存，中间是指针作为内存临界标识，所分配内存仅仅是把指针向空闲一边移动所需大小的相等的距离。\",\"空闲列表： 当java堆内存并不是规整的，即一部分空闲的和已使用的相互交错，虚拟机会维护一个列表，记录那些内存块可用，在分配时查找一块空间足够的可用内存，分配给这个对象。\",\"2.2 并发分配时解决办法：\",\"CAS： 虚拟机采用CAS+重新分配方式保证更新时的原子性来保证并发时的内存分配\",\"本地线程分配缓冲(Thread Local Allcation Buffer,TLAB): 在堆内为每个线程划分出一块单独区域，根据线程不同，向该线程的单独区域内进行内存分配。使用-XX:-/+UseTLAB参数来关闭和开启本地线程分配缓冲(JVM默认开启)，-XX:TLABSize来指定缓冲区大小。当无法进行本地线程分配缓冲时，JVM使用CAS方式分配内存。​​\",\"​​\"]},\"17\":{\"h\":\"3、初始化零值\",\"t\":[\"内存分配完成后，虚拟机需要将分配的空间都初始化为零值(对象头除外)，如int的0值等， 如果使用TLAB，这一步可提前至TLAB分配时进行，这一步操作保证了java里对象实例不赋值默认值也可以直接使用，程序可以访问到这些对象默认的零值。\"]},\"18\":{\"h\":\"4、设置对象头\",\"t\":[\"初始化零值之后，虚拟机需要对对象设置对象头，主要保存对象类的路径(这个对象是那个类)，如何才能找到类的元信息，对象的哈希码，对象GC分代年龄信息等。 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\",\"​​\",\"​​\"]},\"19\":{\"h\":\"5、\",\"t\":[\"执行init方法，即对象按照程序员意愿进行初始化。即为属性赋值，和执行构造方法。\",\"-XX:-/+ UseCompressedOops(默认开启)\",\"在64位系统中，如实际是32位的地址，但使用64位进行存储，相比较32位存储，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动，占用较大带宽，且GC压力会比较大。\",\"为了减少在64位平台下的内存消耗，jvm默认启用了指针压缩功能。\",\"在JVM中32位地址可以支持4G内存(2的32次方)，当内存大于4G时，可以通过对对象指针存入堆内存时压缩编码、取出到cpu寄存器后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方=32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)。\",\"当堆内存小于4G时，不需要手动启用指针压缩，JVM会默认去掉高位的0，使用低位的32位地址\",\"当堆内存大于32G时，指针压缩会失效，JVM会强制使用64位(即8字节)来对java对象寻址。\",\"填充对齐： 对于大部分处理器，对象以8字节整数倍来对齐填充都是最高效的存取方式。\",\"​​\"]},\"20\":{\"h\":\"\",\"t\":[\"java对象一般在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。\",\"逃逸分析(-XX:-/+EliminateAllocations)： 就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，就称之为逃逸，逃逸的对象无法进行栈上分配。\",\"由于一个线程的栈的大小通常不会太大，虚拟机不会将一个对象完整的分配到栈上，而是使用标量替换的方法进，将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。\",\"打印GC参数： -XX:+PrintGCDetails\"]},\"21\":{\"h\":\"1、大对象直接进入老年代\",\"t\":[\"当对象需要大量且连续的空间时，如果新生代的eden区域无法存放，会触发Minor GC，此时大对象在S0和S1区域也无法存储，会直接进入老年代。可通过 -XX:PretenureSizeThreshold参数设置大对象阈值(单位是字节)，此参数在Serial和ParNew垃圾回收器下起作用。\"]},\"22\":{\"h\":\"2、长期存活的对象进入老年代\",\"t\":[\"虚拟机采用分代的算法进行对象管理和垃圾收集，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\"]},\"23\":{\"h\":\"3、对象动态年龄判断\",\"t\":[\"当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在Minor GC之后触发的。\"]},\"24\":{\"h\":\"4、老年代空间担保\",\"t\":[\"年轻代每次Minor GC时，JVM会计算老年代剩余可用空间，如果该空间小于年轻代所有剩余对象之和(包括垃圾对象)\",\"检查“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置\",\"如果设置了，则会对老年代剩余可用空间大小和之前每一次Minor GC后进入老年代对象的平均大小进行比较\",\"如果是小于或参数未设置，则会触发Full GC，对堆内存进行回收，如果回收完还没有足够的空间，则报OOM\",\"如果比对结果为大于，但Minor GC之后需要存放到老年代的对象大小仍然超过了老年代剩余可用空间大小，也会触发Full GC，对堆内存进行回收，如果回收完还没有足够的空间，则报OOM\",\"​​\",\"堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。\"]},\"25\":{\"h\":\"引用计数\",\"t\":[\"可以给对象添加一个引用计数，如果该对象被引用，则计数加1，如果没有被引用，则计数减1，任何计数为0的对象就是可回收对象。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。\",\"class A{ public B b; } class B{ public A a; } public void test(){ A a = new A(); B a = new B(); a.b = b; b.a = a; } \"]},\"26\":{\"h\":\"可达性分析\",\"t\":[\"将 “GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象， 其余未标记的对象都是垃圾对象\",\"GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等\",\"​​\"]},\"27\":{\"h\":\"\",\"t\":[\"java的引用类型一般分为四种：强引用、软引用、弱引用、虚引用\",\"强引用： 普通的变量引用\",\"​public static User user = new User();​\",\"软引用： 将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。\",\"​public static SoftReference<User> user = new SoftReference<User>(new User()); ​\",\"软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。\",\"​（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建\",\"（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出\",\"弱引用： 将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用\",\"​public static WeakReference<User> user = new WeakReference<User>(new User()); ​\",\"虚引用： 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用\"]},\"28\":{\"h\":\"\",\"t\":[\"即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。\",\"标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。\",\"1. 第一次标记并进行一次筛选。 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize方法，对象将直接被回收。\",\"2. 第二次标记 如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。\",\"注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。\",\"public class OOMTest { public static void main(String[] args) { List<Object> list = new ArrayList<>(); int i = 0; int j = 0; while (true) { list.add(new User(i++, UUID.randomUUID().toString())); new User(j--, UUID.randomUUID().toString()); } } } //User类需要重写finalize方法 @Override protected void finalize() throws Throwable { OOMTest.list.add(this); System.out.println(\\\"关闭资源，userid=\\\" + id + \\\"即将被回收\\\"); } \"]},\"29\":{\"h\":\"\",\"t\":[\"方法区主要回收的是无用的类，那么如何判断一个类是无用的类呢？ 类需要同时满足下面3个条件才能算是 “无用的类” ：\",\"该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\",\"加载该类的 ClassLoader 已经被回收。\",\"该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"‍\"]},\"30\":{\"c\":[\"JVM\"]},\"31\":{\"h\":\"04-JVM的垃圾收集器（上）\",\"t\":[\"​​\"]},\"32\":{\"h\":\"分代收集理论\",\"t\":[\"当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\",\"比如在新生代中，每次收集都会有大量对象(近 99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢 10 倍以上。\"]},\"33\":{\"h\":\"标记-复制算法\",\"t\":[\"为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\",\"​​\"]},\"34\":{\"h\":\"标记-清除算法\",\"t\":[\"算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：\",\"效率问题 (如果需要标记的对象太多，效率不高)\",\"空间问题（标记清除后会产生大量不连续的碎片）\",\"​​\"]},\"35\":{\"h\":\"标记-整理算法\",\"t\":[\"根据老年代的特点，特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\",\"​​\",\"如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\",\"​​\",\"虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 Java 虚拟机就不会实现那么多不同的垃圾收集器了。\"]},\"36\":{\"h\":\"2.1\",\"t\":[\"Serial（串行） 收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ \\\"Stop The World\\\" ），直到它收集结束。\",\"新生代采用复制算法​ ，老年代采用标记-整理​算法。\",\"​​\",\"虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\",\"但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。\",\"Serial Old 收集器是 Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\"]},\"37\":{\"h\":\"2.2\",\"t\":[\"Parallel 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器类似。默认的收集线程数跟 cpu 核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改 。\",\"Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\",\"新生代采用复制算法​ ，老年代采用标记-整理​算法。\",\"​​\",\"Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器(JDK8 默认的新生代和老年代收集器)。\"]},\"38\":{\"h\":\"2.3\",\"t\":[\"ParNew 收集器其实跟 Parallel 收集器很类似，区别主要在于它可以和 CMS 收集器配合使用。​\",\"新生代采用复制算法​ ，老年代采用标记-整理​算法。\",\"​​\",\"它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\"]},\"39\":{\"h\":\"2.4\",\"t\":[\"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\",\"从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 **“**​标记-清除​ ”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\",\"初始标记： 暂停所有的其他线程(STW)，并记录下 gc roots 直接能引用的对象，速度很快。\",\"并发标记： 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。\",\"重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。\",\"并发清理： 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。​\",\"并发重置： 重置本次GC过程中的标记数据。\",\"​​\",\"从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面几个明显的缺点：\",\"对CPU资源敏感（会和服务抢资源）；\",\"无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；\",\"它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理\",\"执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是\\\"concurrent mode failure\\\"，此时会进入stop the world，用serial old垃圾收集器来回收\"]},\"40\":{\"h\":\"\",\"t\":[\"-XX:+UseConcMarkSweepGC：启用cms\",\"-XX:ConcGCThreads：并发的GC线程数\",\"-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）\",\"-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次\",\"-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）\",\"-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整\",\"-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，降低CMS GC标记阶段(也会对年轻代一起做标记，如果在minor gc就干掉了很多对垃圾对象，标记阶段就会减少一些标记时间)时的开销，一般CMS的GC耗时 80%都在标记阶段\",\"-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW\",\"-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;\"]},\"41\":{\"h\":\"三色标记\",\"t\":[\"在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。\",\"这里我们引入“三色标记”来给大家解释下，把gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：\",\"黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。\",\"灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。\",\"白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。\",\"​​\",\"/** * 垃圾收集算法细节之三色标记 * 为了简化例子，代码写法可能不规范，请忽略 */ public class ThreeColorRemark { public static void main(String[] args) { A a = new A(); //开始做并发标记 D d = a.b.d; // 1.读 a.b.d = null; // 2.写 a.d = d; // 3.写 } } class A { B b = new B(); D d = null; } class B { C c = new C(); D d = new D(); } class C { } class D { } \"]},\"42\":{\"h\":\"多标-浮动垃圾\",\"t\":[\"在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。 另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象在标记和回收期间可能也会变为垃圾，这也算是浮动垃圾的一部分。\"]},\"43\":{\"h\":\"漏标-读写屏障\",\"t\":[\"漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案：增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。\",\"增量更新： 就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。\",\"原始快照： 就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)\",\"以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。\"]},\"44\":{\"h\":\"写屏障\",\"t\":[\"给某个对象的成员变量赋值时，其底层代码大概长这样：\",\"/** * @param field 某对象的成员变量，如 a.b.d * @param new_value 新值，如 null */ void oop_field_store(oop* field, oop new_value) { *field = new_value; // 赋值操作 } \",\"所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）:\",\"void oop_field_store(oop* field, oop new_value) { pre_write_barrier(field); // 写屏障-写前操作 *field = new_value; post_write_barrier(field, value); // 写屏障-写后操作 } \"]},\"45\":{\"h\":\"\",\"t\":[\"当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B原来成员变量的引用对象D记录下来：\",\"void pre_write_barrier(oop* field) { oop old_value = *field; // 获取旧值 remark_set.add(old_value); // 记录原来的引用对象 } \"]},\"46\":{\"h\":\"\",\"t\":[\"当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A新的成员变量引用对象D记录下来\"]},\"47\":{\"h\":\"读屏障\",\"t\":[\"oop oop_field_load(oop* field) { pre_load_barrier(field); // 读屏障-读取前操作 return *field; } \",\"读屏障是直接针对第一步：D d = a.b.d，当读取成员变量时，一律记录下来：\",\"void pre_load_barrier(oop* field) { oop old_value = *field; remark_set.add(old_value); // 记录读取到的对象 } \",\"现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。\",\"对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下 ：\",\"CMS：写屏障 + 增量更新\",\"G1，Shenandoah：写屏障 + SATB\",\"ZGC：读屏障\",\"工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。\",\"为什么G1用SATB？CMS用增量更新？\",\"我的理解： SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。\"]},\"48\":{\"h\":\"记忆集与卡表\",\"t\":[\"在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象(老年代的对象引用着新生代的对象)，这种如果又去对老年代再去扫描效率太低了。\",\"为此，在新生代可以引入记录集（Remember Set）的数据结构（记录从非收集区[老年代] 到收集区[新生代] 的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。\",\"垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。\",\"hotspot使用一种叫做“卡表”(Cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。\",\"卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。\",\"hotSpot使用的卡页是2^9大小，即512字节 ​\",\"一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.\",\"GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。\"]},\"49\":{\"h\":\"\",\"t\":[\"卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。\",\"Hotspot使用写屏障维护卡表状态。\"]},\"50\":{\"c\":[\"JVM\",\"垃圾收集器\"]},\"51\":{\"h\":\"05-JVM的垃圾收集器（下）\"},\"52\":{\"h\":\"G1垃圾收集器(-XX:+UseG1GC)\",\"t\":[\"G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.\",\"​​\",\"​​\",\"G1将Java堆划分为多个大小相等的独立区域（Region），JVM目标是不超过2048个Region(JVM源码里TARGET_REGION_NUMBER 定义)，实际可以超过该值，但是不推荐。 一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数-XX:G1HeapRegionSize​手动指定Region大小，但是推荐默认的计算方式。\",\"G1保留了年轻代和老年代的概念，但不再是物理隔离了，他们都是(相同性质的堆可以不连续)Region的集合 默认年轻代占5%，如果堆大小为4096M，那么年轻代就是200M左右内存，对应大概是100个Region，可以通过-XX:G1NewSizePercent设置新生代初始占比。在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过-XX:G1MaxNewSizePercent​调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。\",\"一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。\",\"G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理 G1有专门分配大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50% ，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。\",\"Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。\",\"G1收集器一次GC(主要指Mixed GC)的运作过程大致分为以下几个步骤：\",\"​​\",\"初始标记(Init Mark,STW): 暂停所有其他线程，从gc roots开始标记gc roots能达到的第一个对象，这一步速度很快。\",\"并发标记(Concurrent Marking): 与业务线程一起运行，从第一步标记的对象开始，标记能达到所有对象\",\"最终标记(Remark,STW): 暂停所有其他线程，重新标记漏标对象。\",\"筛选回收(CleanUp,STW): 暂停所有其他线程，筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿STW时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片。(注：CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了ZGC，Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本)\",\"G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。\",\"G1在处理多标和漏标的方式为 ：\",\"多标： 暂不处理，形成浮动垃圾，在下次垃圾回收时再处理 。\",\"漏标： 使用原始快照方式进行处理。\",\"G1被视为JDK1.7以后版本的Java虚拟机中一个重要进化特征。它具备以下特点：\",\"并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。\",\"分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。\",\"空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\",\"可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数\\\"-XX:MaxGCPauseMillis\\\"指定)内完成垃圾收集。\",\"毫无疑问， 可以由用户指定期望的停顿时间是G1收集器很强大的一个功能， 设置不同的期望停顿时间， 可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。 不过， 这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时间再怎么低也得有个限度。 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发Full GC反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。\"]},\"53\":{\"h\":\"G1垃圾收集分类\"},\"54\":{\"h\":\"YoungGC\",\"t\":[\"YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC\"]},\"55\":{\"h\":\"MixedGC\",\"t\":[\"MixedGC不是FullGC，当老年代占有率达到了参数-XX:InitiatingHeapOccupancyPercent​设置的值时则触发，回收所有的Young和部分old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中的对象拷贝到别的region中。拷贝的过程中发现没有足够的空region能够承载拷贝对象就会触发一次FullGC。\"]},\"56\":{\"h\":\"FullGC\",\"t\":[\"停止系统线程，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)\"]},\"57\":{\"h\":\"\",\"t\":[\"-XX:+UseG1GC: 使用G1收集器\",\"-XX:ParallelGCThreads: 指定GC工作的线程数量\",\"-XX:G1HeapRegionSize: 指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区\",\"-XX:MaxGCPauseMillis: 目标暂停时间(默认200ms)\",\"-XX:G1NewSizePercent: 新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)\",\"-XX:G1MaxNewSizePercent: 新生代内存最大空间\",\"-XX:TargetSurvivorRatio: Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代\",\"-XX:MaxTenuringThreshold: 最大年龄阈值(默认15)\",\"-XX:InitiatingHeapOccupancyPercent: 老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了\",\"-XX:G1MixedGCLiveThresholdPercent(默认85%): region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。\",\"-XX:G1MixedGCCountTarget: 在一次回收过程中指定做几次筛选回收(默认8次)，这个参数标识最后的混合回收阶段会执行8次，一次只回收掉一部分的Region，然后系统继续运行，过了一小段时间之后，又再次进行混合回收，重复8次，这样可以让系统不至于单次停顿时间过长。\",\"-XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。\"]},\"58\":{\"h\":\"\",\"t\":[\"假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。或者是当年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。\",\"所以这里的优化核心还是在于调节 -XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc。\"]},\"59\":{\"h\":\"\",\"t\":[\"50%以上的堆被存活对象占用\",\"对象分配和晋升的速度变化非常大\",\"垃圾回收时间特别长，超过1秒\",\"8GB以上的堆内存(建议值)\",\"停顿时间是500ms以内\"]},\"60\":{\"h\":\"\",\"t\":[\"Kafka类似的支撑高并发消息系统大家肯定不陌生，对于kafka来说，每秒处理几万甚至几十万消息时很正常的，一般来说部署kafka需要用大内存机器(比如64G)，也就是说可以给年轻代分配个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题，我们以前常说的对于eden区的young gc是很快的，这种情况下它的执行还会很快吗？很显然，不可能，因为内存太大，处理还是要花不少时间的，假设三四十G内存回收可能最快也要几秒钟，按kafka这个并发量放满三四十G的eden区可能也就一两分钟，那么意味着整个系统每运行一两分钟就会因为young gc卡顿几秒钟没法处理新消息，显然是不行的。\",\"对于这种情况，我们可以使用G1收集器，假设50ms能够回收三到四个G内存，那么设置 -XX:MaxGCPauseMills 为50ms，然后50ms的卡顿其实完全能够接受，用户几乎无感知，这样整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。\",\"适用场景\",\"G1垃圾回收器天生适合这种大JVM内存的场景，可以有效解决大内存带来的垃圾回收时间过长问题。\"]},\"61\":{\"h\":\"ZGC收集器(\",\"t\":[\"参考文章\",\"https://wiki.openjdk.java.net/display/zgc/Main\",\"http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf\",\"ZGC是JDK11开始引入的一个新的低延时垃圾收集器，它的目标之一是将STW控制在10ms左右的同时，支持最高TB级别内存的垃圾回收。\",\"注\",\"根据R大的说法，ZGC是根据Azul的论文，通过软件方式设计的\",\"https://www.usenix.org/legacy/events/vee05/full_papers/p46-click.pdf\",\"Azul PGC简单来说是：它是一个mark-compact GC，但是GC过程中所有的阶段都设计为可以并发的，包括移动对象的阶段，所以GC正常工作的时候除了会在自己的线程上吃点CPU之外并不会显著干扰应用的运行。为了实现上方便，PGC虽然算法上可以做成完全并发，但Azul PGC在Azul VM里的实现还是有三个非常短暂的safepoint，其中第一个是做根集合（root set）扫描，包括全局变量啊线程栈啊啥的里面的对象指针，但不包括GC堆里的对象指针，所以这个暂停就不会随着GC堆的大小而变化（不过会根据线程的多少啊、线程栈的大小之类的而变化）。另外两个暂停也同样不会随着堆大小而变化。\"]},\"62\":{\"h\":\"ZGC的目标\",\"t\":[\"​​\",\"支持TB量级的堆： 在半导体现有的发展情况下，TB级别的堆内存支持，基本可以满足之后数十年的发展。\",\"最大的GC停顿时间不超过10ms：目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，Major GC一般都需要100ms以上（G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反），之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。\",\"奠定未来GC的基础\",\"最糟糕的情况下吞吐量下降15%\",\"另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。\"]},\"63\":{\"h\":\"不分代(暂时)\",\"t\":[\"不区分年轻代和老年代。之前的垃圾收集器进行分代区分是基于\\\"大部分对象都是朝生夕死\\\"的假设，事实上大部分系统的对象也是这种情况。但ZGC目前实现起来太麻烦。具体可参考R大在2018年知乎的回答。\",\"为何 ZGC 不像C4 GC一样采用分代机制？是因为实现复杂度还是另有考虑？ - 知乎 (zhihu.com)\"]},\"64\":{\"h\":\"ZGC内存布局\",\"t\":[\"ZGC是一款基于Region内存布局的，暂时不分代的垃圾收集器，主要使用读屏障，颜色指针等技术实现可并发收集垃圾的垃圾收集器，主要使用标记-整理算法实现。\",\"ZGC的Region可分为大、中、小三类：\",\"小型Region（Small Region） ： 容量固定为2MB， 用于放置小于256KB的小对象。\",\"中型Region（Medium Region） ： 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。\",\"大型Region（Large Region） ： 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配的， 因为复制一个大对象的代价非常高昂。\",\"​​\"]},\"65\":{\"h\":\"ZGC收集过程\",\"t\":[\"​​\",\"并发标记(Concurrent Mark)： 和G1一样，并发标记也是遍历对象图做可达性分析的阶段，它的初始标记(Pause Mark Start)和最终标记(Pause Mark End)阶段会短暂的暂停。但与其说是标记对象(记录对象是否一般标记)，不如说是标记指针(记录指针是否已经被标记)，此时会更新指针中Marked0和Marked1标志位。\",\"并发预备重分配(Concurrent Prepare for Relocate): 这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。\",\"并发重分配(Concurrent Relocate): 重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(读屏障)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力\",\"ZGC的颜色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢， 一旦重分配集中某个Region的存活对象都复制完毕后， 这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。\",\"并发重映射(Concurrent Remap): 重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了\"]},\"66\":{\"h\":\"颜色指针\",\"t\":[\"Colored Pointers，即颜色指针，如下图所示，ZGC的核心设计之一。以前的垃圾回收器的GC信息都保存在对象头中，而ZGC的GC信息保存在指针中。\",\"​​\",\"‍\",\"每个对象有64位的指针，具体被划分为：\",\"18位：预留位，给之后使用。\",\"1位：Finalizable标识，用于并发引用有关，它表示这个对象只能通过finalizer才能引用。\",\"1位：Remapped标识，表示该对象未指向重分配集（Relocation Set，表示需要GC的Region集合）中。\",\"1位：Marked1标识，与Marked0配合使用\",\"1位：Marked0标识，和Marked1配合用于辅助GC\",\"42位：对象地址，因此ZGC可以支持2^42=4TB内存\",\"在每个GC周期开始，颜色指针就会互换标志位，使上次GC周期中修正的标志位失效，这样，所有标志都变成了未标记，这时再做GC进行标记存活的对象，并通过标记整理算法清除垃圾对象。\",\"GC周期1：使用Marked0，即周期结束标识为01\",\"GC周期2：使用Marked1，即周期结束标识为10，这样，所有期望的引用都能被重新标记。\",\"ZGC使用了指针的第19-22位，因此ZGC无法使用指针压缩，同时也无法支持32位的操作系统。\"]},\"67\":{\"h\":\"\",\"t\":[\"因为使用了读屏障，一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。\",\"颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。\",\"颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。\"]},\"68\":{\"h\":\"\",\"t\":[\"ZGC之前的垃圾回收器在处理漏标时使用的都是写屏障(Write Barrier)，ZGC使用了完全不同的读屏障(Load Barrier)。在标记和移动阶段，每次从堆内对象的引用类型中读取一个指针时，都会加上一个Load Barriers。\",\"如下面的代码，第一行代码我们尝试读取堆中的一个对象引用obj.fieldA并赋给引用o（fieldA也是一个对象时才会加上读屏障）。如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW。\",\"那么，JVM是如何判断对象被移动过呢？就是利用上面提到的颜色指针，如果指针是Bad Color，那么程序还不能往下执行，需要「slow path」，修正指针；如果指针是Good Color，那么正常往下执行即可：\",\"​​\",\"后面3行代码都不需要加读屏障：\",\"Object p = o这行代码并没有从堆中读取数据；\",\"o.doSomething()也没有从堆中读取数据；\",\"obj.fieldB不是对象引用，而是原子类型。\",\"正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销：\",\"​​\",\"那么，判断对象是Bad Color还是Good Color的依据是什么呢？就是根据上一段提到的Colored Pointers的4个颜色位。当加上读屏障时，根据对象指针中这4位的信息，就能知道当前对象是Bad/Good Color了。\",\"思考\",\"既然低42位指针可以支持4T内存，那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢？\",\"答案肯定是不可以。因为目前主板地址总线最宽只有48bit，4位是颜色位，就只剩44位了，所以受限于目前的硬件，ZGC最大只能支持16T的内存，JDK13就把最大支持堆内存从4T扩大到了16T。\"]},\"69\":{\"h\":\"ZGC存在的问题\",\"t\":[\"ZGC最大的问题是浮动垃圾。ZGC的停顿时间是在10ms以下，但是ZGC的总的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。\",\"ZGC问题\",\"Per大大毫无遮掩地表示当前的ZGC如果遇到非常高的对象分配速率（allocation rate）的话会跟不上，目前唯一有效的“调优”方式就是增大整个GC堆的大小来让ZGC有更大的喘息空间。而添加分代或者Thread-Local GC则可以有效降低这种情况下对堆大小（喘息空间）的需求。 作者：RednaxelaFX 来源：知乎\",\"启用ZGC比较简单，设置JVM参数即可：-XX:+UnlockExperimentalVMOptions 「-XX:+UseZGC」。调优也并不难，因为ZGC调优参数并不多，远不像CMS那么复杂。它和G1一样，可以调优的参数都比较少，大部分工作JVM能很好的自动完成。下图所示是ZGC可以调优的参数：\",\"​​\",\"前同事问过一个ZGC导致内存飙高的问题，因为不是我们的项目，只能边交流边goole。以下命令都是在测试环境执行，根据他说的，他们生产已经飙到了20G\",\"最开始以为是大对象占用太多，ZGC回收垃圾时，不会移动大对象。但通过jstat -gc pid 1000 10这个命令查看了一下堆内存占用还好，只有1.3G，但是free -g命令看却又占用了5G\",\"使用ps -p pid -o pid,user,&cpu,smem,vsz,rss,tty,stat,start,time,command命令查看rss发现也差不多占用了5G\",\"想使用jmap -heap pid才发现命令变了，变成了jhsdb jmap --heap --pid pid,重新执行后，发现jvm命令给出的堆内占用和jstat差不多，和linux检查出的内存占用有出入。\",\"网上搜索一番后，让同事使用top命令查看了一下，和预想的差不多，也是6G左右。\",\"最后通过在上查到的解答，发现ZGC使用了内存映射技术，将同一份物理内存映射为了三份虚拟内存\",\"ZGC内存突破物理内存\",\"因为同事还没代码权限，问我的时候拉出来了堆内信息，而且业务是跑批类型，会处理大量数据，最后估计还是要优化代码，看是否是大对象导致GC回收效率跟不上分配效率导致内存变高。\"]},\"70\":{\"h\":\"\",\"t\":[\"ZGC目前有4中机制触发GC：\",\"定时触发，默认为不使用，可通过ZCollectionInterval参数配置。\",\"预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。\",\"分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。\",\"主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。\"]},\"71\":{\"h\":\"如何选择垃圾回收器\",\"t\":[\"优先调整堆的大小让服务器自己来选择\",\"如果内存小于100M，使用串行收集器\",\"如果是单核，并且没有停顿时间的要求，串行或JVM自己选择\",\"如果允许停顿时间超过1秒，选择并行或者JVM自己选\",\"如果响应时间最重要，并且不能超过1秒，使用并发收集器\",\"4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC\",\"下图有连线的可以搭配使用\",\"​​\",\"JDK 1.8默认使用 Parallel(年轻代和老年代都是)\",\"JDK 1.9开始默认使用 G1，JDK11中删除了CMS垃圾收集器\"]},\"72\":{\"h\":\"安全点与安全区域\"},\"73\":{\"h\":\"安全点(Safe Point)\",\"t\":[\"安全点就是指代码中的一些特定的位置，当线程运行到这些位置时，它的状态是可以确定的，JVM就可以安全的进行一些操作，比如GC等。因此GC也不是随时都能立即触发的，需要等到所有线程运行到安全点时才能触发。\",\"特定的位置有\",\"方法返回之前\",\"调用某个方法之后\",\"抛出异常的位置\",\"循环的末尾\",\"思路\",\"大体实现思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的\"]},\"74\":{\"h\":\"安全区域(Safe Region)\",\"t\":[\"Safe Point是针对正在执行线程设计的，但程序运行中会存在Sleep或者中断的线程，这种线程无法响应JVM的中断请求。因此JVM引入安全区域(Safe Region)概念，Safe Region是指在一段代码片段中，对象的引用关系不会发生变化。在这个区域内进行GC都是安全的。\"]},\"75\":{\"c\":[\"JVM\",\"垃圾收集器\"]},\"76\":{\"h\":\"06-JVM工具详解\"},\"77\":{\"h\":\"前置启动程序\",\"t\":[\"事先启动一个web程序，使用jps查看其进程id，接着可以使用各种java提供的工具排查、优化应用\"]},\"78\":{\"h\":\"jmap\",\"t\":[\"此命令能查看内存信息，实例个数及占用内存大小。\"]},\"79\":{\"h\":\"jmap -histo\",\"t\":[\"#查看历史生成的实例 jmap -histo pid #查看当前存活的实例，执行过程中可能会触发一次fullGC jmap -histo:live pid \",\"​​\",\"​​\",\"num：序号\",\"instances：实例数量\",\"bytes：占用空间大小\",\"class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]\"]},\"80\":{\"h\":\"jmap -heap\",\"t\":[\"查看堆信息\",\"#JDK8查看堆内存信息 jmap -heap pid #JDK17查看堆内存信息 jhsdb jmap --heap --pid pid \",\"​​\"]},\"81\":{\"h\":\"导出堆内对象信息\",\"t\":[\"#导出堆内对象信息到文件 jmap -dump:format=b,file=dump.hprof pid \",\"也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)\",\"-XX:+HeapDumpOnOutOfMemoryError\",\"-XX:HeapDumpPath=./ （路径）\",\"导出文件后，可通过jvisualvm命令工具导入该hprof文件分析\",\"idea分析堆文件\",\"idea中通过View->Tool Windows->Profiler打开分析界面，在界面右方点击打开本地的hprof文件进行分析，如果同时打开了对应的工程，还可直接检测到这个类的哪一行不断产生大对象导致堆溢出\",\"jvm内存溢出排查（使用idea自带的内存泄漏分析工具)_idea jvm内存分析工具-CSDN博客\"]},\"82\":{\"h\":\"jstack\",\"t\":[\"栈信息，可通过该命令查找死锁\"]},\"83\":{\"h\":\"jstack pid\",\"t\":[\"public class DeadLockTest { private static Object lock1 = new Object(); private static Object lock2 = new Object(); public static void main(String[] args) { new Thread(() -> { synchronized (lock1) { try { System.out.println(\\\"thread1 begin\\\"); Thread.sleep(5000); } catch (InterruptedException e) { } synchronized (lock2) { System.out.println(\\\"thread1 end\\\"); } } }).start(); new Thread(() -> { synchronized (lock2) { try { System.out.println(\\\"thread2 begin\\\"); Thread.sleep(5000); } catch (InterruptedException e) { } synchronized (lock1) { System.out.println(\\\"thread2 end\\\"); } } }).start(); System.out.println(\\\"main thread end\\\"); } } \",\"​​\",\"\\\"Thread-1\\\" 线程名\",\"prio=5 优先级=5​\",\"tid=0x000000001fa9e000 线程id​\",\"nid=0x2d64 线程对应的本地线程标识nid​\",\"java.lang.Thread.State: BLOCKED 线程状态\",\"​​\",\"还可以用jvisualvm自动检测死锁\",\"​​\"]},\"84\":{\"h\":\"jstack找出占用CPU最高的线程\",\"t\":[\"package com.tuling.jvm; /** * 运行此代码，cpu会飙高 */ public class Math { public static final int initData = 666; public static User user = new User(); public int compute() { //一个方法对应一块栈帧内存区域 int a = 1; int b = 2; int c = (a + b) * 10; return c; } public static void main(String[] args) { Math math = new Math(); while (true){ math.compute(); } } } \",\"使用命令top -p pid​显示你的java进程内存情况\",\"​​\",\"大写H，展示进程中的线程ID\",\"​​\",\"找到内存和CPU占用较高的tid比如19664\",\"通过printf \\\"%x\\\" pid 转换为十六进制得到0x4cd0，此为线程的十六进制表示\",\"执行jstack 19663 |grep -A 10 4cd0得到线程堆栈信息中4cd0的这个线程号后面10行的信息，从堆栈信息中cpu飙高的代码行信息\",\"​​\",\"查看对应的堆栈信息找出可能存在问题的代码\"]},\"85\":{\"h\":\"jinfo\",\"t\":[\"查看正在运行的java的运行参数\"]},\"86\":{\"h\":\"jinfo -flags pid\",\"t\":[\"查看java参数\",\"​​\"]},\"87\":{\"h\":\"jinfo -sysprops pid\",\"t\":[\"查看java系统参数\",\"​​\"]},\"88\":{\"h\":\"jstat\",\"t\":[\"jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：\",\"jdk8：jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数]\",\"#命令选项 -class：显示ClassLoader的相关信息 -compiler：显示JIT编译的相关信息 -gc：显示与GC相关信息 -gccapacity：显示各个代的容量和使用情况 -gccause：显示垃圾收集相关信息（同-gcutil），同时显示最后一次或当前正在发生的垃圾收集的诱发原因 -gcnew：显示新生代信息 -gcnewcapacity：显示新生代大小和使用情况 -gcold：显示老年代信息 -gcoldcapacity：显示老年代大小 -gcpermcapacity：显示永久代大小 -gcutil：显示垃圾收集信息 -printcompilation：输出JIT编译的方法信息 -t：在输出信息前加上一个Timestamp列，显示程序的运行时间 -h：可以在周期性数据输出后，输出多少行数据后，跟着一个表头信息 间隔时间：用于指定输出统计数据的周期，单位为毫秒 查询次数：用于指定一个输出多少次数据 \"]},\"89\":{\"h\":\"JVM\",\"t\":[\"用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。\"]},\"90\":{\"h\":\"\",\"t\":[\"可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。\"]},\"91\":{\"h\":\"\",\"t\":[\"知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。\"]},\"92\":{\"h\":\"\",\"t\":[\"这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。\"]},\"93\":{\"h\":\"\",\"t\":[\"知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。\"]},\"94\":{\"h\":\"\",\"t\":[\"其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。\"]},\"95\":{\"h\":\"内存泄漏的一些事\",\"t\":[\"一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数同学可能为了图方便对于JVM级缓存就简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，时间长了除了导致full gc，还有可能导致OOM。\",\"这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache等自带一些LRU数据淘汰算法的框架来作为JVM级的缓存。\",\"‍\"]},\"96\":{\"c\":[\"JVM\"]},\"97\":{\"h\":\"01-Mysql索引底层数据结构\"},\"98\":{\"h\":\"一、索引的本质\",\"t\":[\"​​\",\"select * from t where col2 = 89\",\"我们插入到数据表中的数据，有可能分布存储在磁盘不同的空间中，而我们的数据库查询的时候每次都要进行磁盘 IO。当我们不加索引的时候，此时查询就是全表扫描，即一行一行的比对数据，多次进行磁盘 IO，直到查询到我们所需的数据。\",\"而我们所能想到的优化，自然是减少磁盘 IO。而减少磁盘 IO，我们自然是要减少数据比对的次数，即我们要在尽可能少的比对次数中，查询出我们需要的数据。\",\"所以，我们可以考虑，能不能使用一种数据结构来存储数据，使得我们的查询效率更高呢？这时候我们是不是就想到了树这种数据结构？\",\"如果我们可以使用二叉树存储数据，可以用 key 存储数据，用 value 存储磁盘地址，这样查询某个数据时候性能就会大大提升。比如我们查找 col2=89 的数据，如果我们不使用数据结构存储，那么需要 8 次才能找到。而如果我们使用二叉树来存储，只需要 2 次就能查询到数据。\"]},\"99\":{\"h\":\"hash 索引\",\"t\":[\"​​\",\"​​\",\"​​​​存储数据的时候会根据 mysql 自己实现的 hash 算法对索引值进行 hash，然后将索引和内存地址进行存储。如果发生了 hash 碰撞，使用链表连接。\",\"查询的时候先根据索引的 hash 定位位置，然后遍历链表找到具体的索引值，最后根据索引值存储的磁盘文件地址找到具体的数据。\",\"在某些情况下，hash 的效率要优于 B+ 树，因为只需要进行一次磁盘 IO 就能查询到数据。而早期的 B+ 树，只把根节点放到了内存中，可能需要多次磁盘 IO 才能定位到具体数据。\",\"但是 Hash 存在的问题就是如果数据量较大的时候，较多的 hash 冲突导致链表查询数据较慢。而最主要的问题是，hash 仅能满足等值运算，对于范围查找并不支持。\"]},\"100\":{\"h\":\"MySQL 底层为什么不使用二叉树\",\"t\":[\"有如下查询语句：\",\"select * from t where col1 =6; \",\"如果我们使用二叉树给表 t 中的 col1 加了索引，如下：\",\"我们可以看到，当我们的数据是顺序增加的时候，二叉树变成了一个类似链表的树。此时当我们要查询 6 的时候，仍然需要查询 6 次，这和全表扫描基本没什么区别。\",\"​​\",\"这就是 mysql 不使用二叉树的原因，对于单边增长的数据，适用二叉树存储导致二叉树过高，形成一个链表，对我们的查询几乎没有帮助，反而 mysql 需要维护这个索引。\"]},\"101\":{\"h\":\"MySQL 底层为什么不使用红黑树（二叉平衡树）\",\"t\":[\"什么是红黑树\",\"每个节点或者是黑色，或者是红色\",\"根节点是黑色。\",\"每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL 或 NULL)的叶子节点！]\",\"如果一个节点是红色的，则它的子节点必须是黑色的。\",\"从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点\",\"我们插入 1,2\",\"我们来观察一下，当我们继续添加这种单边增长数据，添加 3：\",\"我们发现它不像二叉树一样严格的按照左子树小于根节点、右子数大于根节点的规律进行存储，而是会自动进行平衡。\",\"插入的时候，如果一个红色节点上有了两个黑色节点，就会将该红节点转化成黑节点，同时将该节点两侧的黑节点转化成红节点，同时将上一个黑节点指向该次生成的黑色节点。\",\"即红黑树的特性就是，当树的一边比另一边更高的时候，就会自动进行一次平衡。\",\"​​\",\"​​\",\"​​\",\"​​\",\"我们可以看到，红黑树相对于二叉树确实有所提高，整个树的高度小于二叉树，不会在单边增长的情况下退化为链表。但是当我们数据比较多的时候，红黑树依然会出现“树太高”的问题。\",\"我们需要理解到，树太深的根本原因就是每个根节点只储存了两个子树，这就导致数据量大的时候，树的深度必然太大。所以我们要考虑是否可以增加同一个节点上存储的数据的个数，使得每一个节点可以有更多的子节点，从而存储更多的数据，以此来减少树高度的快速增大。\"]},\"102\":{\"h\":\"MySQL 底层为什么不使用 B Tree\",\"t\":[\"B 树的每个节点都存储了索引和对应的数据。\",\"B 树确实极大的降低了树的高度，但是由于每个节点都存储了数据，导致每一次磁盘 IO 时候所能加载的数据比较少，这无疑是增加了磁盘 IO 的次数，严重影响性能。而且，B 树叶节点之间没有指针连接，这样范围查询的时候就需要不断的从根节点向下遍历，直至匹配到所有条件。\",\"​​\"]},\"103\":{\"h\":\"B+Tree\",\"t\":[\"mysql 底层对 B+ 树做了一些修改，B+ 树的叶子节点之间是单向指针，而 MYysql 中的 B+ 树叶子节点之间是双向指针。\",\"​B+ 树中有一个 max-degree 属性，即表示 B+ 数的节点不能超过该数。\",\"当我们插入 3 的时候：\",\"​​\"]},\"104\":{\"h\":\"B 树和 B+ 树的不同点\",\"t\":[\"B+ 树非叶子节点存储的是冗余索引，存储的是每一页的第一个索引，用来构建整个 B+ 树，只有叶子节点存储了索引和数据。而 B 数，每个节点都存储了索引和数据.\",\"B+ 数每连个叶子节点之间都有一个双向指针，将所有的叶子节点连了起来。指针的作用是：不同的叶子节点存储了其左右相邻的叶子节点的内存地址，这样可以非常快速的去访问相邻的叶子节点。 而 B 数中，叶子节点之前是没有整个指针的。\"]},\"105\":{\"h\":\"B+ 数是如何查询数据的\",\"t\":[\"首先会将 B+ 树的根节点加载到内存中，然后用需要查询的索引值去一一比对。假如我们想查询 30 的记录，这时候 mysql 会根据二分查找算法，首先计算出 30 大概在左边还是右边，此时会确定出，30 在 15 和 56 之间的节点上。而这个节点上存储了 15 到 56 之间的页数据的内存地址，所以可以很快的访问到 15 到 56 之间的子节点数据。然后继续采用二分查找，确定出 30 正在 30~40 之间的节点上，取到内存地址后访问，得到 20 和 30 的叶子节点数据。然后再进行一次查询，就可以找到 30，然后取出 30 所在节点的内存地址，就可以访问到要查询的数据了。\"]},\"106\":{\"h\":\"B+ 树叶子节点之间为何使用双向指针互相连接\",\"t\":[\"在进行范围查询的时候，我们知道 Hash 索引并不支持范围查询，仅支持等只查询。\",\"​​\",\"而 B+ 数中叶子节点间本来就是依次递增排好序的，所以我们范围查询的时候就可以根据第一个叶子节点以及指针，快速的定位到其他的叶子节点，直到完成范围查询。这样范围查询的效率是非常高的。如果是增量的范围查询 20~50，我们只需要定位两个节点 20 和 50 即可，因为叶子节点就是按照增序排列的。\",\"​​\",\"而 B 树中叶子节点之间并没有指针，这样就需要不断的从根节点向叶子节点查询，直到查询到复合条件的数据。这样的效率是比较低的。\"]},\"107\":{\"h\":\"MySql 一页的大小是 16k\",\"t\":[\"Page 是 Innodb 存储的最基本结构，也是 Innodb 磁盘管理的最小单位，与数据库相关的所有内容都存储在 Page 结构里。Page 分为几种类型：数据页（B-Tree Node），Undo 页（Undo Log Page），系统页（System Page），事务数据页（Transaction System Page）等；每个数据页的大小为 16kb，每个 Page 使用一个 32 位（一位表示的就是 0 或 1）的 int 值来表示，正好对应 Innodb 最大 64TB 的存储容量(16kb * 2^32=64tib)\",\"SHOW GLOBAL STATUS LIKE 'Innodb_page_size'; \",\"​​\",\"这个值可以修改，但是不建议修改。这里的 16Kb 是经过计算得到的较优的数据大小。\",\"比如我们使用 bigint(mysql 中占 8B)存储自增主键，每个内存地址大概占用 6 个 B。那么我们来算算，一页可以加载多少个索引：\",\"16 * 1024 / (8 + 6) = 1170\",\"我们知道，叶子节点还存储了数据，假设是每行记录 1KB，那么一页就是 18 行记录。那么整个 B+ 树存满的时候，共有多少个叶子节点呢？\",\"1170117016 = 21902400\",\"所以说，如果使用 B+ 树存储两千万行数据，树的高度也只有 3. 整个查询是相当快的。而且，对于根节点，mysql 是将放到内存的，是常驻内存的。对于较高版本的 mysql，会将所有的非叶子节点都放入到内存中！\",\"mysql 每次和磁盘进行 IO，都会 load 大概 16k 的数据。其实在查询的过程中，比对数据消耗的实现是非常短暂的，而每次加载一页的数据，这个磁盘 IO 过程是比较耗时的。所以说我们要尽可能减少磁盘 IO 的时间。 这里优化的思路就是每一次磁盘 IO 的时候，都尽可能多的加载出数据，这就是为什么 Mysql 不使用 B 数的一个原因，因为 B 数每个节点都存储了索引和数据，这就使得每一页只能加载较少的数据记录。所以 B+ 数的非叶子节点只存了索引，这就使得每一页上能查询出更多的数据记录，相当于是减少了磁盘 IO。\",\"注意，其实 B+ 树的树高度和和数据的大小是有关的，当数据超过两千万行，甚至更多的时候，我们可以增加树的高度，来存储更多的数据。\"]},\"108\":{\"h\":\"二、索引存储\"},\"109\":{\"h\":\"索引存储的位置\",\"t\":[\"mysql 的数据默认都存储在 mysql 服务的 data 目录下，我们可以看到每个数据库都是一个文件夹：\",\"我们进入到某个文件夹下，可以看到数据对应的是该数据库中的数据表。一张表对应两个文件\",\"注意：Innodb 或者 MyISAM 存储引擎是数据表级别的，并不是数据库级别的。我们可以针对一张表设置存储引擎。\",\"​​\",\"​​\",\"​​\"]},\"110\":{\"h\":\"MyISAM 索引文件和数据文件存储\",\"t\":[\"*.frm:存储和表结构相关的数据\",\"*.MYD:存储表数据\",\"*.MYI:存储索引\",\"​​\",\"​​\"]},\"111\":{\"h\":\"MyISAM 数据查询\",\"t\":[\"如果 col1 是索引，要查询 col1=30 的数据：\",\"首先从索引的根节点开始查询，定位到 15-56 之间\",\"然后进入下级节点，定位到 20-49 之间\",\"然后进入叶子节点，定位到 30，取出存储的内存地址\",\"去磁盘上*.MYD 文件中，根据取出的内存地址读取数据\",\"​​\"]},\"112\":{\"h\":\"Innodb 索引文件和数据文件存储\",\"t\":[\"Innodb 表对应的文件只有两个：\",\"*.frm：存储和表结构相关的数据\",\"*.ibd：内存采用一个 B+ 树来维护索引和表记录\",\"​​\",\"​​\"]},\"113\":{\"h\":\"MyISAM 和 Innodb 引擎存储数据的区别\",\"t\":[\"MyISAM：\",\"​​\",\"Innodb：\",\"​​\",\"MyISAM 使用三个文件来存储，将表记录单独存储在*.MYD 文件中\",\"Innodb 使用两个文件存储，索引和表记录被维护在一个 B+ 树中，叶子节点存储索引和整个表记录（聚集索引）。索引和表记录存储在*.ibd 文件中\",\"MyISAM 存储引擎中的主键索引是一个非聚集索引，叶子节点中只包含了索引，不包含数据，存储的是内存地址。数据存储在另一个文件*.MYD 中。\",\"聚集索引\",\"聚集索引： 就是索引和数据存储在一起的索引，也叫聚簇索引\",\"非聚集索引： 就是索引和数据分开存储\",\"从存储结构上来讲，聚集索引查询更快。因为非聚集索引需要回表操作\"]},\"114\":{\"h\":\"为什么 InnoDB 表必须建立主键？并且推荐使用整型的自增主键？\",\"t\":[\"InnoDB 表对应的 ibd 文件是一个 B+ 树，如果表中有主键索引的话，就会使用这个主键索引来构建 B+ 树。如果我们不建立主键索引，mysql 会从该表的所有列中选择数据不重复的一列来组织 B+ 数。如果表中没有符合条件的列，mysql 会自己创建一个隐藏列，类似 row_id，用这一列构建 B+ 树。\",\"为什么我们使用整型的数据作为自增索引呢？因为整型的数据更好比较大小，计较速度比较快。而如果使用 UUID，就需要逐位去比较大小。而且整型数据占用的内存空间更小。\"]},\"115\":{\"h\":\"为什么推荐使用自增主键\",\"t\":[\"我们创建的索引，在 B+ 树中是按照顺序排列的。所以即使我们创建的时候不是按照顺序插入的，mysql 也会根据大小进行排序。即，mysql 需要维护叶子节点中的数据顺序。\",\"而当我们不是顺序插入的时候，如主键插入是 8,6。这样，mysql 就需要修改整个叶子节点的顺序，移动 8 整个节点，将 6 节点插入到 8 节点之前。这个修改过程是比较耗费时间的，所以说我们最好使用自增主键，这样 mysql 就不需要频繁的移动和修改叶子节点的顺序。\",\"​​\",\"​​\",\"可以看到，整个 B+ 树的结构发生了平衡。这个平衡是会消耗时间的。如果是递增，就会创建新的节点，而不是插入到已有的节点再进行分裂和平衡。\"]},\"116\":{\"h\":\"为什么非主键索引（二级索引）结构叶子节点存储的是主键值\",\"t\":[\"MyISAM 的主键和非主键索引存储都是一样的。而 InnoDB 的非主键索引和主键索引是不同的，非主键索引的叶子节点存储的是聚集索引的值。InnoDB 表中只有一个聚集索引。当使用二级索引查询数据的时候，如果查询的字段包括在索引中，直接返回数据。否则就会根据叶子节点中存储的聚集索引的值，回到聚集索引中查询，然后在聚集索引的叶子节点查询出完整数据(称之为回表)。\",\"回表\",\"回表操作是一种数据库查询优化技术，主要用在索引查询过程中。当通过非主键索引查询数据时，会首先查找到对应的主键值，然后再通过这个主键值去聚集索引树中查找完整的数据行。这种需要二次查找的过程就被称为“回表”。例如，在一个产品表中，如果我们使用id作为主键索引，而name和price作为二级索引，那么当我们通过name或price进行查询时，首先通过二级索引找到对应的id，然后再通过id到主键索引中找到完整的产品信息。这个过程就是回表操作。\",\"为什么二级索引不做成聚集索引呢？\",\"1、解决存储空间，数据只存储一份即可，非聚集索引存储聚集索引的主键，可大大减少存储的空间\",\"2、一致性：如果同一张表有多个聚集索引，必然要维护数据的一致性，复杂度较高。\",\"​​\"]},\"117\":{\"h\":\"三、联合索引（复合索引：a, b, c）\",\"t\":[\"​​\",\"现在有一个联合索引（name, age, position），那么我们怎样维护这个联合索引呢？\"]},\"118\":{\"h\":\"索引最左前缀原理\",\"t\":[\"现在有联合索引（name, age, position） 会按照索引字段的顺序排序，先比较 n​ame，再比较 age，再比较 position.\",\"下面的三条 SQL 语句只有第一条 SQL 语句才会走索引。根据左前缀匹配原理，如果我们想使用联合索引，一定要按照联合索引中字段的创建顺序去过滤。那么为什么呢？\",\"​​\",\"我们知道，建立了索引之后，叶子节点是按照顺序排列的。如果是联合索引，是根据联合字段进行综合排序的。\",\"​​\",\"如果我们不根据联合索引字段去查询，即跳过左边的某个字段去查询，此时剩下的右边的字段并不是按照顺序排序的。因为前提是如果左边的索引字段相同的情况下，右边的索引字段才会按照顺序排列。 所以说，如果不按照最左匹配原则来查询，联合索引就会失效，因为叶子节点是按照联合字段综合排序的，即此时的排序不使用于不满足最左匹配原则的查询\"]},\"119\":{\"c\":[\"Mysql\"]},\"120\":{\"h\":\"02-Mysql索引优化一\"},\"121\":{\"h\":\"数据准备\",\"t\":[\"CREATE TABLE `employees` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名', `age` int(11) NOT NULL DEFAULT '0' COMMENT '年龄', `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位', `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间', PRIMARY KEY (`id`), KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='员工记录表'; INSERT INTO employees(name,age,position,hire_time) VALUES('LiLei',22,'manager',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('HanMeimei', 23,'dev',NOW()); INSERT INTO employees(name,age,position,hire_time) VALUES('Lucy',23,'dev',NOW()); -- 插入一些示例数据 drop procedure if exists insert_emp; delimiter ;; create procedure insert_emp() begin declare i int; set i=1; while(i<=100000)do insert into employees(name,age,position) values(CONCAT('zhuge',i),i,'dev'); set i=i+1; end while; end;; delimiter ; call insert_emp(); \"]},\"122\":{\"h\":\"举一个不容易理解的综合例子\"},\"123\":{\"h\":\"1、联合索引第一个字段用范围不会走索引\",\"t\":[\"EXPLAIN SELECT * FROM employees WHERE name > 'LiLei' AND age = 22 AND position ='manager'; \",\"​​\",\"结论： 联合索引第一个字段就用范围查找不会走索引，mysql内部可能觉得第一个字段就用范围，结果集应该很大，回表效率不高，还不如就全表扫描\"]},\"124\":{\"h\":\"2、强制走索引\",\"t\":[\"EXPLAIN SELECT * FROM employees force index(idx_name_age_position) WHERE name > 'LiLei' AND age = 22 AND position ='manager'; \",\"​​\",\"结论： 虽然使用了强制走索引让联合索引第一个字段范围查找也走索引，扫描的行rows看上去也少了点，但是最终查找效率不一定比全表扫描高，因为回表效率不高\",\"做了一个小实验：\",\"-- 关闭查询缓存 set global query_cache_size=0; set global query_cache_type=0; -- 执行时间0.333s SELECT * FROM employees WHERE name > 'LiLei'; -- 执行时间0.444s SELECT * FROM employees force index(idx_name_age_position) WHERE name > 'LiLei'; \"]},\"125\":{\"h\":\"3、覆盖索引优化\",\"t\":[\"EXPLAIN SELECT name,age,position FROM employees WHERE name > 'LiLei' AND age = 22 AND position ='manager'; \",\"​​\"]},\"126\":{\"h\":\"4、in和or在表数据量比较大的情况会走索引，在表记录不多的情况下会选择全表扫描\",\"t\":[\"EXPLAIN SELECT * FROM employees WHERE name in ('LiLei','HanMeimei','Lucy') AND age = 22 AND position ='manager'; \",\"​​\",\"EXPLAIN SELECT * FROM employees WHERE (name = 'LiLei' or name = 'HanMeimei') AND age = 22 AND position ='manager'; \",\"​​\",\"做一个小实验，将employees 表复制一张employees_copy的表，里面保留两三条记录\",\"EXPLAIN SELECT * FROM employees_copy WHERE name in ('LiLei','HanMeimei','Lucy') AND age = 22 AND position ='manager'; \",\"​​\",\"EXPLAIN SELECT * FROM employees_copy WHERE (name = 'LiLei' or name = 'HanMeimei') AND age = 22 AND position ='manager'; \",\"​​\"]},\"127\":{\"h\":\"5、like KK% 一般情况都会走索引\",\"t\":[\"EXPLAIN SELECT * FROM employees WHERE name like 'LiLei%' AND age = 22 AND position ='manager'; \",\"​​\",\"EXPLAIN SELECT * FROM employees_copy WHERE name like 'LiLei%' AND age = 22 AND position ='manager'; \",\"​​\",\"这里有一个索引下推（Index Condition Pushdown，ICP）的概念，like KK%其实就是用到了索引下推优化\",\"索引下推\",\"对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，如\",\"SELECT * FROM employees WHERE name like 'LiLei%' AND age = 22 AND position ='manager'; \",\"这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和position是无序的，无法很好的利用索引。\",\"在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 'LiLei' 开头的索引，然后拿这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再比对age和position这两个字段的值是否符合。\",\"MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的所有字段先做判断​，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 'LiLei' 开头的索引之后，同时还会在索引里过滤age和position这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。\",\"索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引（聚簇索引）的叶子节点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。\"]},\"128\":{\"h\":\"为什么范围查找Mysql没有用索引下推优化？\",\"t\":[\"应该是Mysql认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。\"]},\"129\":{\"h\":\"Mysql如何选择合适的索引\",\"t\":[\"mysql> EXPLAIN select * from employees where name > 'a'; \",\"​​\",\"如果用name索引需要遍历name字段联合索引树，然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据，成本比全表扫描还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下：\",\"mysql> EXPLAIN select name,age,position from employees where name > 'a' ; \",\"​​​​\",\"mysql> EXPLAIN select * from employees where name > 'zzz' ; \",\"​​\",\"对于上面这两种 name>'a' 和 name>'zzz' 的执行结果，mysql最终是否选择走索引或者一张表涉及多个索引，mysql最终如何选择索引，我们可以用trace工具来一查究竟，开启trace工具会影响mysql性能，所以只能临时分析sql使用，用完之后立即关闭\",\"mysql> set session optimizer_trace=\\\"enabled=on\\\",end_markers_in_json=on; --开启trace mysql> select * from employees where name > 'a' order by position; mysql> SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"查看trace字段：\",\"{ \\\"steps\\\": [ { \\\"join_preparation\\\": { --第一阶段：SQL准备阶段，格式化sql \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"expanded_query\\\": \\\"/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` > 'a') order by `employees`.`position`\\\" } ] /* steps */ } /* join_preparation */ }, { \\\"join_optimization\\\": { --第二阶段：SQL优化阶段 \\\"select#\\\": 1, \\\"steps\\\": [ { \\\"condition_processing\\\": { --条件处理 \\\"condition\\\": \\\"WHERE\\\", \\\"original_condition\\\": \\\"(`employees`.`name` > 'a')\\\", \\\"steps\\\": [ { \\\"transformation\\\": \\\"equality_propagation\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" }, { \\\"transformation\\\": \\\"constant_propagation\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" }, { \\\"transformation\\\": \\\"trivial_condition_removal\\\", \\\"resulting_condition\\\": \\\"(`employees`.`name` > 'a')\\\" } ] /* steps */ } /* condition_processing */ }, { \\\"substitute_generated_columns\\\": { } /* substitute_generated_columns */ }, { \\\"table_dependencies\\\": [ --表依赖详情 { \\\"table\\\": \\\"`employees`\\\", \\\"row_may_be_null\\\": false, \\\"map_bit\\\": 0, \\\"depends_on_map_bits\\\": [ ] /* depends_on_map_bits */ } ] /* table_dependencies */ }, { \\\"ref_optimizer_key_uses\\\": [ ] /* ref_optimizer_key_uses */ }, { \\\"rows_estimation\\\": [ --预估表的访问成本 { \\\"table\\\": \\\"`employees`\\\", \\\"range_analysis\\\": { \\\"table_scan\\\": { --全表扫描情况 \\\"rows\\\": 10123, --扫描行数 \\\"cost\\\": 2054.7 --查询成本 } /* table_scan */, \\\"potential_range_indexes\\\": [ --查询可能使用的索引 { \\\"index\\\": \\\"PRIMARY\\\", --主键索引 \\\"usable\\\": false, \\\"cause\\\": \\\"not_applicable\\\" }, { \\\"index\\\": \\\"idx_name_age_position\\\", --辅助索引 \\\"usable\\\": true, \\\"key_parts\\\": [ \\\"name\\\", \\\"age\\\", \\\"position\\\", \\\"id\\\" ] /* key_parts */ } ] /* potential_range_indexes */, \\\"setup_range_conditions\\\": [ ] /* setup_range_conditions */, \\\"group_index_range\\\": { \\\"chosen\\\": false, \\\"cause\\\": \\\"not_group_by_or_distinct\\\" } /* group_index_range */, \\\"analyzing_range_alternatives\\\": { --分析各个索引使用成本 \\\"range_scan_alternatives\\\": [ { \\\"index\\\": \\\"idx_name_age_position\\\", \\\"ranges\\\": [ \\\"a < name\\\" --索引使用范围 ] /* ranges */, \\\"index_dives_for_eq_ranges\\\": true, \\\"rowid_ordered\\\": false, --使用该索引获取的记录是否按照主键排序 \\\"using_mrr\\\": false, \\\"index_only\\\": false, --是否使用覆盖索引 \\\"rows\\\": 5061, --索引扫描行数 \\\"cost\\\": 6074.2, --索引使用成本 \\\"chosen\\\": false, --是否选择该索引 \\\"cause\\\": \\\"cost\\\" } ] /* range_scan_alternatives */, \\\"analyzing_roworder_intersect\\\": { \\\"usable\\\": false, \\\"cause\\\": \\\"too_few_roworder_scans\\\" } /* analyzing_roworder_intersect */ } /* analyzing_range_alternatives */ } /* range_analysis */ } ] /* rows_estimation */ }, { \\\"considered_execution_plans\\\": [ { \\\"plan_prefix\\\": [ ] /* plan_prefix */, \\\"table\\\": \\\"`employees`\\\", \\\"best_access_path\\\": { --最优访问路径 \\\"considered_access_paths\\\": [ --最终选择的访问路径 { \\\"rows_to_scan\\\": 10123, \\\"access_type\\\": \\\"scan\\\", --访问类型：为scan，全表扫描 \\\"resulting_rows\\\": 10123, \\\"cost\\\": 2052.6, \\\"chosen\\\": true, --确定选择 \\\"use_tmp_table\\\": true } ] /* considered_access_paths */ } /* best_access_path */, \\\"condition_filtering_pct\\\": 100, \\\"rows_for_plan\\\": 10123, \\\"cost_for_plan\\\": 2052.6, \\\"sort_cost\\\": 10123, \\\"new_cost_for_plan\\\": 12176, \\\"chosen\\\": true } ] /* considered_execution_plans */ }, { \\\"attaching_conditions_to_tables\\\": { \\\"original_condition\\\": \\\"(`employees`.`name` > 'a')\\\", \\\"attached_conditions_computation\\\": [ ] /* attached_conditions_computation */, \\\"attached_conditions_summary\\\": [ { \\\"table\\\": \\\"`employees`\\\", \\\"attached\\\": \\\"(`employees`.`name` > 'a')\\\" } ] /* attached_conditions_summary */ } /* attaching_conditions_to_tables */ }, { \\\"clause_processing\\\": { \\\"clause\\\": \\\"ORDER BY\\\", \\\"original_clause\\\": \\\"`employees`.`position`\\\", \\\"items\\\": [ { \\\"item\\\": \\\"`employees`.`position`\\\" } ] /* items */, \\\"resulting_clause_is_simple\\\": true, \\\"resulting_clause\\\": \\\"`employees`.`position`\\\" } /* clause_processing */ }, { \\\"reconsidering_access_paths_for_index_ordering\\\": { \\\"clause\\\": \\\"ORDER BY\\\", \\\"steps\\\": [ ] /* steps */, \\\"index_order_summary\\\": { \\\"table\\\": \\\"`employees`\\\", \\\"index_provides_order\\\": false, \\\"order_direction\\\": \\\"undefined\\\", \\\"index\\\": \\\"unknown\\\", \\\"plan_changed\\\": false } /* index_order_summary */ } /* reconsidering_access_paths_for_index_ordering */ }, { \\\"refine_plan\\\": [ { \\\"table\\\": \\\"`employees`\\\" } ] /* refine_plan */ } ] /* steps */ } /* join_optimization */ }, { \\\"join_execution\\\": { --第三阶段：SQL执行阶段 \\\"select#\\\": 1, \\\"steps\\\": [ ] /* steps */ } /* join_execution */ } ] /* steps */ } \",\"结论：全表扫描的成本低于索引扫描，所以mysql最终选择全表扫描\",\"mysql> select * from employees where name > 'zzz' order by position; mysql> SELECT * FROM information_schema.OPTIMIZER_TRACE; \",\"查看trace字段可知索引扫描的成本低于全表扫描，所以mysql最终选择索引扫描\",\"mysql> set session optimizer_trace=\\\"enabled=off\\\"; --关闭trace \"]},\"130\":{\"h\":\"常见sql深入优化\"},\"131\":{\"h\":\"Order by与Group by优化\",\"t\":[\"Case1：\",\"​​\",\"分析： 利用最左前缀法则：中间字段不能断，因此查询用到了name索引，从key_len=74也能看出，age索引列用在排序过程中，因为Extra字段里有using index condition\",\"Case 2：\",\"​​\",\"分析：\",\"从explain的执行结果来看：key_len=74，查询使用了name索引，由于用了position进行排序，跳过了age，出现了Using filesort。\",\"Case 3：\",\"​​\",\"分析： 查找只用到索引name，age和position用于排序，无Using filesort。\",\"Case 4：\",\"​​\",\"分析： 和Case 3中explain的执行结果一样，但是出现了Using filesort，因为索引的创建顺序为name,age,position，但是排序的时候age和position颠倒位置了。\",\"Case 5：\",\"​​\",\"分析： 与Case 4对比，在Extra中并未出现Using filesort，因为age为常量，在排序中被优化，所以索引未颠倒，不会出现Using filesort。\",\"Case 6：\",\"​​\",\"分析： 虽然排序的字段列与索引顺序一样，且order by默认升序，这里position desc变成了降序，导致与索引的排序方式不同，从而产生Using filesort。Mysql8以上版本有降序索引可以支持该种查询方式。\",\"Case 7：\",\"​​\",\"分析： 对于排序来说，多个相等条件也是范围查询\",\"Case 8：\",\"​​\",\"可以用覆盖索引优化\",\"​​\",\"优化总结：\",\"MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，相对的filesort效率低。\",\"order by满足两种情况会使用Using index。 \",\"order by语句使用索引最左前列。\",\"使用where子句与order by子句条件列组合满足索引最左前列。\",\"尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则。\",\"如果order by的条件不在索引列上，就会产生Using filesort。\",\"能用覆盖索引尽量用覆盖索引\",\"group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上order by null禁止排序。注意，where高于having，能写在where中的限定条件就不要去having限定了。\"]},\"132\":{\"h\":\"索引设计原则\"},\"133\":{\"h\":\"1、代码先行，索引后上\",\"t\":[\"一般是怎么给数据表建立索引的，是建完表马上就建立索引吗？ 这其实是不对的，一般应该等到主体业务功能开发完毕，把涉及到该表相关sql都要拿出来分析之后再建立索引。\"]},\"134\":{\"h\":\"2、联合索引尽量覆盖查询条件\",\"t\":[\"比如可以设计一个或者两三个联合索引(尽量少建单值索引)，让每一个联合索引都尽量去包含sql语句里的where、order by、group by的字段，还要确保这些联合索引的字段顺序尽量满足sql查询的最左前缀原则。\"]},\"135\":{\"h\":\"3、不在小基数字段上建立索引\",\"t\":[\"索引基数是指这个字段在表里总共有多少个不同的值，比如一张表总共100万行记录，其中有个性别字段，其值不是男就是女，那么该字段的基数就是2。 如果对这种小基数字段建立索引的话，还不如全表扫描了，因为你的索引树里就包含男和女两种值，根本没法进行快速的二分查找，那用索引就没有太大的意义了。一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能发挥出B+树快速二分查找的优势来。\"]},\"136\":{\"h\":\"4、长字符串我们可以采用前缀索引\",\"t\":[\"尽量对字段类型较小的列设计索引，比如说什么tinyint之类的，因为字段类型较小的话，占用磁盘空间也会比较小，此时你在搜索的时候性能也会比较好一点。\",\"当然，这个所谓的字段类型小一点的列，也不是绝对的，很多时候你就是要针对varchar(255)这种字段建立索引，哪怕多占用一些磁盘空间也是有必要的。\",\"对于这种varchar(255)的大字段可能会比较占用磁盘空间，可以稍微优化下，比如针对这个字段的前20个字符建立索引，就是说，对这个字段里的每个值的前20个字符放在索引树里，类似于 KEY index(name(20),age,position)。\",\"此时你在where条件里搜索的时候，如果是根据name字段来搜索，那么此时就会先到索引树里根据name字段的前20个字符去搜索，定位到之后前20个字符的前缀匹配的部分数据之后，再回到聚簇索引提取出来完整的name字段值进行比对。\",\"但是假如你要是order by name，那么此时你的name因为在索引树里仅仅包含了前20个字符，所以这个排序是没法用上索引的， group by也是同理。所以这里大家要对前缀索引有一个了解。\"]},\"137\":{\"h\":\"5、where与order by冲突时优先where\",\"t\":[\"在where和order by出现索引设计冲突时，到底是针对where去设计索引，还是针对order by设计索引？到底是让where去用上索引，还是让order by用上索引?\",\"一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据，接着再进行排序。\",\"因为大多数情况基于索引进行where筛选往往可以最快速度筛选出你要的少部分数据，然后做排序的成本可能会小很多。\"]},\"138\":{\"h\":\"6、基于慢sql查询做优化\",\"t\":[\"可以根据监控后台的一些慢sql，针对这些慢sql查询做特定的索引优化。\"]},\"139\":{\"h\":\"索引设计实战\",\"t\":[\"以社交场景APP来举例，我们一般会去搜索一些好友，这里面就涉及到对用户信息的筛选，这里肯定就是对用户user表搜索了，这个表一般来说数据量会比较大，我们先不考虑分库分表的情况，比如，我们一般会筛选地区(省市)，性别，年龄，身高，爱好之类的，有的APP可能用户还有评分，比如用户的受欢迎程度评分，我们可能还会根据评分来排序等等。\",\"对于后台程序来说除了过滤用户的各种条件，还需要分页之类的处理，可能会生成类似sql语句执行：\",\" select xx from user where xx=xx and xx=xx order by xx limit xx,xx \",\"对于这种情况如何合理设计索引，比如用户可能经常会根据省市优先筛选同城的用户，还有根据性别去筛选，那我们是否应该设计一个联合索引(province,city,sex) 了？这些字段好像基数都不大，其实是应该的，因为这些字段查询太频繁了，设计索引后可以减少回表的操作。\",\"假设又有用户根据年龄范围去筛选了，比如 where province=xx and city=xx and age>=xx and age<=xx，我们尝试着把age字段加入联合索引 (province,city,sex,age)，注意，一般这种范围查找的条件都要放在最后，之前讲过联合索引范围之后条件的是不能用索引的，但是对于当前这种情况依然用不到age这个索引字段，因为用户没有筛选sex字段，那怎么优化了？其实我们可以这么来优化下sql的写法：where province=xx and city=xx and sex in ('female','male') and age>=xx and age<=xx\",\"对于爱好之类的字段也可以类似sex字段处理，所以可以把爱好字段也加入索引 (province,city,sex,hobby,age)\",\"假设可能还有一个筛选条件，比如要筛选最近一周登录过的用户，一般大家肯定希望跟活跃用户交友了，这样能尽快收到反馈，对应后台sql可能是这样：\",\"where province=xx and city=xx and sex in ('female','male') and age>=xx and age<=xx and latest_login_time>= xx \",\"那我们是否能把 latest_login_time 字段也加入索引了？比如 (province,city,sex,hobby,age,latest_login_time) ，显然是不行的，那怎么来优化这种情况了？其实我们可以试着再设计一个字段is_login_in_latest_7_days，用户如果一周内有登录值就为1，否则为0，那么我们就可以把索引设计成 (province,city,sex,hobby,is_login_in_latest_7_days,age) 来满足上面那种场景了！\",\"一般来说，通过这么一个多字段的索引是能够过滤掉绝大部分数据的，就保留小部分数据下来基于磁盘文件进行order by语句的排序，最后基于limit进行分页，那么一般性能还是比较高的。\",\"不过有时可能用户会这么来查询，就查下受欢迎度较高的女性，比如sql：where sex = 'female' order by score limit xx,xx，那么上面那个索引是很难用上的，不能把太多的字段以及太多的值都用 in 语句拼接到sql里的，那怎么办了？其实我们可以再设计一个辅助的联合索引，比如 (sex,score)，这样就能满足查询要求了。\",\"索引设计的设计思路，核心思想就是，尽量利用一两个复杂的多字段联合索引，抗下你80%以上的查询，然后用一两个辅助索引尽量抗下剩余的一些非典型查询，保证这种大数据量表的查询尽可能多的都能充分利用索引，这样就能保证你的查询速度和性能了！\"]},\"140\":{\"c\":[\"Mysql\"]},\"141\":{\"h\":\"03-Mysql索引优化二\"},\"142\":{\"h\":\"分页查询 limit start,end\",\"t\":[\"常见的mysql分页写法\",\"select * from employees limit 90000,10; \",\"limit 90000,10 这种写法，mysql会查询出90010条数据，然后将前面90000条数据丢弃，保留最后10条数据。\"]},\"143\":{\"h\":\"优化\",\"t\":[\"以下优化方式各有优缺点，需要根据业务需要灵活选择。\"]},\"144\":{\"h\":\"当主键连续且自增，并且根据主键排序时\",\"t\":[\"可改写为以主键为条件，查询所需条数的写法。\",\"select * from employees where id > 90000 limit 10; \",\"以上条件在实际生产中一般不会出现，业务中删除操作可能会导致主键不连续，同时如果根据非主键排序，也会导致结果不准确。\"]},\"145\":{\"h\":\"主键不连续\",\"t\":[\"当主键不连续时，还有一种一般以最初查询出的数据最后一条的某个字段(一般为创建时间)为条件，查询大于这个条件的后10条或后几条，写法如下\",\"select * from employees where hire_time>'2022-04-28 06:34:28' limit 10; select * from employees where hire_time>'2022-05-05 03:00:23' limit 10; \",\"这种写法也有缺陷，一是需要前端修改分页逻辑，该种查询，前端没有数据总数，需要查询比较靠后的数据需要一步一步点击。二是对where后面的条件也有要求，需要递增，且没有其他条件。\"]},\"146\":{\"h\":\"根据非主键字段排序的分页\",\"t\":[\"select * from employees order by name limit 90000,10; \",\"​​\",\"查看执行计划，该sql走了全表扫描，没有走索引，原因是：该sql语句需查询出非主键的字段，因此，如果走辅助索引，还涉及回表操作，同时因为要limit操作，mysql认为走索引效率不如全表扫描，选择了全表扫描，同时排序使用了文件排序(using filesort)。\",\"优化关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL改写如下。\",\"select * from employees e inner join (select id from employees order by name limit 90000,10) t on t.id=e.id; \"]},\"147\":{\"h\":\"join关联优化\"},\"148\":{\"h\":\"Nested-Loop Join 嵌套循环连接(NLJ)\",\"t\":[\"一次一行的从第一张表(驱动表)中读取数据，并根据关联关系，去第二张表中关联相关数据，取出满足条件的行，然后取两张表的合集。\",\"此种需要被关联的的关联关系建立了索引\",\"如有t1表(a,b)有10000行数据，且a字段建立了索引；t2表(100)结构与t1表结构完全相同\",\"explain select * from t1 inner join t2 on t1.a=t2.a; \",\"​​\",\"查看执行计划可以看到，t2小表为驱动表\",\"mysql先将小表的数据取出来(没有where条件，全表扫描)\",\"然后将数据中a字段的值取出，到t1表中获取数据，因为关联关系在t1表中为索引，因此走索引查询出t1表中的数据。\",\"这种方式磁盘扫描了t2表100行，t1表100行，总共200行，效率还是比较高的。 同时可以看到，mysql优化器会自动选择较小的表作为驱动表，因此inner join写在左边的表不一定是驱动表。\"]},\"149\":{\"h\":\"Block-Nested-Loop Join 基于块的嵌套循环连接(BNL)\",\"t\":[\"当被驱动表关联关系字段没有建立索引时，mysql会使用基于块的嵌套循环连接(BNL)\",\"explain select * from t2 inner join t1 on t1.b=t2.b; \",\"​​\",\"Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。\",\"mysql会先将驱动表t2中的数据取出来存放到内存的join_buffer中。\",\"mysql从被驱动表t1中取出每一行数据，与join_buffer中的t2表数据，根据关联关系进行关联。\",\"返回满足join条件的数据。\",\"根据步骤，可以看到，在获取驱动表数据时mysql扫描了t2表数据100行，然后在比对过程中，需要全表扫描t1表10000行，即需要扫描10100次磁盘，同时在内存中的比对极限情况下可能需要执行100*10000=100万次。\"]},\"150\":{\"h\":\"\",\"t\":[\"根据NLJ步骤：\",\"从t2表取出一条数据\",\"查询t1表，此时数据没有建立索引，因此mysql需要从头开始扫描B+树的所有叶子节点，根据关联关系获取数据，并将符合条件的数据返回。\",\"重复上述过程。\",\"从过程中可以看到，t2表做全表扫描，扫描了100行数据，然后再扫描t1表，极限状态下每条数据在t1里扫描10000次；总共扫描磁盘100*10000=100万次，效率很低，因此mysql不选择NLJ。\",\"注意：join_buffer默认256K，由join_buffer_size参数进行设置。如果放不下t2表数据，mysql会进行切块，分多次存放(分段放)。比如join_buffer中可以存放80条数据，但t2表有100行，此时mysql会先放80条数据在join_buffer中，然后取t1数据进行比较；完成后，将join_buffer中数据删除，放剩下20行数据，再取t1数据进行比较。所以此时会多扫一次t1表。\"]},\"151\":{\"h\":\"优化方法\",\"t\":[\"被驱动表的关联字段添加索引，让mysql尽量走嵌套循环连接(NLJ)。\",\"使用小表驱动大表。\",\"根据阿里开发规范，join的表尽量不要超过三张。\",\"inner join通常情况下mysql执行引擎会优化挑选小表为驱动表，但也有可能会出现优化错误的情况，即数据量大的表为驱动表，此时可使用straight_join指定驱动表，类似如下写法\",\"select * from t2 straight_join t1 on t1.b=t2.b; \",\"​​\",\"straight_join方法只适用与inner join形式，left join和right join已经默认指定了驱动表。\",\"尽量让mysql自己来选择驱动表，大部分情况下，程序判断的比人判断的要准确一些，同时straight_join要慎重使用，因为部分情况下，人为指定的顺序不一定比优化引擎靠谱。\",\"驱动表的定义： 应该为两个表按各自条件过滤后，参与连接的数据，那个表参与连接的数据小，就是驱动表，而不是单纯只看表内的数据量。比如下面两个语句。\",\"select * from t1 inner join t2 on t1.a=t2.a where t1.a<10; \",\"​​\",\"当两个表数据量接近\",\"select * from t1 inner join t2 on t1.a=t2.a where t1.a<80; \",\"​​\"]},\"152\":{\"h\":\"in和exists\",\"t\":[\"原则：小表驱动大表\",\"如果表b的数据集大小小于表a，in优先exists\",\"select * from a where id in (select id from b); 基本等价于 for(select id from b){ select * from a where a.id=b.id } \",\"当a表数据集小于b表时，exists优先in\",\"select * from a where exists (select 1 from b where b.id=a.id); 等价于 for(select * from a){ select * from b where b.id=a.id } a和b表连接字段需要添加索引 \",\"exists执行逻辑：\",\"先查询出外面select * from a的数据\",\"然后根据id关联查询b表中数据((select 1 from b where b.id=a.id)，如果在b表中存在，则保留(exists子句返回1)，否则不保留(exists子句返回0)。\",\"语句返回结果\"]},\"153\":{\"h\":\"count()语句\",\"t\":[\"以下语句执行效率：\",\"select count(*) from t1; select count(1) from t1; select count(id) from t1; select count(name) from t1; \",\"查看执行计划，可以看到其实计划都一样；\",\"当有字段有索引时候的效率：count(*)≈count(1)>count(索引字段)>count(主键) 当字段有索引时候，辅助索引只保存了数据主键，索引树大小较小，效率比count(主键)高一点\",\"当字段没有索引时候的效率：count(*)≈count(1)>count(主键)>count(字段) 当字段没有索引时，mysql主要扫描聚簇索引，即count(主键)从叶子节点扫描，count(字段)需从磁盘加载数据到内存，效率较低。\"]},\"154\":{\"h\":\"\",\"t\":[\"count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出字段，所以理论上count(1)比count(字段)会快一点。\"]},\"155\":{\"h\":\"\",\"t\":[\"count() 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，所以不需要用count(列名)或count(常量)来替代 count()。\"]},\"156\":{\"h\":\"\"},\"157\":{\"h\":\"\",\"t\":[\"对于myisam不带where条件的总行数要求，count的性能很高，因为myisam存储引擎在存储数据时，会将表的总行数存储在磁盘上，直接读取即可，查询不需要计算。\"]},\"158\":{\"h\":\"\",\"t\":[\"如果只需要知道表的总行数估值，可以使用如下命令\",\"show table status like 'tablename'; \"]},\"159\":{\"h\":\"\",\"t\":[\"需要注意的是，插入或删除数据的时候需要同时维护该数据，且最好使用redis原子性增加或减少的方法。\"]},\"160\":{\"h\":\"\",\"t\":[\"可以将统计计数的数据维护到数据库的一个表中，让他们在同一个事务中处理。\",\"‍\"]},\"161\":{\"c\":[\"Mysql\"]},\"162\":{\"h\":\"04-Mysql事务隔离级别及锁机制\"},\"163\":{\"h\":\"概述\",\"t\":[\"数据库通常会并发的执行多个事务，这些事务可能会对同一条数据进行增删改等操作，这可能会产生脏读，脏写，不可重复读等问题。\",\"这些问题的本质就是数据的并发问题，所以数据库设计了事务隔离、锁等机制来解决多事务并发问题。\"]},\"164\":{\"h\":\"事务及ACID属性\",\"t\":[\"原子性： 一个事务内的所有sql语句要么同时成功，要么同时失败，这条是操作层面的，原子性由undo log来实现。\",\"一致性： 事务开始和结束时，数据需要保持一致，即一个事务内多条sql修改的数据，要么都成功，要么都失败，这条主要时数据层面的。\",\"隔离性： 数据库需提供一定隔离性，保证每个事务在并发情况下，有自己“独立”的执行空间，不受其他事务影响。\",\"持久性： 事务提交后对数据的修改是永久性的，不应受系统影响。\"]},\"165\":{\"h\":\"并发事务带来的问题\",\"t\":[\"脏写： 当两个或多个事务同时选定了一条数据进行更新，由于不知道其他事务的存在，都是基于最初查询的值进行更新，会导致最后提交的更新覆盖之前提交的更新。\",\"脏读： 当一个事务A对一条数据进行修改，读取到了另一个事务B对该数据未提交的修改，在A事务数据根据之前读取的修改后，事务B进行了回滚，此时A事务的基础数据即是错误数据，不符合一致性要求。\",\"不可重复读： 一个事务按相同查询条件查询数据，不同时间点出现了数据前后不一致情况，即事务A读取一次数据后，事务B修改了该条数据并提交，然后事务A再次读取该条数据时，发现数据被修改和删除了；不符合隔离性要求。\",\"幻读： 一个事务重新读取之前的查询结果，读取到了其他事务插入的满足查询条件的数据，就是幻读，不符合隔离性。\"]},\"166\":{\"h\":\"数据库锁分类\",\"t\":[\"锁是计算机协调多个线程或进程并发访问同一资源的机制，\",\"数据库中，除了计算传统的资源(CPU、RAM、I/O)外，数据库内数据也是一种资源，会面临多个事务并发访问或修改同一条数据的问题。如何保证数据在并发情况下的一致性，有效性，是所有数据库需要解决的一个问题。锁冲突也是影响并发效率的一个方面。\"]},\"167\":{\"h\":\"锁分类\",\"t\":[\"从性能上分为乐观锁(用版本比对)和悲观锁；\",\"从对数据库的操作上分为读锁和写锁\",\"读锁：针对同一份数据，多个读之间不影响，该session的写操作会报错，其余session的写操作会阻塞。 select * from dual lock in share mode;\",\"写锁： 当前的写操作没有执行完，不释放锁，其他session的写操作和读操作会阻塞。 slelect * from dual for update;\",\"从对数据的操作粒度上分为表锁和行锁\",\"表锁： 每次操作锁住整张表。开销小，加锁快；锁定颗粒度大，锁冲突概率高，几乎不会出现并发问题。一般用于整表数据迁移场景。\"]},\"168\":{\"h\":\"表锁\",\"t\":[\"对某一个表加表锁：lock table 表名 read/write;\",\"​​\",\"查看表状态：show open tables;\",\"​​\"]},\"169\":{\"h\":\"添加读锁的情况\",\"t\":[\"对表添加读锁后，当前session更新数据会报错\",\"​​\",\"此时，因为加的是读锁，当前session和其他session均可以读出数据\",\"​​\",\"其余session修改会阻塞\",\"​​\",\"当释放锁后其余session语句会继续执行\",\"​​\",\"​​\"]},\"170\":{\"h\":\"添加写锁情况\",\"t\":[\"添加写锁后，自己可正常读取，可正常修改\",\"​​​​\",\"其他session读取会阻塞\",\"​​\",\"释放后其余session可以读取到。\",\"​​\",\"​​\",\"结论：\",\"对MyISAM表的读操作(加读锁) ,不会阻塞其他进程对同一表的读请求,但会阻塞对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。\",\"对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作\"]},\"171\":{\"h\":\"行锁\",\"t\":[\"每次操作对某行数据进行加锁，加锁开销大，加锁慢，会出现死锁情况，锁定颗粒度小，发生锁冲突的概率低，并发能力高。InnoDB支持事务及行级锁\"]},\"172\":{\"h\":\"事务的隔离级别\",\"t\":[\"隔离级别\",\"脏读\",\"不可重复读\",\"幻读\",\"读未提交read-uncommitted\",\"可能出现\",\"可能出现\",\"可能出现\",\"读已提交reda-committed\",\"不可能出现\",\"可能出现\",\"可能出现\",\"可重复读repeatable-read\",\"不可能出现\",\"不可能出现\",\"可能出现\",\"串行化serializable\",\"不可能出现\",\"不可能出现\",\"不可能出现\",\"数据库事务隔离级别越严格，并发影响的越小，当代价也越高 查看数据库事务隔离级别的语句：show variables like 'tx_isolation'; 设置数据库事务隔离级别的语句：set tx_isolaticton='read-uncommitted' mysql8的关键字为： transaction_isolation\"]},\"173\":{\"h\":\"读未提交\",\"t\":[\"set transaction_isolation='read-uncommitted'; \",\"1、打开客户端A，设置隔离级别为读未提交 2、打开客户端B，设置隔离级别为读未提交 3、在客户端B中，修改lilei的balances-50但不提交，并在A中查询，显示减少了50 4、在A客户端中，在B客户端修改了数据后，再次进行数据计算，balance-50，此时事务被阻塞，说明B事务在更新数据时添加了行级锁 5、此时B进行了回滚后，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据。此时A如果再进行balance-50，其值也是400，因为数据库会拿真实数据进行计算。\"]},\"174\":{\"h\":\"读已提交\",\"t\":[\"set transaction_isolation='read-committed'; \",\"1、客户端A设置隔离模式为读已提交，此时A开启事务，正常读取数据 2、客户端B设置隔离模式为读已提交，此时B开启事务，此时B更新相同数据不提交。 3、客户端A再次查询数据，数据不变，解决了脏读问题。 4、客户端B提交事务。此时客户端A再查一次，查询到客户端B修改的数据，没有满足可重复读要求，对代码编写有很大影响。\"]},\"175\":{\"h\":\"可重复读\",\"t\":[\"set transaction_isolation='repeatable-read'; \",\"1、客户端A设置隔离模式为可重复读，此时A开启事务，正常读取数据。 2、客户端B设置隔离模式为可重复读，此时B开启事务，修改一条数据不提交。 3、客户端A再次查询数据，数据不变，解决了脏读问题。 4、客户端B提交事务。此时客户端A再查一次，查询到仍为第一次查询的数据(mysql通过MVCC机制读取历史版本)，解决了不可重复读问题。 5、如果事务A需要修改数据，需要考虑其他事务修改的情况。\"]},\"176\":{\"h\":\"\",\"t\":[\"set transaction_isolation='serializable'; \",\"1、客户端A设置隔离模式为串行化，此时A开启事务，正常读取数据。 2、客户端B设置隔离模式为串行化，此时B可以正常读取数据，但修改A正读取的数据时，会阻塞。 3、当客户端A提交事务后，其余事务才可以继续操作数据。\"]},\"177\":{\"h\":\"\",\"t\":[\"间隙锁，锁的就是两个值之间的空隙。Mysql默认级别是repeatable-read，有办法解决幻读问题吗？间隙锁在某些情况下可以解决幻读问题。间隙锁是在可重复读隔离级别下才会生效。\",\"​​\",\"在Session_1下面执行 update account set name = 'zhuge' where id > 8 and id <18;，则其他Session没法在这个范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙里插入或修改任何数据，即id在(3,20]区间都无法修改数据，注意最后那个20也是包含在内的。\"]},\"178\":{\"h\":\"临键锁(Next-key Locks)\",\"t\":[\"临键锁是行锁与间隙锁的组合。像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。其实主要是最后那个20。\\\\n 无索引行锁会升级为表锁(RR级别会升级为表锁，RC级别不会升级为表锁) 因为锁主要加在索引上，如果更新条件为非索引字段，在可重复读的隔离级别下，行锁可能会升级为表锁。\",\"InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。\"]},\"179\":{\"h\":\"结论\",\"t\":[\"​Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和MYISAM相比就会有比较明显的优势了。\",\"但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。\"]},\"180\":{\"h\":\"锁分析\"},\"181\":{\"h\":\"1、通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况\",\"t\":[\"show status like 'innodb_row_lock%'; \",\"对各个状态量的说明如下：\",\"Innodb_row_lock_current_waits: 当前正在等待锁定的数量\",\"Innodb_row_lock_time: 从系统启动到现在锁定总时间长度\",\"Innodb_row_lock_time_avg: 每次等待所花平均时间\",\"Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间\",\"Innodb_row_lock_waits: 系统启动后到现在总共等待的次数\",\"当等待次数很高，且等待所花平均时间较长时，需要分析为什么有这么多等待，然后根据分析结果进行优化。\"]},\"182\":{\"h\":\"2、查看infomation_schema库中锁相关表\",\"t\":[\"-- 查看事务 select * from INFORMATION_SCHEMA.INNODB_TRX; -- 查看锁 select * from INFORMATION_SCHEMA.INNODB_LOCKS; -- 8.0查看锁 select * from `performance_schema`.data_locks -- 查看锁等待 select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS; -- 8.0查看锁等待 select * from `performance_schema`.data_lock_waits; -- 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到 kill trx_mysql_thread_id -- 查看锁等待详细信息 show engine innodb status\\\\G; \"]},\"183\":{\"h\":\"\",\"t\":[\"A:select * from account for update; B:select * from actor for update; A:select * from actor for update; B:select * from account for update; \",\"​​\",\"最后可以看到mysql会自动检测出死锁的情况，并回滚产生死锁的那个事务，但有些情况数据库没法检测到。\"]},\"184\":{\"h\":\"\",\"t\":[\"更新时尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。\",\"合理设计索引，尽量缩小锁的范围。\",\"尽可能减少检索条件范围，避免间隙锁。\",\"尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行。\",\"尽可能低级别事务隔离。\"]},\"185\":{\"c\":[\"Mysql\"]},\"186\":{\"h\":\"05-理解MVCC与BufferPool\"},\"187\":{\"h\":\"MVCC多版本控制机制\",\"t\":[\"MySql在可重复读的事务隔离机制下，如何保证事务较高的隔离级别，同样的查询语句在一个事务里如何做到查询相同的结果的，就算有其他事务对数据进行修改也不影响该事务内的查询结果。 这个隔离性就是靠着MVCC(Multi-Version Concurrency Control) 机制来保证的，对同一行数据的读默认不加互斥锁来保证隔离性，避免的频繁加锁解锁带来的性能问题。MySql默认在可重复读和读已提交的事务隔离情况下都实现了MVCC\"]},\"188\":{\"h\":\"undo日志版本链和read-veiw机制\",\"t\":[\"undo日志版本链是指一行数据被多个事务修改，在每个事务修改完之后，mysql会保留本次修改的数据到undo回滚日志，并且用两个字段trx_id和roll_pointer来记录本次修改的事务id和回滚的指针，其中回滚的指针指向修改前的数据。这样undo日志链可以将数据串联成一个历史版本链\",\"​​\",\"一个事务开启后，当执行第一条sql语句时会生成read-view(一致性视图) ，该视图在事务结束前都不会改变(读已提交的隔离级别则在每次执行查询语句的时候重新生成read-view)\",\"read-view由生成时仍在活跃的事务id(未提交的事务id)数组，和已创建的最大的事务id组成，其中未提交事务数组中最小的事务id为min_trx_ids，已创建的最大事务id为max_trx_ids，事务里的任何sql查询，都需要从undo日志链中的最新数据开始，逐一与read-view做比较，以得到最终结果。\"]},\"189\":{\"h\":\"比对方式\",\"t\":[\"事务的sql查询时，会先从undo日志链中获取最新的一条数据，读取trx_id，然后与read-view比较：\",\"当 trx_id < min_trx_ids时，表明该数据最后修改的事务id比生成的read-view中最小的事务id还小，表示是已经提交过的事务，数据可以展示。\",\"当 trx_id > max_trx_ids时，表明该数据最后修改的事务id比生成read-veiw时最大的事务id还大，表示这是未来事务提交的数据，数据不可展示。\",\"当 min_trx_ids ≤ trx_id ≤ max_trx_ids 时，表明该数据落入read-veiw视图中，需进一步判断：\",\"当trx_id在read-veiw的活跃事务数组中时，则表明提交该数据的事务在生成视图时仍在活跃，数据不可以展示(当trx_id和当前事务id一致时，则表明是该事务提交的数据，此时可以展示)。\",\"当trx_id不在read-veiw的活跃事务数组中时，则表明提交该数据的事务在生成视图时已经提交，数据可以展示。\",\"所有不可展示的条件，会再根据roll_pointer查找到上一个版本的数据，再根据规则进行比较，直到查找到可以展示的数据。\",\"注意：begin/start transaction并不是一个事务的起点，这个时候mysql还没有分配事务id，只有当执行了修改innodb表的语句时，才真正启动事务，向mysql申请事务id，mysql内部是严格按照启动顺序来分配事务id的。\"]},\"190\":{\"h\":\"\",\"t\":[\"​​\",\"更新前，mysql会根据索引查找到相应数据，并将该数据所在的页，加载到BufferPool中；\",\"更新前，mysql将更新数据的旧值写入undo日志，便于回滚；\",\"mysql将BufferPool中的数据进行更新；\",\"事务准备提交时，mysql将更新后数据写入readLog日志缓存中，readLog日志主要作用是在mysql启动时，恢复BufferPool中数据，保证数据一致性；\",\"mysql将readLog日志缓存刷入磁盘；\",\"事务准备提交时，mysql将更新后数据写入binlog日志，以便于恢复磁盘数据；\",\"事务提交后，更新完binlog日志后，向readLog日志写入commit标志，保证readLog与binlog日志一致。\",\"BufferPool的磁盘I/O会不定时将BufferPool中数据刷入磁盘相应数据。\"]},\"191\":{\"h\":\"设计原因\",\"t\":[\"因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据，性能可能相当差。磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。\\nMysql这套机制看起来复杂，但它可以保证每个更新请求都是更新内存BufferPool，然后顺序写日志文件，同时还能保证各种异常情况下的数据一致性。\\n更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干甚至上万的读写请求。\"]},\"192\":{\"c\":[\"Mysql\"]},\"193\":{\"h\":\"06-Innodb原理与Mysql日志机制\"},\"194\":{\"h\":\"Mysql 内部结构\",\"t\":[\"总体来说，mysql 服务端分为 Service 层和引擎层，其中 Service 层包括连接器、查询缓存、词法分析器、优化器、执行器等功能；引擎层主要包括各种执行引擎，如 Innodb、Myisam 等主要从磁盘读写数据的引擎。\",\"​​\"]},\"195\":{\"h\":\"Service 层\",\"t\":[\"主要包括连接器、连接器、查询缓存、词法分析器、优化器、执行器等，同时内置函数(如时间、日期、数学和加密函数等)，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。\"]},\"196\":{\"h\":\"连接器\",\"t\":[\"当 mysql 的客户端发起链接请求时，就由连接器进行处理，它提供链接建立、权限认证、维持并管理链接等功能。当链接一个 mysql 数据库的时候，一般会用以下命令链接\",\"[root@192 ~]# mysql -h host[数据库地址] -u root[用户] -p root[密码] -P 3306 \",\"链接命令中使用的时 mysql 提供的客户端，-h 参数是链接数据库的 ip 地址，-P 参数是链接数据库的端口。客户端在与 mysql 服务端完成 TCP 握手后，使用用户和密码进行验证，服务端会出现以下情况\",\"用户名或密码错误，服务端验证不通过，会返回\\\"Access denied for user\\\"，客户端会结束程序执行。\",\"用户名和密码正确，服务端查询用户权限表，查询当前登录用户所拥有的表及服务器权限，然后缓存起来，之后该链接的所有权限会从缓存中获取。因此，当管理员修改了用户权限后，已经建立过链接的也不会受到影响，只有再次建立连接，修改后的权限才会生效。\"]},\"197\":{\"h\":\"查询缓存\",\"t\":[\"连接建立完成后，就可以执行 sql 了，这就进入了 service 层的第二步：查询缓存。\",\"当 mysql 拿到一个查询 sql 时，会先查询缓存中是否存在相同的 sql，也就是之前执行过相同的 sql，如果有，就会从缓存中获取数据进行返回。之前执行的 sql 的结果会以 key-value 方式存储在内存中，key 是执行的 sql，value 为 sql 的结果。如果缓存中没有对应的结果，那么就会继续执行后续的阶段，当从硬盘中查询出结果后，将结果存储在缓存中。\",\"从执行步骤可以看出，如果能从缓存中获取到查询结果，可以省略后续查询硬盘等步骤，查询效率会非常高。\",\"但一般而言，查询缓存比较鸡肋，因为只要更新过表中的值，那么缓存中对应的表的缓存全部会失效，在一般的业务场景下，缓存失效的非常快。因此很可能查询刚建立缓存，然后就被更新失效掉了，对于更新频繁的系统来说，缓存的命中会非常低。\",\"因此，一般建议大家在静态表中使用缓存，比如不常修改的字典表，系统表等。mysql 也提供按需使用。可以将 my.cnf 参数 query_cache_type ​设置成 DEMAND\",\"my.cnf #query_cache_type有3个值 0代表关闭查询缓存OFF，1代表开启ON，2（DEMAND）代表当sql语句中有SQL_CACHE关键词时才缓存 query_cache_type=2 \",\"这样，对于一般的 sql 语句不开启查询缓存，当有需要时，可显式的指定查询缓存\",\"select SQL_CACHE * from test where id=1; \",\"查看当前 mysql 实例是否开启缓存\",\"show global variables like \\\"%query_cache_type&\\\"; \",\"mysql8.0 移除了查询缓存功能\"]},\"198\":{\"h\":\"词法分析器\",\"t\":[\"当没有命中缓存或设置了按需开启且查询 sql 中没有关键字时，就需要真正执行 sql 了，这时 mysql 需要知道你想要怎么做，就需要分析传过来的 sql，对 sql 进行词法、语法分析。\",\"分析器会先做\\\"词法分析\\\"。mysql 会先做词法分析，分析你发送过来的 sql 是什么，比如识别 select，那就知道是需要进行查询，将 from 后的单词识别为表名，将 where 后面的字符串识别为列名等等。\",\"做完了这些识别后，还需要进行语法识别。mysql 会根据语法规则分析传入的语句是否满足 mysql 的语法。比如下面这句因为将 from 关键字写错，就收到\\\"You have an error in your SQL syntax\\\"的报错。\",\"select * fro user_info; \",\"分析器对 sql 分析的过程\",\"​​\",\"当分析器分析过后，会生成这样一个语法树\",\"​​\",\"至此，词法分析器将语句分析完成，将进入优化器\"]},\"199\":{\"h\":\"优化器\",\"t\":[\"经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。\",\"优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序；以及一些 mysql 自己内部的优化机制。\"]},\"200\":{\"h\":\"执行器\",\"t\":[\"开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证)。\",\"select * from test where id=10; \",\"如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。\"]},\"201\":{\"h\":\"引擎层\",\"t\":[\"引擎层负责数据的存储和提取其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说如果我们在 create table 时不指定表的存储引擎类型,默认会给你设置存储引擎为 InnoDB。\"]},\"202\":{\"h\":\"Innodb 底层原理与 Mysql 日志机制\",\"t\":[\"​​\",\"更新前，mysql 会根据索引查找到相应数据，并将该数据所在的页，加载到 BufferPool 中；\",\"更新前，mysql 将更新数据的旧值写入 undo 日志，便于回滚；\",\"mysql 将 BufferPool 中的数据进行更新；\",\"事务准备提交时，mysql 将更新后数据写入 redo log 日志缓存中，redo log 日志主要作用是在 mysql 启动时，恢复 BufferPool 中数据，保证数据一致性；\",\"mysql 将 readLog 日志缓存刷入磁盘；\",\"事务准备提交时，mysql 将更新后数据写入 binlog 日志，以便于恢复磁盘数据；\",\"事务提交后，更新完 binlog 日志后，向 readLog 日志写入 commit 标志，保证 readLog 与 binlog 日志一致。\",\"BufferPool 的磁盘 I/O 会不定时将 BufferPool 中数据刷入磁盘相应数据。\"]},\"203\":{\"h\":\"设计原因\",\"t\":[\"因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。\",\"Mysql 这套机制看起来复杂，但它可以保证每个更新请求都是更新内存 BufferPool，然后顺序写日志文件，同时还能保证各种异常情况下的数据一致性。\",\"更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。正是通过这套机制，才能让我们的 MySQL 数据库在较高配置的机器上每秒可以抗下几干甚至上万的读写请求。\"]},\"204\":{\"h\":\"redo log 重做日志关键参数\",\"t\":[\"​innodb_log_buffer_size​:设置 redo log buffer 大小参数，默认 16M ，最大值是 4096M，最小值为 1M。\",\"show variables like '%innodb_log_buffer_size%'; \",\"​innodb_log_group_home_dir​：设置 redo log 文件存储位置参数，默认值为\\\"./\\\"，即 innodb 数据文件存储位置，其中的 ib_logfile0 和 ib_logfile1 即为 redo log 文件。\",\"show variables like '%innodb_log_group_home_dir%'; \",\"​​\",\"​innodb_log_files_in_group​：设置 redo log 文件的个数，命名方式如: ib_logfile0, iblogfile1... iblogfileN。默认 2 个，最大 100 个。\",\"show variables like '%innodb_log_files_in_group%'; \",\"​innodb_log_file_size​：设置单个 redo log 文件大小，默认值为 48M。最大值为 512G，注意最大值指的是整个 redo log 系列文件之和，即(innodb_log_files_in_group * innodb_log_file_size)不能大于最大值 512G。\",\"show variables like '%innodb_log_file_size%'; \"]},\"205\":{\"h\":\"redo log 写入磁盘过程分析\",\"t\":[\"以两个文件为例子，redo log 从文件头开始顺序写日志，写完第一个文件的结尾，转到第二个文件的头部开始。当写到第二个文件的结尾时，再转到第一个文件开头开始循环写。\",\"​​\",\"write pos：当前记录位置，写日志时向后移动，当移动到 3 文件的结尾时，转到 0 文件的开头。\",\"check point：当前要擦除的位置，也是向后移动循环使用，在擦除前需要将内容刷到磁盘中。\",\"write pos 和 check point 中间就是可写区域，记录 bufferPool 更新操作日志，当 write pos 追上 check point 时代表文件无可写入内容，此时不能执行更新操作，需要等待内容刷新到硬盘，check point 推进后才可以继续执行更新。\",\"​innodb_flush_log_at_trx_commit​：这个参数控制 redo log 的写入策略，有三种可能取值：\",\"0-表示每次提交事务，都将 redo log 留在 redo log buffer 中，此时如果 mysql 宕机，会丢失数据\",\"1(默认)-表示每次提交事务，都将 redo log 直接持久化到硬盘，数据最安全，不会因为服务宕机而丢失数据但效率会差一些，线上系统推荐使用这个值\",\"2-表示每次提交事务，都将 redo log 写到操作系统的 page cache 里，由操作系统决定什么时候持久化到硬盘，这种不会因为服务宕机而丢失数据，但是操作系统如果宕机了，page cache 里的数据还没来得及写入磁盘文件的话就会丢失数据\",\"InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 操作系统函数 write 写到文件系统的 page cache，然后调用操作系统函数 fsync 持久化到磁盘文件。\",\"​​\",\"# 查看innodb_flush_log_at_trx_commit参数值： show variables like 'innodb_flush_log_at_trx_commit'; # 设置innodb_flush_log_at_trx_commit参数值(也可以在my.ini或my.cnf文件里配置)： set global innodb_flush_log_at_trx_commit=1; \"]},\"206\":{\"h\":\"BinLog二进制归档日志\",\"t\":[\"binlog保存了所有修改操作，不保存查询操作，如果mysql服务意外停止，可通过二进制文件排查，用户操作和表结构操作，可以用来恢复硬盘上的数据库数据。\",\"启用binlog会影响服务器性能，但如果需要恢复数据或主从复制，好处大于下降的这些性能！\",\"# 查看binlog相关参数 show variables like '%log_bin%'; \",\"mysql8.0默认开启了biglog，在mysql5.7版本中默认是关闭状态\",\"​​\",\"打开binlog功能，需要修改配置文件my.ini(windows)或my.cnf(linux)，然后重启数据库\",\"# log-bin设置binlog的存放位置，可以是绝对路径，也可以是相对路径，这里写的相对路径，则binlog文件默认会放在data数据目录下 log-bin=mysql-nbinlog # Server Id是数据库服务器id，随便写一个数都可以，这个id用来在mysql集群环境中标记唯一mysql服务器，集群环境中每台mysql服务器的id不能一样，不加启动会报错 server-id=1 # 其他配置 binlog_format = row # 日志文件格式 expire_logs_days = 15 # 执行自动删除距离当前15天以前的binlog日志文件的天数， 默认为0， 表示不自动删除 max_binlog_size = 200M # 单个binlog日志文件的大小限制，默认为 1GB \",\"‍\"]},\"207\":{\"c\":[\"Mysql\"]},\"208\":{\"h\":\"07-表结构及索引设计\"},\"209\":{\"h\":\"数据库表设计-范式化\",\"t\":[\"范式来自英文Normal Form，简称NF。MySQL是关系型数据库，但是要想设计—个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求得严格。满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(insert)、删除(delete)和更新(update)操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。\",\"目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。\"]},\"210\":{\"h\":\"第一范式\",\"t\":[\"定义：属于第一范式关系的所有属性都不可再分，即数据项不可分。\",\"如：\",\"id\",\"name-age\",\"1\",\"张三-18\",\"name-age不符合第一范式，可将其拆分\",\"id\",\"name\",\"age\",\"1\",\"张三\",\"18\"]},\"211\":{\"h\":\"第二范式\",\"t\":[\"定义：第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。通常在实现来说，需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。通俗来说，表中数据需要主键或唯一索引。\"]},\"212\":{\"h\":\"第三范式\",\"t\":[\"定义：指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主键对主键的传递依赖。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。通俗来说就是个需要关联关系表将相关信息进行关联\"]},\"213\":{\"h\":\"反范式化设计\",\"t\":[\"完全符合范式化的设计真的完美无缺吗？很明显在实际的业务查询中会大量存在着表的关联查询，而大量的表关联很多的时候非常影响查询的性能。 所谓得反范式化就是为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反。允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间。\"]},\"214\":{\"h\":\"总结\"},\"215\":{\"h\":\"范式化设计的优缺点\"},\"216\":{\"h\":\"优点\",\"t\":[\"范式化设计的表结构，更新操作会比反范式化快。\",\"范式化设计的表结构，存储空间比反范式化小。\",\"范式化设计的表，数据冗余较小，若出现需要修改的情况，修改位置，修改数据量较小，通常只修改一处即可。\",\"很少有多余的数据，在检索列表时，可以更少的使用distinct和order by\"]},\"217\":{\"h\":\"缺点\",\"t\":[\"范式化设计的表通常需要连表查询才能得到所有结果。稍微复杂一点的查询语句，可能需要关联多张表，此时查询语句执行效率变低，也可能会导致一些表索引失效。\"]},\"218\":{\"h\":\"反范式化设计的优缺点\"},\"219\":{\"h\":\"优点\",\"t\":[\"反范式化设计，可以减少表的关联。\",\"可以更好的进行索引优化。\"]},\"220\":{\"h\":\"缺点\",\"t\":[\"数据冗余，维护成本变高，可能会出现数据错误或不一致情况。\",\"对数据修改需要考虑的地方更多\"]},\"221\":{\"h\":\"实际工作中的反范式化\"},\"222\":{\"h\":\"1.缓存和汇总\",\"t\":[\"最常见的反范式化方法是对数据进行缓存，在不同的表中存储特定的列，将本来需要连表查询的语句，通过表结构，改为单表查询。 汇总也是一种反范式化方式，将经常需要用到的汇总且结果不变的数据，存入一张表中，每天只做一次加工后，后续查询既可不用加工数据。此种方式常见于报表等情况。 在使用缓存表和汇总表时，有个关键点是如何维护缓存表和汇总表中的数据，常用的有两种方式，实时维护数据和定期重建，这个取决于应用程序，不过一般来说，缓存表用实时维护数据更多点，往往在一个事务中同时更新数据本表和缓存表，汇总表则用定期重建更多，使用定时任务对汇总表进行更新。\"]},\"223\":{\"h\":\"2.计数器表\",\"t\":[\"计数器表在Web应用中很常见。比如网站点击数、用户的朋友数、文件下载次数等。对于高并发下的处理，首先可以创建一张独立的表存储计数器，这样可使计数器表小且快，并且可以使用一些更高级的技巧。\",\"比如假设有一个计数器表，只有一行数据，记录网站的点击次数，网站的每次点击都会导致对计数器进行更新，问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁(mutex)。这会使得这些事务只能串行执行，会严重限制系统的并发能力。\",\"可以将计数器保存在多行中，每次随机选择一行进行更新。在具体实现上，可以增加一个槽（slot)字段，然后预先在这张表增加100行或者更多数据，当对计数器更新时，选择一个随机的槽（slot)进行更新即可。\",\"这种解决思路其实就是写热点的分散，在JDK的JDK1.8中新的原子类LongAdder也是这种处理方式，而我们在实际的缓冲中间件Redis等的使用、架构设计中，可以采用这种写热点的分散的方式，当然架构设计中对于写热点还有削峰填谷的处理方式，这种在MySQL的实现中也有体现。\",\"其实还有一种方式是这类计数器类更新操作可以在程序中用线程实现，将计数类操作与业务解耦，实现更好的业务体验。\"]},\"224\":{\"h\":\"3.字段类型优化\",\"t\":[\"02-Mysql索引优化一\",\"03-Mysql索引优化二\"]},\"225\":{\"h\":\"4.mysql索引\"},\"226\":{\"h\":\"按结构分\",\"t\":[\"B+树索引\",\"哈希索引\",\"FULLTEXT(全文索引，现在innodb也支持了)\"]},\"227\":{\"h\":\"按物理角度分\",\"t\":[\"聚集索引\",\"非聚集索引\"]},\"228\":{\"h\":\"MRR\",\"t\":[\"每次从二级索引/非聚簇索引中读取到一条记录后，就会根据该记录的主键值执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机IO带来的性能开销比较大。MySQL中提出了一个名为Disk-SweepMulti-RangeRead(MRR，多范围读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执行回表操作。相对于每读取一条二级索引记录就立即执行回表操作，这样会节省一些IO开销。使用这个MRR优化措施的条件比较苛刻，所以我们直接认为每读取一条二级索引记录就立即执行回表操作。MRR的详细信息，可以查询官方文档。\"]},\"229\":{\"h\":\"如何创建高性能索引\"},\"230\":{\"h\":\"\",\"t\":[\"在定义列时，需要指定列的类型，比如tinyint、int、bigint所占空间是依次增大的，我们要表示的数据类型大小是可以根据业务推断出来的，在选择列类型时，尽量在满足业务要求的条件下，选择占用空间小的类型，这样的列在做索引时，每个索引页可存储的数据就更多，减少了索引I/O读取带来的消耗。\"]},\"231\":{\"h\":\"\",\"t\":[\"创建索引时候优先选择离散性强的列。索引离散型指不重复索引的数量与数据总量的比值，这个比值越大越好。当这个比值越大，说明该字段不重复的可能性越大，通过索引筛选出的数据较少，可以过滤掉更多的行。\",\"select count(distinct order_no)/count(*) from order_exp; \"]},\"232\":{\"h\":\"\",\"t\":[\"有的时候需要将很长的字段添加索引，这时不需要将所有长度全部加上索引，否则会让索引变长变慢，因此可以索引该字段的开始部分，这样可以节约索引空间，提高索引效率\",\"SELECT COUNT( DISTINCT LEFT ( order_note, 3 ))/ COUNT(*) AS sel3, COUNT( DISTINCT LEFT ( order_note, 4 ))/ COUNT(*) AS sel4, COUNT( DISTINCT LEFT ( order_note, 5 ))/ COUNT(*) AS sel5, COUNT( DISTINCT LEFT ( order_note, 6 ))/ COUNT(*) AS sel6, COUNT( DISTINCT LEFT ( order_note, 7 ))/ COUNT(*) AS sel7, COUNT( DISTINCT LEFT ( order_note, 8 ))/ COUNT(*) AS sel8, COUNT( DISTINCT LEFT ( order_note, 9 ))/ COUNT(*) AS sel9, COUNT( DISTINCT LEFT ( order_note, 10 ))/ COUNT(*) AS sel10, COUNT( DISTINCT LEFT ( order_note, 11 ))/ COUNT(*) AS sel11, COUNT( DISTINCT LEFT ( order_note, 12 ))/ COUNT(*) AS sel12, COUNT( DISTINCT LEFT ( order_note, 13 ))/ COUNT(*) AS sel13, COUNT( DISTINCT LEFT ( order_note, 14 ))/ COUNT(*) AS sel14, COUNT( DISTINCT LEFT ( order_note, 15 ))/ COUNT(*) AS sel15, COUNT( DISTINCT order_note )/ COUNT(*) AS total FROM order_exp; \",\"在阿里的编码规范中，长字段做索引时，建议用字段的前20位作为索引，但根据经验，一般13-15个字符长度即可\",\"ALTER TABLE order_exp ADD KEY (order_note(14)); \"]},\"233\":{\"h\":\"\",\"t\":[\"即为where、order by、group by后面的条件列创建索引，出现在查询列表中的列可不建立索引，除非是为了进行索引覆盖。order by和group by的顺序，需要和索引建立的顺序一致，才能使用索引。例如，一个表的索引是(name,age,sex)，则order by name,age,sex;语句可以利用索引在建立时的排序，直接从索引中读取主键信息，回表查询其余列，而order by age,sex,name;语句则不能利用索引，需要在内存中重新排序后才能查询出需要的数据。group by同理。\"]},\"234\":{\"h\":\"\",\"t\":[\"索引将所有记录放到一起获得一星；\",\"如果索引中的顺序和查询的排序顺序一致，获得二星；\",\"索引中的列包含了查询中所需要的列，获得三星。\",\"其中，三星一般是最重要的，二星和一星重要性相差不大。\"]},\"235\":{\"h\":\"\",\"t\":[\"主键在设计时，尽量不要频繁update，当需要updat主键时，已经平衡的页需要频繁的分裂和合并，会严重影响性能。\"]},\"236\":{\"c\":[\"Mysql\"]},\"237\":{\"h\":\"Using filesort文件排序原理\"},\"238\":{\"h\":\"filesort文件排序方式\",\"t\":[\"单路排序： 是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可以看到sort_mode信息里显示< sort_key, additional_fields >或者< sort_key, packed_additional_fields >\",\"双路排序（又叫回表​排序模式）： 是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具可以看到sort_mode信息里显示< sort_key, rowid >\",\"MySQL 通过比较系统变量 max_length_for_sort_data(默认1024字节) 的大小和需要查询的字段总大小来判断使用哪种排序模式。\",\"如果字段的总长度小于max_length_for_sort_data，那么使用单路排序模式；\",\"如果字段的总长度大于max_length_for_sort_data，那么使用双路排序模式；\"]},\"239\":{\"h\":\"\",\"t\":[\"从索引name找到第一个满足 name = ‘zhuge’ 条件的主键 id\",\"根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中\",\"从索引name找到下一个满足 name = ‘zhuge’ 条件的主键 id\",\"重复步骤 2、3 直到不满足 name = ‘zhuge’\",\"对 sort_buffer 中的数据按照字段 position 进行排序\",\"返回结果给客户端\"]},\"240\":{\"h\":\"\",\"t\":[\"从索引 name 找到第一个满足 name = ‘zhuge’ 的主键id\",\"根据主键 id 取出整行，把排序字段 position 和主键 id 这两个字段放到 sort buffer 中\",\"从索引 name 取下一个满足 name = ‘zhuge’ 记录的主键 id\",\"重复 3、4 直到不满足 name = ‘zhuge’\",\"对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序\",\"遍历排序好的 id 和字段 position，按照 id 的值回到原表中取出所有字段的值返回给客户端\",\"其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。\",\"如果 MySQL 排序内存(sort buffer)配置的比较小并且没有条件继续增加了，可以适当把 max_length_for_sort_data 配置小点，让优化器选择使用双路排序算法，可以在sort_buffer 中一次排序更多的行，只是需要再根据主键回到原表取数据。\",\"如果 MySQL 排序内存(sort buffer)有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择全字段排序(单路排序)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。\",\"所以，MySQL通过 max_length_for_sort_data 这个参数来控制排序，在不同场景使用不同的排序模式，从而提升排序效率。\",\"注意： 虽然全部使用sort_buffer内存排序一般情况下效率会高于磁盘文件排序，但不能因为这个就随便增大sort_buffer(默认1M)，mysql很多参数设置都是做过优化的，不建议轻易调整。\",\"‍\"]},\"241\":{\"c\":[\"Mysql\"]},\"242\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"243\":{\"h\":\"JVM\"},\"244\":{\"h\":\"Statudy\"},\"245\":{\"h\":\"Mysql\"}},\"dirtCount\":0,\"index\":[[\"配置小点\",{\"1\":{\"240\":1}}],[\"配置的比较小并且没有条件继续增加了\",{\"1\":{\"240\":1}}],[\"配合工作\",{\"1\":{\"38\":1}}],[\"排序内存\",{\"1\":{\"240\":2}}],[\"排序完后需要再次取回其它需要的字段\",{\"1\":{\"238\":1}}],[\"遍历排序好的\",{\"1\":{\"240\":1}}],[\"遍历方式可以是广度\",{\"1\":{\"47\":1}}],[\"返回结果给客户端\",{\"1\":{\"239\":1}}],[\"返回满足join条件的数据\",{\"1\":{\"149\":1}}],[\"条件的主键\",{\"1\":{\"239\":2}}],[\"条件处理\",{\"1\":{\"129\":1}}],[\"双路排序\",{\"1\":{\"238\":1}}],[\"获得三星\",{\"1\":{\"234\":1}}],[\"获得二星\",{\"1\":{\"234\":1}}],[\"获取旧值\",{\"1\":{\"45\":1}}],[\"除非是为了进行索引覆盖\",{\"1\":{\"233\":1}}],[\"除了计算传统的资源\",{\"1\":{\"166\":1}}],[\"除了追求低停顿外\",{\"1\":{\"52\":1}}],[\"除了\",{\"1\":{\"38\":1}}],[\"除了使用多线程进行垃圾收集外\",{\"1\":{\"37\":1}}],[\"除了对象obja\",{\"1\":{\"25\":1}}],[\"除了可以让对象的成员变量在栈上分配和读写之外\",{\"1\":{\"10\":1}}],[\"除了第2层的统计信息外\",{\"1\":{\"7\":1}}],[\"创建索引时候优先选择离散性强的列\",{\"1\":{\"231\":1}}],[\"全文索引\",{\"1\":{\"226\":1}}],[\"全表扫描的成本低于索引扫描\",{\"1\":{\"129\":1}}],[\"全表扫描\",{\"1\":{\"129\":1,\"148\":1}}],[\"全表扫描情况\",{\"1\":{\"129\":1}}],[\"哈希索引\",{\"1\":{\"226\":1}}],[\"架构设计中\",{\"1\":{\"223\":1}}],[\"问题在于\",{\"1\":{\"223\":1}}],[\"问我的时候拉出来了堆内信息\",{\"1\":{\"69\":1}}],[\"网站的每次点击都会导致对计数器进行更新\",{\"1\":{\"223\":1}}],[\"网上搜索一番后\",{\"1\":{\"69\":1}}],[\"汇总表则用定期重建更多\",{\"1\":{\"222\":1}}],[\"汇总也是一种反范式化方式\",{\"1\":{\"222\":1}}],[\"往往在一个事务中同时更新数据本表和缓存表\",{\"1\":{\"222\":1}}],[\"改为单表查询\",{\"1\":{\"222\":1}}],[\"稍微复杂一点的查询语句\",{\"1\":{\"217\":1}}],[\"缺点\",{\"0\":{\"217\":1,\"220\":1}}],[\"若出现需要修改的情况\",{\"1\":{\"216\":1}}],[\"若在分析结束的阶段\",{\"1\":{\"41\":1}}],[\"换句话来说反范式化就是使用空间来换取时间\",{\"1\":{\"213\":1}}],[\"允许存在少量得冗余\",{\"1\":{\"213\":1}}],[\"部门简介等与部门有关的信息再加入员工信息表中\",{\"1\":{\"212\":1}}],[\"部门简介等信息\",{\"1\":{\"212\":1}}],[\"部门名称\",{\"1\":{\"212\":1}}],[\"部分其他收集器原本需要停顿java线程来执行gc动作\",{\"1\":{\"52\":1}}],[\"列\",{\"1\":{\"211\":1}}],[\"列名\",{\"1\":{\"155\":1}}],[\"张三\",{\"1\":{\"210\":2}}],[\"属于第一范式关系的所有属性都不可再分\",{\"1\":{\"210\":1}}],[\"属性\",{\"1\":{\"103\":1}}],[\"满足最低要求的范式是第一范式\",{\"1\":{\"209\":1}}],[\"满足这些规范的数据库是简洁的\",{\"1\":{\"209\":1}}],[\"又叫回表​排序模式\",{\"1\":{\"238\":1}}],[\"又称完美范式\",{\"1\":{\"209\":1}}],[\"又再次进行混合回收\",{\"1\":{\"57\":1}}],[\"科德范式\",{\"1\":{\"209\":1}}],[\"巴斯\",{\"1\":{\"209\":1}}],[\"操作异常\",{\"1\":{\"209\":1}}],[\"操作系统函数\",{\"1\":{\"205\":1}}],[\"删除\",{\"1\":{\"209\":1}}],[\"简称nf\",{\"1\":{\"209\":1}}],[\"简称c1编译器和c2编译器\",{\"1\":{\"7\":1}}],[\"范式来自英文normal\",{\"1\":{\"209\":1}}],[\"范式化设计的表通常需要连表查询才能得到所有结果\",{\"1\":{\"217\":1}}],[\"范式化设计的表\",{\"1\":{\"216\":1}}],[\"范式化设计的表结构\",{\"1\":{\"216\":2}}],[\"范式化设计的优缺点\",{\"0\":{\"215\":1}}],[\"范式化\",{\"0\":{\"209\":1}}],[\"集群环境中每台mysql服务器的id不能一样\",{\"1\":{\"206\":1}}],[\"随便写一个数都可以\",{\"1\":{\"206\":1}}],[\"好处大于下降的这些性能\",{\"1\":{\"206\":1}}],[\"好空闲出来一批region来供下一次mixedgc使用\",{\"1\":{\"56\":1}}],[\"持久化到磁盘文件\",{\"1\":{\"205\":1}}],[\"持久性\",{\"1\":{\"164\":1}}],[\"秒\",{\"1\":{\"205\":1}}],[\"里的数据还没来得及写入磁盘文件的话就会丢失数据\",{\"1\":{\"205\":1}}],[\"里\",{\"1\":{\"205\":1}}],[\"里面保留两三条记录\",{\"1\":{\"126\":1}}],[\"线上系统推荐使用这个值\",{\"1\":{\"205\":1}}],[\"线程状态\",{\"1\":{\"83\":1}}],[\"线程对应的本地线程标识nid​\",{\"1\":{\"83\":1}}],[\"线程id​\",{\"1\":{\"83\":1}}],[\"线程名\",{\"1\":{\"83\":1}}],[\"线程栈的大小之类的而变化\",{\"1\":{\"61\":1}}],[\"线程栈的本地变量\",{\"1\":{\"26\":1}}],[\"线程持有的锁\",{\"1\":{\"18\":1}}],[\"线程进行回收\",{\"1\":{\"11\":1}}],[\"宕机\",{\"1\":{\"205\":1}}],[\"留在\",{\"1\":{\"205\":1}}],[\"推进后才可以继续执行更新\",{\"1\":{\"205\":1}}],[\"追上\",{\"1\":{\"205\":1}}],[\"转到\",{\"1\":{\"205\":1}}],[\"转到第二个文件的头部开始\",{\"1\":{\"205\":1}}],[\"转换为十六进制得到0x4cd0\",{\"1\":{\"84\":1}}],[\"系列文件之和\",{\"1\":{\"204\":1}}],[\"系统表等\",{\"1\":{\"197\":1}}],[\"系统启动后到现在总共等待的次数\",{\"1\":{\"181\":1}}],[\"系统页\",{\"1\":{\"107\":1}}],[\"系统一边运行\",{\"1\":{\"39\":1}}],[\"命名方式如\",{\"1\":{\"204\":1}}],[\"命令可以计算出如下一些关键数据\",{\"1\":{\"89\":1}}],[\"命令选项\",{\"1\":{\"88\":2}}],[\"命令的格式如下\",{\"1\":{\"88\":1}}],[\"恢复\",{\"1\":{\"202\":1}}],[\"恢复bufferpool中数据\",{\"1\":{\"190\":1}}],[\"日志文件格式\",{\"1\":{\"206\":1}}],[\"日志一致\",{\"1\":{\"202\":1}}],[\"日志写入\",{\"1\":{\"202\":1}}],[\"日志后\",{\"1\":{\"202\":1}}],[\"日志缓存刷入磁盘\",{\"1\":{\"202\":1}}],[\"日志缓存中\",{\"1\":{\"202\":1}}],[\"日志主要作用是在\",{\"1\":{\"202\":1}}],[\"日志\",{\"1\":{\"202\":2}}],[\"日志机制\",{\"0\":{\"202\":1}}],[\"日期\",{\"1\":{\"195\":1}}],[\"版本开始成为了默认存储引擎\",{\"1\":{\"201\":1}}],[\"决定各个表的连接顺序\",{\"1\":{\"199\":1}}],[\"决定使用哪个索引\",{\"1\":{\"199\":1}}],[\"经过了分析器\",{\"1\":{\"199\":1}}],[\"至此\",{\"1\":{\"198\":1}}],[\"至少要经历再次标记过程\",{\"1\":{\"28\":1}}],[\"词法分析\",{\"1\":{\"198\":1}}],[\"词法分析器将语句分析完成\",{\"1\":{\"198\":1}}],[\"词法分析器\",{\"0\":{\"198\":1},\"1\":{\"194\":1,\"195\":1}}],[\"语法分析\",{\"1\":{\"198\":1}}],[\"语句则不能利用索引\",{\"1\":{\"233\":1}}],[\"语句可以利用索引在建立时的排序\",{\"1\":{\"233\":1}}],[\"语句不开启查询缓存\",{\"1\":{\"197\":1}}],[\"语句\",{\"0\":{\"153\":1}}],[\"语句返回结果\",{\"1\":{\"152\":1}}],[\"语句拼接到sql里的\",{\"1\":{\"139\":1}}],[\"语句才会走索引\",{\"1\":{\"118\":1}}],[\"语句只有第一条\",{\"1\":{\"118\":1}}],[\"移除了查询缓存功能\",{\"1\":{\"197\":1}}],[\"移动\",{\"1\":{\"115\":1}}],[\"拿到一个查询\",{\"1\":{\"197\":1}}],[\"拿着过滤完剩下的索引对应的主键id再回表查整行数据\",{\"1\":{\"127\":1}}],[\"连接建立完成后\",{\"1\":{\"197\":1}}],[\"连接器\",{\"0\":{\"196\":1},\"1\":{\"195\":1}}],[\"握手后\",{\"1\":{\"196\":1}}],[\"地址\",{\"1\":{\"196\":1}}],[\"链接命令中使用的时\",{\"1\":{\"196\":1}}],[\"密码\",{\"1\":{\"196\":1}}],[\"~\",{\"1\":{\"196\":1}}],[\"~pliden\",{\"1\":{\"61\":1}}],[\"维护成本变高\",{\"1\":{\"220\":1}}],[\"维护了一个codecache\",{\"1\":{\"5\":1}}],[\"维持并管理链接等功能\",{\"1\":{\"196\":1}}],[\"权限认证\",{\"1\":{\"196\":1}}],[\"视图等\",{\"1\":{\"195\":1}}],[\"触发器\",{\"1\":{\"195\":1}}],[\"层的第二步\",{\"1\":{\"197\":1}}],[\"层\",{\"0\":{\"195\":1}}],[\"层包括连接器\",{\"1\":{\"194\":1}}],[\"层和引擎层\",{\"1\":{\"194\":1}}],[\"磁盘随机读写的性能是非常差的\",{\"1\":{\"191\":1,\"203\":1}}],[\"磁盘管理的最小单位\",{\"1\":{\"107\":1}}],[\"便于回滚\",{\"1\":{\"190\":1,\"202\":1}}],[\"向\",{\"1\":{\"202\":1}}],[\"向readlog日志写入commit标志\",{\"1\":{\"190\":1}}],[\"向mysql申请事务id\",{\"1\":{\"189\":1}}],[\"向该线程的单独区域内进行内存分配\",{\"1\":{\"16\":1}}],[\"≤\",{\"1\":{\"189\":2}}],[\"逐一与read\",{\"1\":{\"188\":1}}],[\"已经平衡的页需要频繁的分裂和合并\",{\"1\":{\"235\":1}}],[\"已经建立过链接的也不会受到影响\",{\"1\":{\"196\":1}}],[\"已经被回收\",{\"1\":{\"29\":1}}],[\"已创建的最大事务id为max\",{\"1\":{\"188\":1}}],[\"未提交的事务id\",{\"1\":{\"188\":1}}],[\"机制来保证的\",{\"1\":{\"187\":1}}],[\"理解mvcc与bufferpool\",{\"0\":{\"186\":1}}],[\"涉及事务加锁的sql尽量放在事务最后执行\",{\"1\":{\"184\":1}}],[\"合理设计索引\",{\"1\":{\"184\":1}}],[\"合并到了下一次垃圾收集循环中的并发标记阶段里去完成\",{\"1\":{\"65\":1}}],[\"释放锁\",{\"1\":{\"182\":1}}],[\"释放后其余session可以读取到\",{\"1\":{\"170\":1}}],[\"像上面那个例子里的这个\",{\"1\":{\"178\":1}}],[\"临键锁是行锁与间隙锁的组合\",{\"1\":{\"178\":1}}],[\"临键锁\",{\"0\":{\"178\":1}}],[\"间隙锁是在可重复读隔离级别下才会生效\",{\"1\":{\"177\":1}}],[\"间隙锁在某些情况下可以解决幻读问题\",{\"1\":{\"177\":1}}],[\"间隙锁\",{\"1\":{\"177\":1}}],[\"间隔时间\",{\"1\":{\"88\":2}}],[\"客户端会结束程序执行\",{\"1\":{\"196\":1}}],[\"客户端在与\",{\"1\":{\"196\":1}}],[\"客户端b设置隔离模式为串行化\",{\"1\":{\"176\":1}}],[\"客户端b设置隔离模式为可重复读\",{\"1\":{\"175\":1}}],[\"客户端b设置隔离模式为读已提交\",{\"1\":{\"174\":1}}],[\"客户端b提交事务\",{\"1\":{\"174\":1,\"175\":1}}],[\"客户端a设置隔离模式为串行化\",{\"1\":{\"176\":1}}],[\"客户端a设置隔离模式为可重复读\",{\"1\":{\"175\":1}}],[\"客户端a设置隔离模式为读已提交\",{\"1\":{\"174\":1}}],[\"客户端a再次查询数据\",{\"1\":{\"174\":1,\"175\":1}}],[\"客户端编译器\",{\"1\":{\"7\":1}}],[\"客户端编译器和服务端编译器\",{\"0\":{\"7\":1}}],[\"说明该字段不重复的可能性越大\",{\"1\":{\"231\":1}}],[\"说明该关联查询使用的是\",{\"1\":{\"149\":1}}],[\"说明b事务在更新数据时添加了行级锁\",{\"1\":{\"173\":1}}],[\"修改数据量较小\",{\"1\":{\"216\":1}}],[\"修改位置\",{\"1\":{\"216\":1}}],[\"修改后的权限才会生效\",{\"1\":{\"196\":1}}],[\"修改一条数据不提交\",{\"1\":{\"175\":1}}],[\"修改lilei的balances\",{\"1\":{\"173\":1}}],[\"修正指针\",{\"1\":{\"68\":1}}],[\"修正\",{\"1\":{\"68\":1}}],[\"打开binlog功能\",{\"1\":{\"206\":1}}],[\"打开表的时候\",{\"1\":{\"200\":1}}],[\"打开客户端b\",{\"1\":{\"173\":1}}],[\"打开客户端a\",{\"1\":{\"173\":1}}],[\"打印gc参数\",{\"1\":{\"20\":1}}],[\"打印内联决策\",{\"1\":{\"8\":1}}],[\"隔离级别\",{\"1\":{\"172\":1}}],[\"隔离性\",{\"1\":{\"164\":1}}],[\"外\",{\"1\":{\"166\":1}}],[\"幻读\",{\"1\":{\"165\":1,\"172\":1}}],[\"脏读\",{\"1\":{\"165\":1,\"172\":1}}],[\"脏写\",{\"1\":{\"163\":1,\"165\":1}}],[\"独立\",{\"1\":{\"164\":1}}],[\"概述\",{\"0\":{\"163\":1}}],[\"概念\",{\"1\":{\"74\":1}}],[\"常用的有两种方式\",{\"1\":{\"222\":1}}],[\"常量\",{\"1\":{\"155\":1}}],[\"常见的mysql分页写法\",{\"1\":{\"142\":1}}],[\"常见sql深入优化\",{\"0\":{\"130\":1}}],[\"跟count\",{\"1\":{\"154\":1}}],[\"跟着一个表头信息\",{\"1\":{\"88\":1}}],[\"需进一步判断\",{\"1\":{\"189\":1}}],[\"需从磁盘加载数据到内存\",{\"1\":{\"153\":1}}],[\"需要在内存中重新排序后才能查询出需要的数据\",{\"1\":{\"233\":1}}],[\"需要和索引建立的顺序一致\",{\"1\":{\"233\":1}}],[\"需要指定列的类型\",{\"1\":{\"230\":1}}],[\"需要为表加上一个列\",{\"1\":{\"211\":1}}],[\"需要修改配置文件my\",{\"1\":{\"206\":1}}],[\"需要等待内容刷新到硬盘\",{\"1\":{\"205\":1}}],[\"需要等到所有线程运行到安全点时才能触发\",{\"1\":{\"73\":1}}],[\"需要知道你想要怎么做\",{\"1\":{\"198\":1}}],[\"需要分析为什么有这么多等待\",{\"1\":{\"181\":1}}],[\"需要考虑其他事务修改的情况\",{\"1\":{\"175\":1}}],[\"需要注意的是\",{\"1\":{\"159\":1}}],[\"需要全表扫描t1表10000行\",{\"1\":{\"149\":1}}],[\"需要递增\",{\"1\":{\"145\":1}}],[\"需要查询比较靠后的数据需要一步一步点击\",{\"1\":{\"145\":1}}],[\"需要根据业务需要灵活选择\",{\"1\":{\"143\":1}}],[\"需要维护叶子节点中的数据顺序\",{\"1\":{\"115\":1}}],[\"需要维护这个索引\",{\"1\":{\"100\":1}}],[\"需要\",{\"1\":{\"68\":1}}],[\"需要把各个region中的对象拷贝到别的region中\",{\"1\":{\"55\":1}}],[\"需要重新构建\",{\"1\":{\"27\":1}}],[\"需要依靠gc进行回收内存\",{\"1\":{\"20\":1}}],[\"需要额外的codecache存储编译的代码\",{\"1\":{\"5\":1}}],[\"需要进行机器编译\",{\"1\":{\"5\":1}}],[\"字段类型优化\",{\"0\":{\"224\":1}}],[\"字段\",{\"1\":{\"153\":2,\"154\":3,\"223\":1}}],[\"字段也加入索引了\",{\"1\":{\"139\":1}}],[\"高一点\",{\"1\":{\"153\":1}}],[\"高效率的利用\",{\"1\":{\"37\":1}}],[\"≈count\",{\"1\":{\"153\":2}}],[\"应该为两个表按各自条件过滤后\",{\"1\":{\"151\":1}}],[\"应该是mysql认为范围查找过滤的结果集过大\",{\"1\":{\"128\":1}}],[\"人为指定的顺序不一定比优化引擎靠谱\",{\"1\":{\"151\":1}}],[\"程序判断的比人判断的要准确一些\",{\"1\":{\"151\":1}}],[\"程序可以访问到这些对象默认的零值\",{\"1\":{\"17\":1}}],[\"完全符合范式化的设计真的完美无缺吗\",{\"1\":{\"213\":1}}],[\"完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的\",{\"1\":{\"11\":1}}],[\"完成后\",{\"1\":{\"150\":1}}],[\"由操作系统决定什么时候持久化到硬盘\",{\"1\":{\"205\":1}}],[\"由join\",{\"1\":{\"150\":1}}],[\"由于不知道其他事务的存在\",{\"1\":{\"165\":1}}],[\"由于用了position进行排序\",{\"1\":{\"131\":1}}],[\"由于一个线程的栈的大小通常不会太大\",{\"1\":{\"20\":1}}],[\"由于即时编译器编译本地代码需要占用程序运行时间\",{\"1\":{\"7\":1}}],[\"由于调整元空间大小需要fullgc\",{\"1\":{\"0\":1}}],[\"极限状态下每条数据在t1里扫描10000次\",{\"1\":{\"150\":1}}],[\"没有满足可重复读要求\",{\"1\":{\"174\":1}}],[\"没有where条件\",{\"1\":{\"148\":1}}],[\"没有走索引\",{\"1\":{\"146\":1}}],[\"驱动表的定义\",{\"1\":{\"151\":1}}],[\"驱动表\",{\"1\":{\"148\":1}}],[\"嵌套循环连接\",{\"0\":{\"148\":1}}],[\"选择占用空间小的类型\",{\"1\":{\"230\":1}}],[\"选择一个随机的槽\",{\"1\":{\"223\":1}}],[\"选择了全表扫描\",{\"1\":{\"146\":1}}],[\"选择并行或者jvm自己选\",{\"1\":{\"71\":1}}],[\"该视图在事务结束前都不会改变\",{\"1\":{\"188\":1}}],[\"该session的写操作会报错\",{\"1\":{\"167\":1}}],[\"该sql语句需查询出非主键的字段\",{\"1\":{\"146\":1}}],[\"该sql走了全表扫描\",{\"1\":{\"146\":1}}],[\"该种查询\",{\"1\":{\"145\":1}}],[\"该类对应的\",{\"1\":{\"29\":1}}],[\"该类所有的对象实例都已经被回收\",{\"1\":{\"29\":1}}],[\"业务中删除操作可能会导致主键不连续\",{\"1\":{\"144\":1}}],[\"保留最后10条数据\",{\"1\":{\"142\":1}}],[\"保证\",{\"1\":{\"202\":1}}],[\"保证readlog与binlog日志一致\",{\"1\":{\"190\":1}}],[\"保证数据一致性\",{\"1\":{\"190\":1,\"202\":1}}],[\"保证每个事务在并发情况下\",{\"1\":{\"164\":1}}],[\"保证这种大数据量表的查询尽可能多的都能充分利用索引\",{\"1\":{\"139\":1}}],[\"保证了g1收集器在有限时间内可以尽可能高的收集效率\",{\"1\":{\"52\":1}}],[\"抗下你80\",{\"1\":{\"139\":1}}],[\"核心思想就是\",{\"1\":{\"139\":1}}],[\"核数相同\",{\"1\":{\"37\":1}}],[\"爱好之类的\",{\"1\":{\"139\":1}}],[\"身高\",{\"1\":{\"139\":1}}],[\"性别\",{\"1\":{\"139\":1}}],[\"性能可能相当差\",{\"1\":{\"191\":1}}],[\"性能\",{\"1\":{\"7\":1}}],[\"省市\",{\"1\":{\"139\":1}}],[\"针对同一份数据\",{\"1\":{\"167\":1}}],[\"针对这些慢sql查询做特定的索引优化\",{\"1\":{\"138\":1}}],[\"针对并发标记\",{\"1\":{\"42\":1}}],[\"哪怕多占用一些磁盘空间也是有必要的\",{\"1\":{\"136\":1}}],[\"哪些对象应放在老年代中\",{\"1\":{\"22\":1}}],[\"长字段做索引时\",{\"1\":{\"232\":1}}],[\"长字符串我们可以采用前缀索引\",{\"0\":{\"136\":1}}],[\"长期存活的对象进入老年代\",{\"0\":{\"22\":1}}],[\"把需要的字段放到\",{\"1\":{\"240\":1}}],[\"把排序字段\",{\"1\":{\"240\":1}}],[\"把涉及到该表相关sql都要拿出来分析之后再建立索引\",{\"1\":{\"133\":1}}],[\"把gc\",{\"1\":{\"41\":1}}],[\"遵照索引创建顺序的最左前缀法则\",{\"1\":{\"131\":1}}],[\"遵循索引建立\",{\"1\":{\"131\":1}}],[\"出现在查询列表中的列可不建立索引\",{\"1\":{\"233\":1}}],[\"出现了using\",{\"1\":{\"131\":1}}],[\"出生并经过第一次\",{\"1\":{\"22\":1}}],[\"跳过了age\",{\"1\":{\"131\":1}}],[\"利用最左前缀法则\",{\"1\":{\"131\":1}}],[\"确定选择\",{\"1\":{\"129\":1}}],[\"确定出\",{\"1\":{\"105\":1}}],[\"访问类型\",{\"1\":{\"129\":1}}],[\"辅助索引只保存了数据主键\",{\"1\":{\"153\":1}}],[\"辅助索引\",{\"1\":{\"129\":1}}],[\"7版本中默认是关闭状态\",{\"1\":{\"206\":1}}],[\"7\",{\"1\":{\"129\":1,\"131\":1,\"139\":2,\"232\":1}}],[\"7以后版本的java虚拟机中一个重要进化特征\",{\"1\":{\"52\":1}}],[\"格式化sql\",{\"1\":{\"129\":1}}],[\"成本比全表扫描还高\",{\"1\":{\"129\":1}}],[\"成为热点方法后\",{\"1\":{\"8\":1}}],[\"成为热点代码\",{\"1\":{\"8\":1}}],[\"聚簇索引\",{\"1\":{\"127\":1}}],[\"聚集索引查询更快\",{\"1\":{\"113\":1}}],[\"聚集索引\",{\"1\":{\"113\":3,\"227\":1}}],[\"覆盖索引优化\",{\"0\":{\"125\":1}}],[\"query\",{\"1\":{\"124\":2,\"129\":1,\"197\":4}}],[\"做权限验证\",{\"1\":{\"200\":1}}],[\"做完了这些识别后\",{\"1\":{\"198\":1}}],[\"做一个小实验\",{\"1\":{\"126\":1}}],[\"做了一个小实验\",{\"1\":{\"124\":1}}],[\"做重新标记\",{\"1\":{\"39\":1}}],[\"强制走索引\",{\"0\":{\"124\":1}}],[\"强引用\",{\"1\":{\"27\":2}}],[\"举一个不容易理解的综合例子\",{\"0\":{\"122\":1}}],[\"插入或删除数据的时候需要同时维护该数据\",{\"1\":{\"159\":1}}],[\"插入一些示例数据\",{\"1\":{\"121\":1}}],[\"插入的时候\",{\"1\":{\"101\":1}}],[\"员工记录表\",{\"1\":{\"121\":1}}],[\"入职时间\",{\"1\":{\"121\":1}}],[\"职位\",{\"1\":{\"121\":1}}],[\"姓名\",{\"1\":{\"121\":1}}],[\"`performance\",{\"1\":{\"182\":2}}],[\"`position`\",{\"1\":{\"121\":2,\"129\":6}}],[\"`idx\",{\"1\":{\"121\":1}}],[\"`id`\",{\"1\":{\"121\":2,\"129\":2}}],[\"`hire\",{\"1\":{\"121\":1,\"129\":2}}],[\"`age`\",{\"1\":{\"121\":2,\"129\":2}}],[\"`name`\",{\"1\":{\"121\":2,\"129\":9}}],[\"`employees`\",{\"1\":{\"121\":1,\"129\":23}}],[\"右边的索引字段才会按照顺序排列\",{\"1\":{\"118\":1}}],[\"右子数大于根节点的规律进行存储\",{\"1\":{\"101\":1}}],[\"再转到第一个文件开头开始循环写\",{\"1\":{\"205\":1}}],[\"再根据规则进行比较\",{\"1\":{\"189\":1}}],[\"再次进行数据计算\",{\"1\":{\"173\":1}}],[\"再取t1数据进行比较\",{\"1\":{\"150\":1}}],[\"再回到聚簇索引提取出来完整的name字段值进行比对\",{\"1\":{\"136\":1}}],[\"再比对age和position这两个字段的值是否符合\",{\"1\":{\"127\":1}}],[\"再比较\",{\"1\":{\"118\":2}}],[\"再将这些记录过的引用关系中的灰色对象为根\",{\"1\":{\"43\":1}}],[\"再将这些记录过的引用关系中的黑色对象为根\",{\"1\":{\"43\":1}}],[\"现在innodb也支持了\",{\"1\":{\"226\":1}}],[\"现在最常用的存储引擎是\",{\"1\":{\"201\":1}}],[\"现在有联合索引\",{\"1\":{\"118\":1}}],[\"现在有一个联合索引\",{\"1\":{\"117\":1}}],[\"现代追踪式\",{\"1\":{\"47\":1}}],[\"联合索引尽量覆盖查询条件\",{\"0\":{\"134\":1}}],[\"联合索引第一个字段就用范围查找不会走索引\",{\"1\":{\"123\":1}}],[\"联合索引第一个字段用范围不会走索引\",{\"0\":{\"123\":1}}],[\"联合索引就会失效\",{\"1\":{\"118\":1}}],[\"联合索引\",{\"0\":{\"117\":1}}],[\"三星一般是最重要的\",{\"1\":{\"234\":1}}],[\"三\",{\"0\":{\"117\":1}}],[\"三色标记\",{\"0\":{\"41\":1},\"1\":{\"41\":1}}],[\"复合索引\",{\"0\":{\"117\":1}}],[\"复杂度较高\",{\"1\":{\"116\":1}}],[\"复制算法\",{\"0\":{\"33\":1}}],[\"复制\",{\"1\":{\"8\":1,\"33\":1,\"52\":1}}],[\"必然要维护数据的一致性\",{\"1\":{\"116\":1}}],[\"必须使关系满足一定的约束条件\",{\"1\":{\"209\":1}}],[\"必须是符合实际的\",{\"1\":{\"52\":1}}],[\"必须解决\",{\"1\":{\"43\":1}}],[\"否则会让索引变长变慢\",{\"1\":{\"232\":1}}],[\"否则就会有大量的数据冗余\",{\"1\":{\"212\":1}}],[\"否则就会根据叶子节点中存储的聚集索引的值\",{\"1\":{\"116\":1}}],[\"否则都会从行锁升级为表锁\",{\"1\":{\"178\":1}}],[\"否则不保留\",{\"1\":{\"152\":1}}],[\"否则为0\",{\"1\":{\"48\":1,\"139\":1}}],[\"节点之前\",{\"1\":{\"115\":1}}],[\"节点插入到\",{\"1\":{\"115\":1}}],[\"文件下载次数等\",{\"1\":{\"223\":1}}],[\"文件的开头\",{\"1\":{\"205\":1}}],[\"文件的结尾时\",{\"1\":{\"205\":1}}],[\"文件的个数\",{\"1\":{\"204\":1}}],[\"文件大小\",{\"1\":{\"204\":1}}],[\"文件\",{\"1\":{\"204\":1}}],[\"文件存储位置参数\",{\"1\":{\"204\":1}}],[\"文件是一个\",{\"1\":{\"114\":1}}],[\"文件中\",{\"1\":{\"111\":1,\"113\":2}}],[\"非聚簇索引中读取到一条记录后\",{\"1\":{\"228\":1}}],[\"非聚集索引存储聚集索引的主键\",{\"1\":{\"116\":1}}],[\"非聚集索引\",{\"1\":{\"113\":1,\"227\":1}}],[\"非主键索引的叶子节点存储的是聚集索引的值\",{\"1\":{\"116\":1}}],[\"非死不可\",{\"1\":{\"28\":1}}],[\"引擎层负责数据的存储和提取其架构模式是插件式的\",{\"1\":{\"201\":1}}],[\"引擎层\",{\"0\":{\"201\":1}}],[\"引擎层主要包括各种执行引擎\",{\"1\":{\"194\":1}}],[\"引擎存储数据的区别\",{\"0\":{\"113\":1}}],[\"引用计数\",{\"0\":{\"25\":1}}],[\"表中数据需要主键或唯一索引\",{\"1\":{\"211\":1}}],[\"表中只有一个聚集索引\",{\"1\":{\"116\":1}}],[\"表结构及索引设计\",{\"0\":{\"208\":1}}],[\"表明该数据落入read\",{\"1\":{\"189\":1}}],[\"表明该数据最后修改的事务id比生成read\",{\"1\":{\"189\":1}}],[\"表明该数据最后修改的事务id比生成的read\",{\"1\":{\"189\":1}}],[\"表名\",{\"1\":{\"168\":1}}],[\"表锁\",{\"0\":{\"168\":1},\"1\":{\"167\":1}}],[\"表依赖详情\",{\"1\":{\"129\":1}}],[\"表复制一张employees\",{\"1\":{\"126\":1}}],[\"表对应的\",{\"1\":{\"114\":1}}],[\"表对应的文件只有两个\",{\"1\":{\"112\":1}}],[\"表必须建立主键\",{\"0\":{\"114\":1}}],[\"表示不自动删除\",{\"1\":{\"206\":1}}],[\"表示每次提交事务\",{\"1\":{\"205\":3}}],[\"表示这是未来事务提交的数据\",{\"1\":{\"189\":1}}],[\"表示是已经提交过的事务\",{\"1\":{\"189\":1}}],[\"表示需要gc的region集合\",{\"1\":{\"66\":1}}],[\"表示该对象未指向重分配集\",{\"1\":{\"66\":1}}],[\"表示该元素变脏\",{\"1\":{\"48\":1}}],[\"表示对象尚未被垃圾收集器访问过\",{\"1\":{\"41\":1}}],[\"表示对象已经被垃圾收集器访问过\",{\"1\":{\"41\":2}}],[\"表示在初始标记的时候多线程执行\",{\"1\":{\"40\":1}}],[\"去使用这个引擎提供的接口\",{\"1\":{\"200\":1}}],[\"去第二张表中关联相关数据\",{\"1\":{\"148\":1}}],[\"去磁盘上\",{\"1\":{\"111\":1}}],[\"去实际访问拆散后的成员变量\",{\"1\":{\"10\":1}}],[\"服务端查询用户权限表\",{\"1\":{\"196\":1}}],[\"服务端验证不通过\",{\"1\":{\"196\":1}}],[\"服务端会出现以下情况\",{\"1\":{\"196\":1}}],[\"服务端完成\",{\"1\":{\"196\":1}}],[\"服务端分为\",{\"1\":{\"194\":1}}],[\"服务端编译器\",{\"1\":{\"7\":1}}],[\"服务的\",{\"1\":{\"109\":1}}],[\"二星和一星重要性相差不大\",{\"1\":{\"234\":1}}],[\"二是对where后面的条件也有要求\",{\"1\":{\"145\":1}}],[\"二级索引\",{\"0\":{\"116\":1}}],[\"二\",{\"0\":{\"108\":1}}],[\"二叉平衡树\",{\"0\":{\"101\":1}}],[\"二叉树变成了一个类似链表的树\",{\"1\":{\"100\":1}}],[\"过滤后的结果集比较小\",{\"1\":{\"128\":1}}],[\"过滤掉不符合条件的记录之后再回表\",{\"1\":{\"127\":1}}],[\"过程是比较耗时的\",{\"1\":{\"107\":1}}],[\"过了一小段时间之后\",{\"1\":{\"57\":1}}],[\"行锁可能会升级为表锁\",{\"1\":{\"178\":1}}],[\"行锁\",{\"0\":{\"171\":1}}],[\"行记录\",{\"1\":{\"107\":1}}],[\"行为的垃圾收集器\",{\"1\":{\"48\":1}}],[\"叶子节点是按照顺序排列的\",{\"1\":{\"118\":1}}],[\"叶子节点中只包含了索引\",{\"1\":{\"113\":1}}],[\"叶子节点存储索引和整个表记录\",{\"1\":{\"113\":1}}],[\"叶子节点还存储了数据\",{\"1\":{\"107\":1}}],[\"叶子节点之前是没有整个指针的\",{\"1\":{\"104\":1}}],[\"个好的关系\",{\"1\":{\"209\":1}}],[\"个\",{\"1\":{\"107\":1,\"204\":2}}],[\"值来表示\",{\"1\":{\"107\":1}}],[\"值配置整数\",{\"1\":{\"57\":1}}],[\"位\",{\"1\":{\"107\":1}}],[\"页\",{\"1\":{\"107\":1}}],[\"结果集应该很大\",{\"1\":{\"123\":1}}],[\"结果这个缓存map越来越大\",{\"1\":{\"95\":1}}],[\"结论\",{\"0\":{\"179\":1},\"1\":{\"123\":1,\"124\":1,\"129\":1,\"170\":1}}],[\"结构明晰的\",{\"1\":{\"209\":1}}],[\"结构与t1表结构完全相同\",{\"1\":{\"148\":1}}],[\"结构叶子节点存储的是主键值\",{\"0\":{\"116\":1}}],[\"结构里\",{\"1\":{\"107\":1}}],[\"快速的定位到其他的叶子节点\",{\"1\":{\"106\":1}}],[\"得到的索引行里的age和position是无序的\",{\"1\":{\"127\":1}}],[\"得到\",{\"1\":{\"105\":1}}],[\"取下一个满足\",{\"1\":{\"240\":1}}],[\"取出所有字段的值\",{\"1\":{\"239\":1}}],[\"取出整行\",{\"1\":{\"239\":1,\"240\":1}}],[\"取出满足条件的行\",{\"1\":{\"148\":1}}],[\"取出存储的内存地址\",{\"1\":{\"111\":1}}],[\"取出到cpu寄存器后解码方式进行优化\",{\"1\":{\"19\":1}}],[\"取到内存地址后访问\",{\"1\":{\"105\":1}}],[\"首先可以创建一张独立的表存储计数器\",{\"1\":{\"223\":1}}],[\"首先通过二级索引找到对应的id\",{\"1\":{\"116\":1}}],[\"首先从索引的根节点开始查询\",{\"1\":{\"111\":1}}],[\"首先计算出\",{\"1\":{\"105\":1}}],[\"首先会将\",{\"1\":{\"105\":1}}],[\"数学和加密函数等\",{\"1\":{\"195\":1}}],[\"数组\",{\"1\":{\"188\":1}}],[\"数据冗余\",{\"1\":{\"220\":1}}],[\"数据冗余较小\",{\"1\":{\"216\":1}}],[\"数据最安全\",{\"1\":{\"205\":1}}],[\"数据文件存储位置\",{\"1\":{\"204\":1}}],[\"数据不可以展示\",{\"1\":{\"189\":1}}],[\"数据不可展示\",{\"1\":{\"189\":1}}],[\"数据不变\",{\"1\":{\"174\":1,\"175\":1}}],[\"数据可以展示\",{\"1\":{\"189\":2}}],[\"数据库只需满足第三范式\",{\"1\":{\"209\":1}}],[\"数据库表设计\",{\"0\":{\"209\":1}}],[\"数据库在较高配置的机器上每秒可以抗下几干甚至上万的读写请求\",{\"1\":{\"203\":1}}],[\"数据库地址\",{\"1\":{\"196\":1}}],[\"数据库的时候\",{\"1\":{\"196\":1}}],[\"数据库事务隔离级别越严格\",{\"1\":{\"172\":1}}],[\"数据库内数据也是一种资源\",{\"1\":{\"166\":1}}],[\"数据库中\",{\"1\":{\"166\":1}}],[\"数据库锁分类\",{\"0\":{\"166\":1}}],[\"数据库需提供一定隔离性\",{\"1\":{\"164\":1}}],[\"数据库通常会并发的执行多个事务\",{\"1\":{\"163\":1}}],[\"数据需要保持一致\",{\"1\":{\"164\":1}}],[\"数据准备\",{\"0\":{\"121\":1}}],[\"数据只存储一份即可\",{\"1\":{\"116\":1}}],[\"数据存储在另一个文件\",{\"1\":{\"113\":1}}],[\"数据查询\",{\"0\":{\"111\":1}}],[\"数据页\",{\"1\":{\"107\":1}}],[\"数每个节点都存储了索引和数据\",{\"1\":{\"107\":1}}],[\"数每连个叶子节点之间都有一个双向指针\",{\"1\":{\"104\":1}}],[\"数的非叶子节点只存了索引\",{\"1\":{\"107\":1}}],[\"数的一个原因\",{\"1\":{\"107\":1}}],[\"数的节点不能超过该数\",{\"1\":{\"103\":1}}],[\"数是如何查询数据的\",{\"0\":{\"105\":1}}],[\"数中叶子节点间本来就是依次递增排好序的\",{\"1\":{\"106\":1}}],[\"数中\",{\"1\":{\"104\":1}}],[\"数\",{\"1\":{\"104\":1,\"114\":1}}],[\"底层原理与\",{\"0\":{\"202\":1}}],[\"底层对\",{\"1\":{\"103\":1}}],[\"底层为什么不使用\",{\"0\":{\"102\":1}}],[\"底层为什么不使用红黑树\",{\"0\":{\"101\":1}}],[\"底层为什么不使用二叉树\",{\"0\":{\"100\":1}}],[\"严重影响性能\",{\"1\":{\"102\":1}}],[\"红黑树依然会出现\",{\"1\":{\"101\":1}}],[\"红黑树相对于二叉树确实有所提高\",{\"1\":{\"101\":1}}],[\"添加写锁后\",{\"1\":{\"170\":1}}],[\"添加写锁情况\",{\"0\":{\"170\":1}}],[\"添加读锁的情况\",{\"0\":{\"169\":1}}],[\"添加\",{\"1\":{\"101\":1}}],[\"根本没法进行快速的二分查找\",{\"1\":{\"135\":1}}],[\"根节点是黑色\",{\"1\":{\"101\":1}}],[\"根据主键\",{\"1\":{\"239\":1,\"240\":1}}],[\"根据阿里开发规范\",{\"1\":{\"151\":1}}],[\"根据关联关系获取数据\",{\"1\":{\"150\":1}}],[\"根据关联关系进行关联\",{\"1\":{\"149\":1}}],[\"根据nlj步骤\",{\"1\":{\"150\":1}}],[\"根据步骤\",{\"1\":{\"149\":1}}],[\"根据非主键字段排序的分页\",{\"0\":{\"146\":1}}],[\"根据左前缀匹配原理\",{\"1\":{\"118\":1}}],[\"根据取出的内存地址读取数据\",{\"1\":{\"111\":1}}],[\"根据结果我们大概就能知道系统大概多久会因为young\",{\"1\":{\"91\":1}}],[\"根据他说的\",{\"1\":{\"69\":1}}],[\"根据对象指针中这4位的信息\",{\"1\":{\"68\":1}}],[\"根据r大的说法\",{\"1\":{\"61\":1}}],[\"根据期望的gc停顿时间确定old区垃圾收集的优先顺序\",{\"1\":{\"55\":1}}],[\"根据用户所期望的gc停顿stw时间\",{\"1\":{\"52\":1}}],[\"根据老年代的特点\",{\"1\":{\"35\":1}}],[\"根据线程不同\",{\"1\":{\"16\":1}}],[\"根据程序访问情况\",{\"1\":{\"10\":1}}],[\"什么是红黑树\",{\"1\":{\"101\":1}}],[\"形成一个链表\",{\"1\":{\"100\":1}}],[\"形成浮动垃圾\",{\"1\":{\"52\":1}}],[\"冲突导致链表查询数据较慢\",{\"1\":{\"99\":1}}],[\"较多的\",{\"1\":{\"99\":1}}],[\"树来维护索引和表记录\",{\"1\":{\"112\":1}}],[\"树存储两千万行数据\",{\"1\":{\"107\":1}}],[\"树存满的时候\",{\"1\":{\"107\":1}}],[\"树中是按照顺序排列的\",{\"1\":{\"115\":1}}],[\"树中\",{\"1\":{\"113\":1}}],[\"树中叶子节点之间并没有指针\",{\"1\":{\"106\":1}}],[\"树中有一个\",{\"1\":{\"103\":1}}],[\"树非叶子节点存储的是冗余索引\",{\"1\":{\"104\":1}}],[\"树和\",{\"0\":{\"104\":1}}],[\"树叶子节点之间为何使用双向指针互相连接\",{\"0\":{\"106\":1}}],[\"树叶子节点之间是双向指针\",{\"1\":{\"103\":1}}],[\"树叶节点之间没有指针连接\",{\"1\":{\"102\":1}}],[\"树做了一些修改\",{\"1\":{\"103\":1}}],[\"树确实极大的降低了树的高度\",{\"1\":{\"102\":1}}],[\"树的结构发生了平衡\",{\"1\":{\"115\":1}}],[\"树的树高度和和数据的大小是有关的\",{\"1\":{\"107\":1}}],[\"树的高度也只有\",{\"1\":{\"107\":1}}],[\"树的根节点加载到内存中\",{\"1\":{\"105\":1}}],[\"树的不同点\",{\"0\":{\"104\":1}}],[\"树的叶子节点之间是单向指针\",{\"1\":{\"103\":1}}],[\"树的每个节点都存储了索引和对应的数据\",{\"1\":{\"102\":1}}],[\"树的深度必然太大\",{\"1\":{\"101\":1}}],[\"树太深的根本原因就是每个根节点只储存了两个子树\",{\"1\":{\"101\":1}}],[\"树太高\",{\"1\":{\"101\":1}}],[\"树\",{\"1\":{\"99\":2,\"104\":1,\"114\":3}}],[\"碰撞\",{\"1\":{\"99\":1}}],[\"索引中的列包含了查询中所需要的列\",{\"1\":{\"234\":1}}],[\"索引将所有记录放到一起获得一星\",{\"1\":{\"234\":1}}],[\"索引离散型指不重复索引的数量与数据总量的比值\",{\"1\":{\"231\":1}}],[\"索引树大小较小\",{\"1\":{\"153\":1}}],[\"索引字段\",{\"1\":{\"153\":1}}],[\"索引设计的设计思路\",{\"1\":{\"139\":1}}],[\"索引设计实战\",{\"0\":{\"139\":1}}],[\"索引设计原则\",{\"0\":{\"132\":1}}],[\"索引基数是指这个字段在表里总共有多少个不同的值\",{\"1\":{\"135\":1}}],[\"索引后上\",{\"0\":{\"133\":1}}],[\"索引创建的顺序\",{\"1\":{\"131\":1}}],[\"索引使用成本\",{\"1\":{\"129\":1}}],[\"索引使用范围\",{\"1\":{\"129\":1}}],[\"索引扫描行数\",{\"1\":{\"129\":1}}],[\"索引下推会减少回表次数\",{\"1\":{\"127\":1}}],[\"索引下推\",{\"1\":{\"127\":1}}],[\"索引最左前缀原理\",{\"0\":{\"118\":1}}],[\"索引和表记录存储在\",{\"1\":{\"113\":1}}],[\"索引和表记录被维护在一个\",{\"1\":{\"113\":1}}],[\"索引文件和数据文件存储\",{\"0\":{\"110\":1,\"112\":1}}],[\"索引存储的位置\",{\"0\":{\"109\":1}}],[\"索引存储\",{\"0\":{\"108\":1}}],[\"索引并不支持范围查询\",{\"1\":{\"106\":1}}],[\"索引\",{\"0\":{\"99\":1}}],[\"索引的本质\",{\"0\":{\"98\":1}}],[\"存入\",{\"1\":{\"239\":1}}],[\"存入一张表中\",{\"1\":{\"222\":1}}],[\"存在一个部门信息表\",{\"1\":{\"212\":1}}],[\"存在的问题就是如果数据量较大的时候\",{\"1\":{\"99\":1}}],[\"存储空间比反范式化小\",{\"1\":{\"216\":1}}],[\"存储引擎中的主键索引是一个非聚集索引\",{\"1\":{\"113\":1}}],[\"存储引擎是数据表级别的\",{\"1\":{\"109\":1}}],[\"存储索引\",{\"1\":{\"110\":1}}],[\"存储表数据\",{\"1\":{\"110\":1}}],[\"存储和表结构相关的数据\",{\"1\":{\"110\":1,\"112\":1}}],[\"存储自增主键\",{\"1\":{\"107\":1}}],[\"存储的是内存地址\",{\"1\":{\"113\":1}}],[\"存储的是每一页的第一个索引\",{\"1\":{\"104\":1}}],[\"存储的最基本结构\",{\"1\":{\"107\":1}}],[\"存储磁盘地址\",{\"1\":{\"98\":1}}],[\"存储数据\",{\"1\":{\"98\":1}}],[\"存活下来的对象过多\",{\"1\":{\"58\":1}}],[\"存活对象过多\",{\"1\":{\"57\":1}}],[\"kill\",{\"1\":{\"182\":1}}],[\"kk\",{\"0\":{\"127\":1},\"1\":{\"127\":1,\"128\":3}}],[\"key\",{\"0\":{\"178\":1},\"1\":{\"98\":1,\"121\":2,\"129\":4,\"131\":1,\"136\":1,\"197\":2,\"232\":1,\"238\":3}}],[\"kafka类似的支撑高并发消息系统大家肯定不陌生\",{\"1\":{\"60\":1}}],[\"观察每次结果eden\",{\"1\":{\"92\":1}}],[\"公式算出\",{\"1\":{\"91\":1}}],[\"your\",{\"1\":{\"198\":1}}],[\"you\",{\"1\":{\"198\":1}}],[\"young\",{\"1\":{\"91\":1}}],[\"younggc并不是说现有的eden区放满了就会马上触发\",{\"1\":{\"54\":1}}],[\"younggc\",{\"0\":{\"54\":1}}],[\"ygc\",{\"1\":{\"91\":1}}],[\"ygct\",{\"1\":{\"91\":1}}],[\"知道了老年代对象的增长速率就可以推算出full\",{\"1\":{\"93\":1}}],[\"知道年轻代对象增长速率我们就能推根据eden区的大小推算出young\",{\"1\":{\"91\":1}}],[\"知乎\",{\"1\":{\"63\":1,\"69\":1}}],[\"甚至可能会更差\",{\"1\":{\"179\":1}}],[\"甚至更多的时候\",{\"1\":{\"107\":1}}],[\"甚至10分钟来观察整体情况\",{\"1\":{\"90\":1}}],[\"甚至会造成内存溢出\",{\"1\":{\"27\":1}}],[\"共有多少个叶子节点呢\",{\"1\":{\"107\":1}}],[\"共执行10次\",{\"1\":{\"90\":1}}],[\"共同的关注点\",{\"1\":{\"52\":1}}],[\"先查询出外面select\",{\"1\":{\"152\":1}}],[\"先比较\",{\"1\":{\"118\":1}}],[\"先给自己的系统设置一些初始性的jvm参数\",{\"1\":{\"89\":1}}],[\"先去检查这个指令的参数是否能够在类的常量池中定位到一个类的符号引用\",{\"1\":{\"15\":1}}],[\"有条件可以配置比较大\",{\"1\":{\"240\":1}}],[\"有的时候需要将很长的字段添加索引\",{\"1\":{\"232\":1}}],[\"有的app可能用户还有评分\",{\"1\":{\"139\":1}}],[\"有个关键点是如何维护缓存表和汇总表中的数据\",{\"1\":{\"222\":1}}],[\"有一个后台线程\",{\"1\":{\"205\":1}}],[\"有三种可能取值\",{\"1\":{\"205\":1}}],[\"有没有执行查询的权限\",{\"1\":{\"200\":1}}],[\"有办法解决幻读问题吗\",{\"1\":{\"177\":1}}],[\"有效性\",{\"1\":{\"166\":1}}],[\"有自己\",{\"1\":{\"164\":1}}],[\"有10000行数据\",{\"1\":{\"148\":1}}],[\"有时like\",{\"1\":{\"128\":1}}],[\"有如下查询语句\",{\"1\":{\"100\":1}}],[\"有可能分布存储在磁盘不同的空间中\",{\"1\":{\"98\":1}}],[\"有了这些数据就可以采用之前介绍过的优化思路\",{\"1\":{\"89\":1}}],[\"有两种解决方案\",{\"1\":{\"43\":1}}],[\"输出多少行数据后\",{\"1\":{\"88\":1}}],[\"输出jit编译的方法信息\",{\"1\":{\"88\":1}}],[\"同样的查询语句在一个事务里如何做到查询相同的结果的\",{\"1\":{\"187\":1}}],[\"同\",{\"1\":{\"88\":1}}],[\"同时\",{\"1\":{\"209\":1}}],[\"同时内置函数\",{\"1\":{\"195\":1}}],[\"同时straight\",{\"1\":{\"151\":1}}],[\"同时在内存中的比对极限情况下可能需要执行100\",{\"1\":{\"149\":1}}],[\"同时可以看到\",{\"1\":{\"148\":1}}],[\"同时排序使用了文件排序\",{\"1\":{\"146\":1}}],[\"同时因为要limit操作\",{\"1\":{\"146\":1}}],[\"同时如果根据非主键排序\",{\"1\":{\"144\":1}}],[\"同时还能保证各种异常情况下的数据一致性\",{\"1\":{\"191\":1,\"203\":1}}],[\"同时还会在索引里过滤age和position这两个字段\",{\"1\":{\"127\":1}}],[\"同时还可以看出每次young\",{\"1\":{\"92\":1}}],[\"同时将上一个黑节点指向该次生成的黑色节点\",{\"1\":{\"101\":1}}],[\"同时将该节点两侧的黑节点转化成红节点\",{\"1\":{\"101\":1}}],[\"同时显示最后一次或当前正在发生的垃圾收集的诱发原因\",{\"1\":{\"88\":1}}],[\"同时也无法支持32位的操作系统\",{\"1\":{\"66\":1}}],[\"同时gc线程开始对未标记的区域做清扫\",{\"1\":{\"39\":1}}],[\"同时工作\",{\"1\":{\"39\":1}}],[\"同时启动会更慢\",{\"1\":{\"7\":1}}],[\"同时收集器会对该值进行调整\",{\"1\":{\"0\":1}}],[\"显示减少了50\",{\"1\":{\"173\":1}}],[\"显示程序的运行时间\",{\"1\":{\"88\":1}}],[\"显示垃圾收集信息\",{\"1\":{\"88\":1}}],[\"显示垃圾收集相关信息\",{\"1\":{\"88\":1}}],[\"显示永久代大小\",{\"1\":{\"88\":1}}],[\"显示老年代大小\",{\"1\":{\"88\":1}}],[\"显示老年代信息\",{\"1\":{\"88\":1}}],[\"显示新生代大小和使用情况\",{\"1\":{\"88\":1}}],[\"显示新生代信息\",{\"1\":{\"88\":1}}],[\"显示各个代的容量和使用情况\",{\"1\":{\"88\":1}}],[\"显示与gc相关信息\",{\"1\":{\"88\":1}}],[\"显示jit编译的相关信息\",{\"1\":{\"88\":1}}],[\"显示classloader的相关信息\",{\"1\":{\"88\":1}}],[\"显然是不行的\",{\"1\":{\"60\":1,\"139\":1}}],[\"显然在可达性分析刚刚开始的阶段\",{\"1\":{\"41\":1}}],[\"显然执⾏效率是⽐不上c\",{\"1\":{\"5\":1}}],[\"查找只用到索引name\",{\"1\":{\"131\":1}}],[\"查询效率会非常高\",{\"1\":{\"197\":1}}],[\"查询当前登录用户所拥有的表及服务器权限\",{\"1\":{\"196\":1}}],[\"查询缓存比较鸡肋\",{\"1\":{\"197\":1}}],[\"查询缓存\",{\"0\":{\"197\":1},\"1\":{\"194\":1,\"195\":1,\"197\":1}}],[\"查询到仍为第一次查询的数据\",{\"1\":{\"175\":1}}],[\"查询到客户端b修改的数据\",{\"1\":{\"174\":1}}],[\"查询不需要计算\",{\"1\":{\"157\":1}}],[\"查询t1表\",{\"1\":{\"150\":1}}],[\"查询大于这个条件的后10条或后几条\",{\"1\":{\"145\":1}}],[\"查询所需条数的写法\",{\"1\":{\"144\":1}}],[\"查询使用了name索引\",{\"1\":{\"131\":1}}],[\"查询可能使用的索引\",{\"1\":{\"129\":1}}],[\"查询成本\",{\"1\":{\"129\":1}}],[\"查询的时候先根据索引的\",{\"1\":{\"99\":1}}],[\"查询出我们需要的数据\",{\"1\":{\"98\":1}}],[\"查询次数\",{\"1\":{\"88\":2}}],[\"查看binlog相关参数\",{\"1\":{\"206\":1}}],[\"查看innodb\",{\"1\":{\"205\":1}}],[\"查看infomation\",{\"0\":{\"182\":1}}],[\"查看当前\",{\"1\":{\"197\":1}}],[\"查看当前存活的实例\",{\"1\":{\"79\":1}}],[\"查看锁等待详细信息\",{\"1\":{\"182\":1}}],[\"查看锁等待\",{\"1\":{\"182\":1}}],[\"查看锁\",{\"1\":{\"182\":1}}],[\"查看事务\",{\"1\":{\"182\":1}}],[\"查看数据库事务隔离级别的语句\",{\"1\":{\"172\":1}}],[\"查看表状态\",{\"1\":{\"168\":1}}],[\"查看执行计划可以看到\",{\"1\":{\"148\":1}}],[\"查看执行计划\",{\"1\":{\"146\":1,\"153\":1}}],[\"查看trace字段可知索引扫描的成本低于全表扫描\",{\"1\":{\"129\":1}}],[\"查看trace字段\",{\"1\":{\"129\":1}}],[\"查看java系统参数\",{\"1\":{\"87\":1}}],[\"查看java参数\",{\"1\":{\"86\":1}}],[\"查看正在运行的java的运行参数\",{\"1\":{\"85\":1}}],[\"查看对应的堆栈信息找出可能存在问题的代码\",{\"1\":{\"84\":1}}],[\"查看堆信息\",{\"1\":{\"80\":1}}],[\"查看历史生成的实例\",{\"1\":{\"79\":1}}],[\"毫秒\",{\"1\":{\"88\":1}}],[\"毫无疑问\",{\"1\":{\"52\":1}}],[\"|grep\",{\"1\":{\"84\":1}}],[\"找到第一个满足\",{\"1\":{\"240\":1}}],[\"找到内存和cpu占用较高的tid比如19664\",{\"1\":{\"84\":1}}],[\"找到的对象都标记为非垃圾对象\",{\"1\":{\"26\":1}}],[\"展示进程中的线程id\",{\"1\":{\"84\":1}}],[\"6074\",{\"1\":{\"129\":1}}],[\"6引入了索引下推优化\",{\"1\":{\"127\":1}}],[\"6之前的版本\",{\"1\":{\"127\":1}}],[\"6\",{\"0\":{\"138\":1},\"1\":{\"100\":2,\"107\":2,\"115\":2,\"129\":2,\"131\":1,\"232\":1}}],[\"666\",{\"1\":{\"84\":1}}],[\"64tb\",{\"1\":{\"107\":1}}],[\"64\",{\"1\":{\"0\":1}}],[\"运行此代码\",{\"1\":{\"84\":1}}],[\"栈信息\",{\"1\":{\"82\":1}}],[\"栈上分配可以支持方法逃逸\",{\"1\":{\"11\":1}}],[\"栈上分配\",{\"0\":{\"11\":1}}],[\">或者<\",{\"1\":{\"238\":1}}],[\">count\",{\"1\":{\"153\":4}}],[\">\",{\"1\":{\"83\":2,\"123\":1,\"124\":3,\"125\":1,\"129\":12,\"144\":1,\"177\":1,\"189\":1,\"238\":2}}],[\">profiler打开分析界面\",{\"1\":{\"81\":1}}],[\">tool\",{\"1\":{\"81\":1}}],[\">>>>>>>>\",{\"1\":{\"8\":1}}],[\"路径\",{\"1\":{\"81\":1}}],[\"导出文件后\",{\"1\":{\"81\":1}}],[\"导出堆内对象信息到文件\",{\"1\":{\"81\":1}}],[\"导出堆内对象信息\",{\"0\":{\"81\":1}}],[\"导致与索引的排序方式不同\",{\"1\":{\"131\":1}}],[\"导致每一次磁盘\",{\"1\":{\"102\":1}}],[\"导致每次选出来的回收集只占堆内存很小的一部分\",{\"1\":{\"52\":1}}],[\"导致进入survivor区域后触发了动态年龄判定规则\",{\"1\":{\"58\":1}}],[\"导致系统运行很久\",{\"1\":{\"58\":1}}],[\"导致垃圾慢慢堆积\",{\"1\":{\"52\":1}}],[\"导致它们的引用计数器都不为0\",{\"1\":{\"25\":1}}],[\"序号\",{\"1\":{\"79\":1}}],[\"接着再进行排序\",{\"1\":{\"137\":1}}],[\"接着可以使用各种java提供的工具排查\",{\"1\":{\"77\":1}}],[\"接下来jvm就会加上一个读屏障\",{\"1\":{\"68\":1}}],[\"接下来\",{\"1\":{\"8\":1}}],[\"事务提交后\",{\"1\":{\"190\":1,\"202\":1}}],[\"事务提交后对数据的修改是永久性的\",{\"1\":{\"164\":1}}],[\"事务准备提交时\",{\"1\":{\"190\":2,\"202\":2}}],[\"事务的sql查询时\",{\"1\":{\"189\":1}}],[\"事务的隔离级别\",{\"0\":{\"172\":1}}],[\"事务里的任何sql查询\",{\"1\":{\"188\":1}}],[\"事务b修改了该条数据并提交\",{\"1\":{\"165\":1}}],[\"事务b进行了回滚\",{\"1\":{\"165\":1}}],[\"事务开始和结束时\",{\"1\":{\"164\":1}}],[\"事务及acid属性\",{\"0\":{\"164\":1}}],[\"事务数据页\",{\"1\":{\"107\":1}}],[\"事先启动一个web程序\",{\"1\":{\"77\":1}}],[\"事实上大部分系统的对象也是这种情况\",{\"1\":{\"63\":1}}],[\"事实上并不只是新生代\",{\"1\":{\"48\":1}}],[\"安全区域\",{\"0\":{\"74\":1}}],[\"安全点就是指代码中的一些特定的位置\",{\"1\":{\"73\":1}}],[\"安全点\",{\"0\":{\"73\":1}}],[\"安全点与安全区域\",{\"0\":{\"72\":1}}],[\"轮询标志的地方和安全点是重合的\",{\"1\":{\"73\":1}}],[\"各个线程执行过程时会不停地主动去轮询这个标志\",{\"1\":{\"73\":1}}],[\"仅支持等只查询\",{\"1\":{\"106\":1}}],[\"仅能满足等值运算\",{\"1\":{\"99\":1}}],[\"仅仅简单地设置一个标志位\",{\"1\":{\"73\":1}}],[\"仅开启方法计数器和回边计数器\",{\"1\":{\"7\":1}}],[\"思路\",{\"1\":{\"73\":1}}],[\"思考\",{\"1\":{\"68\":1}}],[\"循环的末尾\",{\"1\":{\"73\":1}}],[\"抛出异常的位置\",{\"1\":{\"73\":1}}],[\"调用\",{\"1\":{\"205\":1}}],[\"调用某个方法之后\",{\"1\":{\"73\":1}}],[\"调优也并不难\",{\"1\":{\"69\":1}}],[\"调优\",{\"1\":{\"69\":1}}],[\"距上次gc堆内存增长10\",{\"1\":{\"70\":1}}],[\"耗尽时间\",{\"1\":{\"70\":1}}],[\"耗时更长\",{\"1\":{\"7\":1}}],[\"耗时短以达到更快编译的速度\",{\"1\":{\"7\":1}}],[\"90000\",{\"1\":{\"142\":2,\"144\":1,\"146\":2}}],[\"9开始默认使用\",{\"1\":{\"71\":1}}],[\"9\",{\"1\":{\"70\":1,\"232\":1}}],[\"99\",{\"1\":{\"32\":1}}],[\"计较速度比较快\",{\"1\":{\"114\":1}}],[\"计算得出\",{\"1\":{\"93\":1}}],[\"计算内存99\",{\"1\":{\"70\":1}}],[\"计数器表在web应用中很常见\",{\"1\":{\"223\":1}}],[\"计数器表\",{\"0\":{\"223\":1}}],[\"计数器\",{\"1\":{\"22\":1}}],[\"计数器的计数一旦溢出阈值\",{\"1\":{\"6\":1}}],[\"预估表的访问成本\",{\"1\":{\"129\":1}}],[\"预热触发\",{\"1\":{\"70\":1}}],[\"预留位\",{\"1\":{\"66\":1}}],[\"定位到之后前20个字符的前缀匹配的部分数据之后\",{\"1\":{\"136\":1}}],[\"定位到\",{\"1\":{\"111\":3}}],[\"定位位置\",{\"1\":{\"99\":1}}],[\"定时触发\",{\"1\":{\"70\":1}}],[\"定义\",{\"1\":{\"52\":1,\"210\":1,\"211\":1,\"212\":1}}],[\"看是否是大对象导致gc回收效率跟不上分配效率导致内存变高\",{\"1\":{\"69\":1}}],[\"看情况使用final\",{\"1\":{\"8\":1}}],[\"发生锁冲突的概率低\",{\"1\":{\"171\":1}}],[\"发生方法内联的前提是要让这个方法循环足够的次数\",{\"1\":{\"8\":1}}],[\"发现数据被修改和删除了\",{\"1\":{\"165\":1}}],[\"发现zgc使用了内存映射技术\",{\"1\":{\"69\":1}}],[\"发现jvm命令给出的堆内占用和jstat差不多\",{\"1\":{\"69\":1}}],[\"变成了jhsdb\",{\"1\":{\"69\":1}}],[\"想使用jmap\",{\"1\":{\"69\":1}}],[\"前端没有数据总数\",{\"1\":{\"145\":1}}],[\"前端编译\",{\"0\":{\"3\":1}}],[\"前置启动程序\",{\"0\":{\"77\":1}}],[\"前同事问过一个zgc导致内存飙高的问题\",{\"1\":{\"69\":1}}],[\"远不像cms那么复杂\",{\"1\":{\"69\":1}}],[\"远远比并发标记阶段时间短\",{\"1\":{\"39\":1}}],[\"作者\",{\"1\":{\"69\":1}}],[\"作用是统计一个方法中循环体代码执行的次数\",{\"1\":{\"6\":1}}],[\"喘息空间\",{\"1\":{\"69\":1}}],[\"方式存储在内存中\",{\"1\":{\"197\":1}}],[\"方式就是增大整个gc堆的大小来让zgc有更大的喘息空间\",{\"1\":{\"69\":1}}],[\"方法返回之前\",{\"1\":{\"73\":1}}],[\"方法区主要回收的是无用的类\",{\"1\":{\"29\":1}}],[\"方法只会被执行一次\",{\"1\":{\"28\":1}}],[\"方法\",{\"1\":{\"28\":1}}],[\"方法如果需要继承\",{\"1\":{\"8\":1}}],[\"方法太大不光会导致方法无法内联\",{\"1\":{\"8\":1}}],[\"方法内联之后会继续进行无用代码消除\",{\"1\":{\"8\":1}}],[\"方法内联往往还是很多后续优化手段的基础\",{\"1\":{\"8\":1}}],[\"方法内联的优化本质就是把目标方法的代码原封不动的\",{\"1\":{\"8\":1}}],[\"方法内联就是将目标方法的执行代码复制到调用该方法的地方\",{\"1\":{\"8\":1}}],[\"方法内联\",{\"0\":{\"8\":1}}],[\"方法调用计数器\",{\"1\":{\"6\":1}}],[\"答案肯定是不可以\",{\"1\":{\"68\":1}}],[\"既然低42位指针可以支持4t内存\",{\"1\":{\"68\":1}}],[\"判断对象是bad\",{\"1\":{\"68\":1}}],[\"官方的测试数据是需要多出额外4\",{\"1\":{\"68\":1}}],[\"正是通过这套机制\",{\"1\":{\"191\":1,\"203\":1}}],[\"正是因为load\",{\"1\":{\"68\":1}}],[\"正常读取数据\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"正常情况按照最左前缀原则\",{\"1\":{\"127\":1}}],[\"正常情况g1的垃圾收集是先做mixedgc\",{\"1\":{\"55\":1}}],[\"正常情况不会被回收\",{\"1\":{\"27\":1}}],[\"正常情况下\",{\"1\":{\"11\":1}}],[\"正好对应\",{\"1\":{\"107\":1}}],[\"正在\",{\"1\":{\"105\":1}}],[\"于是不断往里面放缓存数据\",{\"1\":{\"95\":1}}],[\"于是应用代码就永远都会持有更新后的有效指针\",{\"1\":{\"68\":1}}],[\"于是引用计数算法无法通知\",{\"1\":{\"25\":1}}],[\"给之后使用\",{\"1\":{\"66\":1}}],[\"给某个对象的成员变量赋值时\",{\"1\":{\"44\":1}}],[\"颜色指针具备强大的扩展性\",{\"1\":{\"67\":1}}],[\"颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量\",{\"1\":{\"67\":1}}],[\"颜色指针就会互换标志位\",{\"1\":{\"66\":1}}],[\"颜色指针\",{\"0\":{\"66\":1}}],[\"颜色指针等技术实现可并发收集垃圾的垃圾收集器\",{\"1\":{\"64\":1}}],[\"原子性由undo\",{\"1\":{\"164\":1}}],[\"原子性\",{\"1\":{\"164\":1}}],[\"原则\",{\"1\":{\"152\":1}}],[\"原因是\",{\"1\":{\"146\":1}}],[\"原来记录新旧对象关系的转发表就可以释放掉了\",{\"1\":{\"65\":1}}],[\"原始快照\",{\"1\":{\"43\":1}}],[\"反范式化设计的优缺点\",{\"0\":{\"218\":1}}],[\"反范式化设计\",{\"0\":{\"213\":1},\"1\":{\"219\":1}}],[\"反之则是乱七八糟\",{\"1\":{\"209\":1}}],[\"反而\",{\"1\":{\"100\":1}}],[\"反而会适得其反\",{\"1\":{\"62\":1}}],[\"反正它们都是要遍历所有对象的\",{\"1\":{\"65\":1}}],[\"功能\",{\"1\":{\"65\":1}}],[\"功能之外\",{\"1\":{\"47\":1}}],[\"能写在where中的限定条件就不要去having限定了\",{\"1\":{\"131\":1}}],[\"能用覆盖索引尽量用覆盖索引\",{\"1\":{\"131\":1}}],[\"能不能使用一种数据结构来存储数据\",{\"1\":{\"98\":1}}],[\"能力\",{\"1\":{\"65\":2}}],[\"能让使用者明确指定在一个长度为m毫秒的时间片段\",{\"1\":{\"52\":1}}],[\"自己内部的优化机制\",{\"1\":{\"199\":1}}],[\"自己可正常读取\",{\"1\":{\"170\":1}}],[\"自己实现的\",{\"1\":{\"99\":1}}],[\"自然是减少磁盘\",{\"1\":{\"98\":1}}],[\"自然可以获得很高的单线程收集效率\",{\"1\":{\"36\":1}}],[\"自愈\",{\"1\":{\"65\":3}}],[\"容量不固定\",{\"1\":{\"64\":1}}],[\"容量固定为32mb\",{\"1\":{\"64\":1}}],[\"容量固定为2mb\",{\"1\":{\"64\":1}}],[\"容纳的话\",{\"1\":{\"22\":1}}],[\"小表驱动大表\",{\"1\":{\"152\":1}}],[\"小型region\",{\"1\":{\"64\":1}}],[\"小三类\",{\"1\":{\"64\":1}}],[\"小于等于32g\",{\"1\":{\"19\":1}}],[\"zzz\",{\"1\":{\"129\":3}}],[\"zhuge\",{\"1\":{\"121\":1,\"177\":1,\"239\":3,\"240\":3}}],[\"zhihu\",{\"1\":{\"63\":1}}],[\"zgc目前有4中机制触发gc\",{\"1\":{\"70\":1}}],[\"zgc内存突破物理内存\",{\"1\":{\"69\":1}}],[\"zgc内存布局\",{\"0\":{\"64\":1}}],[\"zgc回收垃圾时\",{\"1\":{\"69\":1}}],[\"zgc问题\",{\"1\":{\"69\":1}}],[\"zgc最大的问题是浮动垃圾\",{\"1\":{\"69\":1}}],[\"zgc最大只能支持16t的内存\",{\"1\":{\"68\":1}}],[\"zgc存在的问题\",{\"0\":{\"69\":1}}],[\"zgc使用了完全不同的读屏障\",{\"1\":{\"68\":1}}],[\"zgc使用了指针的第19\",{\"1\":{\"66\":1}}],[\"zgc之前的垃圾回收器在处理漏标时使用的都是写屏障\",{\"1\":{\"68\":1}}],[\"zgc只使用了读屏障\",{\"1\":{\"67\":1}}],[\"zgc就能完成收集\",{\"1\":{\"67\":1}}],[\"zgc很巧妙地把并发重映射阶段要做的工作\",{\"1\":{\"65\":1}}],[\"zgc将这种行为称为指针的\",{\"1\":{\"65\":1}}],[\"zgc每次回收都会扫描所有的region\",{\"1\":{\"65\":1}}],[\"zgc收集过程\",{\"0\":{\"65\":1}}],[\"zgc收集器能仅从引用上就明确得知一个对象是否处于重分配集之中\",{\"1\":{\"65\":1}}],[\"zgc收集器\",{\"0\":{\"61\":1}}],[\"zgc的停顿时间是在10ms以下\",{\"1\":{\"69\":1}}],[\"zgc的核心设计之一\",{\"1\":{\"66\":1}}],[\"zgc的颜色指针因为\",{\"1\":{\"65\":1}}],[\"zgc的region可分为大\",{\"1\":{\"64\":1}}],[\"zgc的目标\",{\"0\":{\"62\":1}}],[\"zgc是一款基于region内存布局的\",{\"1\":{\"64\":1}}],[\"zgc是根据azul的论文\",{\"1\":{\"61\":1}}],[\"zgc是jdk11开始引入的一个新的低延时垃圾收集器\",{\"1\":{\"61\":1}}],[\"zgc和shenandoah收集器\",{\"1\":{\"48\":1}}],[\"zgc\",{\"1\":{\"47\":1,\"61\":2,\"63\":1}}],[\"具体被划分为\",{\"1\":{\"66\":1}}],[\"具体可参考r大在2018年知乎的回答\",{\"1\":{\"63\":1}}],[\"具体的优化策略可参见openjdk的wiki\",{\"1\":{\"7\":1}}],[\"几乎不会出现并发问题\",{\"1\":{\"167\":1}}],[\"几乎不用\",{\"1\":{\"27\":1}}],[\"几百g以上用zgc\",{\"1\":{\"71\":1}}],[\"几百g甚至上t堆的停顿时间也是10ms以下\",{\"1\":{\"62\":1}}],[\"几十g堆的停顿时间是10ms以下\",{\"1\":{\"62\":1}}],[\"奠定未来gc的基础\",{\"1\":{\"62\":1}}],[\"支持\",{\"1\":{\"201\":1}}],[\"支持tb量级的堆\",{\"1\":{\"62\":1}}],[\"支持最高tb级别内存的垃圾回收\",{\"1\":{\"61\":1}}],[\"扫描了100行数据\",{\"1\":{\"150\":1}}],[\"扫描行数\",{\"1\":{\"129\":1}}],[\"扫描的行rows看上去也少了点\",{\"1\":{\"124\":1}}],[\"扫描\",{\"1\":{\"61\":1}}],[\"参与连接的数据\",{\"1\":{\"151\":1}}],[\"参考文章\",{\"1\":{\"61\":1}}],[\"参数是链接数据库的端口\",{\"1\":{\"196\":1}}],[\"参数是链接数据库的\",{\"1\":{\"196\":1}}],[\"参数使用\",{\"1\":{\"8\":1}}],[\"参数\",{\"1\":{\"8\":1,\"197\":1}}],[\"参数信息\",{\"1\":{\"7\":1}}],[\"适用二叉树存储导致二叉树过高\",{\"1\":{\"100\":1}}],[\"适用场景\",{\"1\":{\"60\":1}}],[\"适当提高该值\",{\"1\":{\"0\":1}}],[\"处理还是要花不少时间的\",{\"1\":{\"60\":1}}],[\"停顿时间是500ms以内\",{\"1\":{\"59\":1}}],[\"停止系统线程\",{\"1\":{\"56\":1}}],[\"建议用字段的前20位作为索引\",{\"1\":{\"232\":1}}],[\"建议值\",{\"1\":{\"59\":1}}],[\"建立了索引之后\",{\"1\":{\"118\":1}}],[\"建立回边计数器就是为了发现一个方法体内被频繁调用的循环\",{\"1\":{\"6\":1}}],[\"垃圾回收时间特别长\",{\"1\":{\"59\":1}}],[\"垃圾收集器\",{\"2\":{\"50\":1,\"75\":1}}],[\"垃圾收集场景中\",{\"1\":{\"48\":1}}],[\"垃圾收集算法细节之三色标记\",{\"1\":{\"41\":1}}],[\"垃圾收集子系统的压力将会下降很多\",{\"1\":{\"11\":1}}],[\"频繁触发mixed\",{\"1\":{\"58\":1}}],[\"达到了survivor区域的50\",{\"1\":{\"58\":1}}],[\"达到该值就会触发full\",{\"1\":{\"0\":1}}],[\"了\",{\"1\":{\"58\":1,\"139\":1,\"197\":1,\"198\":1}}],[\"意味着本次混合回收就结束了\",{\"1\":{\"57\":1}}],[\"总结\",{\"0\":{\"214\":1}}],[\"总体来说\",{\"1\":{\"194\":1}}],[\"总共扫描磁盘100\",{\"1\":{\"150\":1}}],[\"总共200行\",{\"1\":{\"148\":1}}],[\"总和超过了survivor区域的50\",{\"1\":{\"57\":1}}],[\"总消耗时间的比值\",{\"1\":{\"37\":1}}],[\"目录下\",{\"1\":{\"109\":1}}],[\"目前关系数据库有六种范式\",{\"1\":{\"209\":1}}],[\"目前唯一有效的\",{\"1\":{\"69\":1}}],[\"目前一般线上环境运行良好的java应用minor\",{\"1\":{\"62\":1}}],[\"目标暂停时间\",{\"1\":{\"57\":1}}],[\"目的就是让这种对象在本轮gc清理中能存活下来\",{\"1\":{\"43\":1}}],[\"拷贝的过程中发现没有足够的空region能够承载拷贝对象就会触发一次fullgc\",{\"1\":{\"55\":1}}],[\"继续给新对象存放\",{\"1\":{\"54\":1}}],[\"毕竟g1是要冻结用户线程来复制对象的\",{\"1\":{\"52\":1}}],[\"期望值\",{\"1\":{\"52\":1}}],[\"降低停顿时间是g1\",{\"1\":{\"52\":1}}],[\"降低cms\",{\"1\":{\"40\":1}}],[\"清理和压缩整理\",{\"1\":{\"56\":1}}],[\"清理\",{\"1\":{\"52\":1}}],[\"清除​\",{\"1\":{\"39\":1}}],[\"清除算法\",{\"0\":{\"34\":1}}],[\"清除\",{\"1\":{\"32\":2,\"34\":1,\"35\":1,\"39\":1}}],[\"虽然全部使用sort\",{\"1\":{\"240\":1}}],[\"虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下\",{\"1\":{\"179\":1}}],[\"虽然排序的字段列与索引顺序一样\",{\"1\":{\"131\":1}}],[\"虽然使用了强制走索引让联合索引第一个字段范围查找也走索引\",{\"1\":{\"124\":1}}],[\"虽然g1可以不需要其他收集器配合就能独立管理整个gc堆\",{\"1\":{\"52\":1}}],[\"虽然我们对各个收集器进行比较\",{\"1\":{\"35\":1}}],[\"暂时不分代的垃圾收集器\",{\"1\":{\"64\":1}}],[\"暂时\",{\"0\":{\"63\":1}}],[\"暂不处理\",{\"1\":{\"52\":1}}],[\"暂停所有其他线程\",{\"1\":{\"52\":3}}],[\"暂停所有的其他线程\",{\"1\":{\"39\":1}}],[\"优点\",{\"0\":{\"216\":1,\"219\":1}}],[\"优先级=5​\",{\"1\":{\"83\":1}}],[\"优先调整堆的大小让服务器自己来选择\",{\"1\":{\"71\":1}}],[\"优先选择回收价值最大的region\",{\"1\":{\"52\":1}}],[\"优化器是在表里面有多个索引的时候\",{\"1\":{\"199\":1}}],[\"优化器\",{\"0\":{\"199\":1},\"1\":{\"194\":1,\"195\":1}}],[\"优化方法\",{\"0\":{\"151\":1}}],[\"优化关键是让排序时返回的字段尽可能少\",{\"1\":{\"146\":1}}],[\"优化\",{\"0\":{\"143\":1}}],[\"优化总结\",{\"1\":{\"131\":1}}],[\"优化应用\",{\"1\":{\"77\":1}}],[\"优化的规模与耗时\",{\"1\":{\"7\":1}}],[\"优化后的机器码执行效率更高\",{\"1\":{\"7\":1}}],[\"注\",{\"1\":{\"52\":1,\"61\":1}}],[\"注意最大值指的是整个\",{\"1\":{\"204\":1}}],[\"注意最后那个20也是包含在内的\",{\"1\":{\"177\":1}}],[\"注意\",{\"1\":{\"28\":1,\"32\":1,\"90\":1,\"101\":1,\"107\":1,\"109\":1,\"131\":1,\"139\":1,\"150\":1,\"189\":1,\"240\":1}}],[\"时代表文件无可写入内容\",{\"1\":{\"205\":1}}],[\"时不指定表的存储引擎类型\",{\"1\":{\"201\":1}}],[\"时\",{\"1\":{\"189\":1,\"197\":1}}],[\"时的最左前缀法则\",{\"1\":{\"131\":1}}],[\"时的开销\",{\"1\":{\"40\":1}}],[\"时候所能加载的数据比较少\",{\"1\":{\"102\":1}}],[\"时间长了除了导致full\",{\"1\":{\"95\":1}}],[\"时间长了就会导致full\",{\"1\":{\"95\":1}}],[\"时间是用户可控制的\",{\"1\":{\"52\":1}}],[\"时触发\",{\"1\":{\"70\":1}}],[\"筛选回收阶段首先对各个region的回收价值和成本进行排序\",{\"1\":{\"52\":1}}],[\"筛选回收\",{\"1\":{\"52\":1}}],[\"筛选的条件是此对象是否有必要执行finalize\",{\"1\":{\"28\":1}}],[\"最常见的反范式化方法是对数据进行缓存\",{\"1\":{\"222\":1}}],[\"最小值为\",{\"1\":{\"204\":1}}],[\"最小容量可低至4mb\",{\"1\":{\"64\":1}}],[\"最优访问路径\",{\"1\":{\"129\":1}}],[\"最多三次\",{\"1\":{\"70\":1}}],[\"最后可以看到mysql会自动检测出死锁的情况\",{\"1\":{\"183\":1}}],[\"最后基于limit进行分页\",{\"1\":{\"139\":1}}],[\"最后根据索引值存储的磁盘文件地址找到具体的数据\",{\"1\":{\"99\":1}}],[\"最后估计还是要优化代码\",{\"1\":{\"69\":1}}],[\"最后通过在上查到的解答\",{\"1\":{\"69\":1}}],[\"最开始以为是大对象占用太多\",{\"1\":{\"69\":1}}],[\"最糟糕的情况下吞吐量下降15\",{\"1\":{\"62\":1}}],[\"最大值为\",{\"1\":{\"204\":1}}],[\"最大值是\",{\"1\":{\"204\":1}}],[\"最大\",{\"1\":{\"107\":1,\"204\":1}}],[\"最大的gc停顿时间不超过10ms\",{\"1\":{\"62\":1}}],[\"最大年龄阈值\",{\"1\":{\"57\":1}}],[\"最终选择的访问路径\",{\"1\":{\"129\":1}}],[\"最终占满堆引发full\",{\"1\":{\"52\":1}}],[\"最终标记\",{\"1\":{\"52\":1}}],[\"最简单的做法就是一个指令就翻译一次成为机器码进行之心\",{\"1\":{\"5\":1}}],[\"与\",{\"1\":{\"202\":1}}],[\"与join\",{\"1\":{\"149\":1}}],[\"与case\",{\"1\":{\"131\":1}}],[\"与cms的\",{\"1\":{\"52\":1}}],[\"与数据库相关的所有内容都存储在\",{\"1\":{\"107\":1}}],[\"与marked0配合使用\",{\"1\":{\"66\":1}}],[\"与业务线程一起运行\",{\"1\":{\"52\":1}}],[\"与其他收集器的单线程相比\",{\"1\":{\"36\":1}}],[\"唯一不同的是对大对象的处理\",{\"1\":{\"52\":1}}],[\"之后该链接的所有权限会从缓存中获取\",{\"1\":{\"196\":1}}],[\"之后可能又会变成老年代\",{\"1\":{\"52\":1}}],[\"之间\",{\"1\":{\"111\":2}}],[\"之间的子节点数据\",{\"1\":{\"105\":1}}],[\"之间的页数据的内存地址\",{\"1\":{\"105\":1}}],[\"之间的节点上\",{\"1\":{\"105\":2}}],[\"之前执行的\",{\"1\":{\"197\":1}}],[\"之前讲过联合索引范围之后条件的是不能用索引的\",{\"1\":{\"139\":1}}],[\"之前的垃圾收集器进行分代区分是基于\",{\"1\":{\"63\":1}}],[\"之前说过\",{\"1\":{\"7\":1}}],[\"之所以能做到这一点是因为它的停顿时间主要跟root扫描有关\",{\"1\":{\"62\":1}}],[\"假如我们想查询\",{\"1\":{\"105\":1}}],[\"假如zgc全过程需要执行10分钟\",{\"1\":{\"69\":1}}],[\"假如逃逸分析能够证明一个对象不会被方法外部访问\",{\"1\":{\"10\":1}}],[\"假设可能还有一个筛选条件\",{\"1\":{\"139\":1}}],[\"假设又有用户根据年龄范围去筛选了\",{\"1\":{\"139\":1}}],[\"假设是每行记录\",{\"1\":{\"107\":1}}],[\"假设是每5分钟一次\",{\"1\":{\"92\":1}}],[\"假设50ms能够回收三到四个g内存\",{\"1\":{\"60\":1}}],[\"假设三四十g内存回收可能最快也要几秒钟\",{\"1\":{\"60\":1}}],[\"假设参数\",{\"1\":{\"58\":1}}],[\"假设年轻代现在有1000个region\",{\"1\":{\"52\":1}}],[\"他们生产已经飙到了20g\",{\"1\":{\"69\":1}}],[\"他们都是\",{\"1\":{\"52\":1}}],[\"他也不可能像堆中那么豪横的使用内存空间\",{\"1\":{\"11\":1}}],[\"下面的三条\",{\"1\":{\"118\":1}}],[\"下图有连线的可以搭配使用\",{\"1\":{\"71\":1}}],[\"下图所示是zgc可以调优的参数\",{\"1\":{\"69\":1}}],[\"下\",{\"0\":{\"51\":1}}],[\"卡页\",{\"1\":{\"48\":1}}],[\"卡表变脏上面已经说了\",{\"1\":{\"49\":1}}],[\"卡表是使用一个字节数组实现\",{\"1\":{\"48\":1}}],[\"卡表\",{\"1\":{\"48\":1}}],[\"关键字写错\",{\"1\":{\"198\":1}}],[\"关闭trace\",{\"1\":{\"129\":1}}],[\"关闭查询缓存\",{\"1\":{\"124\":1}}],[\"关闭资源\",{\"1\":{\"28\":1}}],[\"关于卡表与记忆集的关系\",{\"1\":{\"48\":1}}],[\"典型的如g1\",{\"1\":{\"48\":1}}],[\"到t1表中获取数据\",{\"1\":{\"148\":1}}],[\"到底是让where去用上索引\",{\"1\":{\"137\":1}}],[\"到底是针对where去设计索引\",{\"1\":{\"137\":1}}],[\"到主键索引上找出相应的记录\",{\"1\":{\"127\":1}}],[\"到\",{\"1\":{\"105\":2}}],[\"到原本的字段里\",{\"1\":{\"68\":1}}],[\"到收集区\",{\"1\":{\"48\":1}}],[\"到发起调用的方法之中\",{\"1\":{\"8\":1}}],[\"记忆集与卡表\",{\"0\":{\"48\":1}}],[\"记录的主键\",{\"1\":{\"240\":1}}],[\"记录网站的点击次数\",{\"1\":{\"223\":1}}],[\"记录\",{\"1\":{\"205\":1}}],[\"记录从旧对象到新对象的转向关系\",{\"1\":{\"65\":1}}],[\"记录从非收集区\",{\"1\":{\"48\":1}}],[\"记录指针是否已经被标记\",{\"1\":{\"65\":1}}],[\"记录对象是否一般标记\",{\"1\":{\"65\":1}}],[\"记录读取到的对象\",{\"1\":{\"47\":1}}],[\"记录原来的引用对象\",{\"1\":{\"45\":1}}],[\"记录那些内存块可用\",{\"1\":{\"16\":1}}],[\"我的理解\",{\"1\":{\"47\":1}}],[\"我们要表示的数据类型大小是可以根据业务推断出来的\",{\"1\":{\"230\":1}}],[\"我们尝试着把age字段加入联合索引\",{\"1\":{\"139\":1}}],[\"我们可能还会根据评分来排序等等\",{\"1\":{\"139\":1}}],[\"我们可以用trace工具来一查究竟\",{\"1\":{\"129\":1}}],[\"我们可以针对一张表设置存储引擎\",{\"1\":{\"109\":1}}],[\"我们可以增加树的高度\",{\"1\":{\"107\":1}}],[\"我们可以看到每个数据库都是一个文件夹\",{\"1\":{\"109\":1}}],[\"我们可以看到\",{\"1\":{\"100\":1,\"101\":1}}],[\"我们可以考虑\",{\"1\":{\"98\":1}}],[\"我们可以使用g1收集器\",{\"1\":{\"60\":1}}],[\"我们可以利用写屏障\",{\"1\":{\"45\":1,\"46\":1}}],[\"我们可以通过以下一些方法提高内联发生的概率\",{\"1\":{\"8\":1}}],[\"我们一般会筛选地区\",{\"1\":{\"139\":1}}],[\"我们一般会去搜索一些好友\",{\"1\":{\"139\":1}}],[\"我们先不考虑分库分表的情况\",{\"1\":{\"139\":1}}],[\"我们创建的索引\",{\"1\":{\"115\":1}}],[\"我们进入到某个文件夹下\",{\"1\":{\"109\":1}}],[\"我们只需要定位两个节点\",{\"1\":{\"106\":1}}],[\"我们知道\",{\"1\":{\"106\":1,\"107\":1,\"118\":1}}],[\"我们需要理解到\",{\"1\":{\"101\":1}}],[\"我们发现它不像二叉树一样严格的按照左子树小于根节点\",{\"1\":{\"101\":1}}],[\"我们来观察一下\",{\"1\":{\"101\":1}}],[\"我们插入\",{\"1\":{\"101\":1}}],[\"我们插入到数据表中的数据\",{\"1\":{\"98\":1}}],[\"我们自然是要减少数据比对的次数\",{\"1\":{\"98\":1}}],[\"我们以前常说的对于eden区的young\",{\"1\":{\"60\":1}}],[\"我们能做的就是根据具体应用场景选择适合自己的垃圾收集器\",{\"1\":{\"35\":1}}],[\"我们更关注jvm在后端编译过程中如何提升执⾏的效率\",{\"1\":{\"4\":1}}],[\"区间都无法修改数据\",{\"1\":{\"177\":1}}],[\"区引用的变化\",{\"1\":{\"47\":1}}],[\"区别主要在于它可以和\",{\"1\":{\"38\":1}}],[\"工程实现中\",{\"1\":{\"47\":1}}],[\"深度遍历等等\",{\"1\":{\"47\":1}}],[\"深入理解jvm执行引擎\",{\"0\":{\"2\":1}}],[\"缓存表用实时维护数据更多点\",{\"1\":{\"222\":1}}],[\"缓存和汇总\",{\"0\":{\"222\":1}}],[\"缓存的命中会非常低\",{\"1\":{\"197\":1}}],[\"缓存失效的非常快\",{\"1\":{\"197\":1}}],[\"缓存日志等方式进行实现\",{\"1\":{\"47\":1}}],[\"缓刑\",{\"1\":{\"28\":1}}],[\"队列\",{\"1\":{\"47\":1}}],[\"赋值操作\",{\"1\":{\"44\":1}}],[\"新值\",{\"1\":{\"44\":1}}],[\"新生代内存最大空间\",{\"1\":{\"57\":1}}],[\"新生代内存初始空间\",{\"1\":{\"57\":1}}],[\"新生代\",{\"1\":{\"48\":1}}],[\"新生代采用复制算法​\",{\"1\":{\"36\":1,\"37\":1,\"38\":1}}],[\"新生代大小\",{\"1\":{\"0\":1}}],[\"某对象的成员变量\",{\"1\":{\"44\":1}}],[\"待下一轮gc的时候重新扫描\",{\"1\":{\"43\":1}}],[\"增量更新\",{\"1\":{\"43\":2,\"47\":1}}],[\"漏标会导致被引用的对象被当成垃圾误删除\",{\"1\":{\"43\":1}}],[\"漏标\",{\"0\":{\"43\":1},\"1\":{\"52\":1}}],[\"本次垃圾回收可能只能停顿200毫秒\",{\"1\":{\"52\":1}}],[\"本轮不会进行清除\",{\"1\":{\"42\":1}}],[\"本地方法栈的变量等等\",{\"1\":{\"26\":1}}],[\"本地线程分配缓冲\",{\"1\":{\"16\":1}}],[\"被驱动表的关联字段添加索引\",{\"1\":{\"151\":1}}],[\"被称之为\",{\"1\":{\"42\":1}}],[\"被标记为非垃圾对象\",{\"1\":{\"42\":1}}],[\"被销毁\",{\"1\":{\"42\":1}}],[\"浮动垃圾并不会影响垃圾回收的正确性\",{\"1\":{\"42\":1}}],[\"浮动垃圾\",{\"0\":{\"42\":1},\"1\":{\"42\":1}}],[\"写到文件系统的\",{\"1\":{\"205\":1}}],[\"写到操作系统的\",{\"1\":{\"205\":1}}],[\"写日志时向后移动\",{\"1\":{\"205\":1}}],[\"写完第一个文件的结尾\",{\"1\":{\"205\":1}}],[\"写入磁盘过程分析\",{\"0\":{\"205\":1}}],[\"写锁\",{\"1\":{\"167\":1}}],[\"写法如下\",{\"1\":{\"145\":1}}],[\"写后操作\",{\"1\":{\"44\":1}}],[\"写前操作\",{\"1\":{\"44\":1}}],[\"写屏障\",{\"0\":{\"44\":1},\"1\":{\"44\":2,\"47\":2}}],[\"写\",{\"1\":{\"41\":2}}],[\"读已提交的隔离级别则在每次执行查询语句的时候重新生成read\",{\"1\":{\"188\":1}}],[\"读已提交\",{\"0\":{\"174\":1}}],[\"读已提交reda\",{\"1\":{\"172\":1}}],[\"读未提交\",{\"0\":{\"173\":1}}],[\"读未提交read\",{\"1\":{\"172\":1}}],[\"读锁\",{\"1\":{\"167\":1}}],[\"读取trx\",{\"1\":{\"189\":1}}],[\"读取到了其他事务插入的满足查询条件的数据\",{\"1\":{\"165\":1}}],[\"读取到了另一个事务b对该数据未提交的修改\",{\"1\":{\"165\":1}}],[\"读取前操作\",{\"1\":{\"47\":1}}],[\"读屏障也会发现并修正指针\",{\"1\":{\"68\":1}}],[\"读屏障可以用于支持移动对象的并发执行等\",{\"1\":{\"47\":1}}],[\"读屏障是直接针对第一步\",{\"1\":{\"47\":1}}],[\"读屏障\",{\"0\":{\"47\":1},\"1\":{\"47\":2,\"65\":1}}],[\"读写屏障还有其他功能\",{\"1\":{\"47\":1}}],[\"读写屏障\",{\"0\":{\"43\":1}}],[\"读\",{\"1\":{\"41\":1}}],[\"开销小\",{\"1\":{\"167\":1}}],[\"开头的索引之后\",{\"1\":{\"127\":1}}],[\"开头的索引\",{\"1\":{\"127\":1}}],[\"开始执行的时候\",{\"1\":{\"200\":1}}],[\"开始后产生的新对象\",{\"1\":{\"42\":1}}],[\"开始做并发标记\",{\"1\":{\"41\":1}}],[\"开启trace\",{\"1\":{\"129\":1}}],[\"开启trace工具会影响mysql性能\",{\"1\":{\"129\":1}}],[\"开启用户线程\",{\"1\":{\"39\":1}}],[\"开启全部性能监控\",{\"1\":{\"7\":1}}],[\"请忽略\",{\"1\":{\"41\":1}}],[\"代表当sql语句中有sql\",{\"1\":{\"197\":1}}],[\"代表每次fullgc后都会压缩一次\",{\"1\":{\"40\":1}}],[\"代码先行\",{\"0\":{\"133\":1}}],[\"代码写法可能不规范\",{\"1\":{\"41\":1}}],[\"白色\",{\"1\":{\"41\":1}}],[\"灰色集合可以通过栈\",{\"1\":{\"47\":1}}],[\"灰色\",{\"1\":{\"41\":1}}],[\"且等待所花平均时间较长时\",{\"1\":{\"181\":1}}],[\"且最好使用redis原子性增加或减少的方法\",{\"1\":{\"159\":1}}],[\"且a字段建立了索引\",{\"1\":{\"148\":1}}],[\"且没有其他条件\",{\"1\":{\"145\":1}}],[\"且order\",{\"1\":{\"131\":1}}],[\"且必须是2的n次幂\",{\"1\":{\"57\":1}}],[\"且这个对象的所有引用都已经扫描过\",{\"1\":{\"41\":1}}],[\"且gc压力会比较大\",{\"1\":{\"19\":1}}],[\"黑色集合一般都不会出现\",{\"1\":{\"47\":1}}],[\"黑色对象一旦新插入了指向白色对象的引用之后\",{\"1\":{\"43\":1}}],[\"黑色对象不可能直接\",{\"1\":{\"41\":1}}],[\"黑色的对象代表已经扫描过\",{\"1\":{\"41\":1}}],[\"黑色\",{\"1\":{\"41\":1}}],[\"按物理角度分\",{\"0\":{\"227\":1}}],[\"按结构分\",{\"0\":{\"226\":1}}],[\"按行累加\",{\"1\":{\"155\":1}}],[\"按kafka这个并发量放满三四十g的eden区可能也就一两分钟\",{\"1\":{\"60\":1}}],[\"按照字段\",{\"1\":{\"240\":1}}],[\"按照\",{\"1\":{\"41\":1,\"240\":1}}],[\"按后退时\",{\"1\":{\"27\":1}}],[\"缩短stw\",{\"1\":{\"40\":2}}],[\"多范围读取\",{\"1\":{\"228\":1}}],[\"多个读之间不影响\",{\"1\":{\"167\":1}}],[\"多个相等条件也是范围查询\",{\"1\":{\"131\":1}}],[\"多次进行磁盘\",{\"1\":{\"98\":1}}],[\"多核环境下的硬件优势\",{\"1\":{\"52\":1}}],[\"多标\",{\"0\":{\"42\":1},\"1\":{\"52\":1}}],[\"多标和漏标的情况就有可能发生\",{\"1\":{\"41\":1}}],[\"多少次fullgc之后压缩一次\",{\"1\":{\"40\":1}}],[\"多线程并发资源竞争是一个很复杂的场景\",{\"1\":{\"12\":1}}],[\"减少了索引i\",{\"1\":{\"230\":1}}],[\"减少锁定资源量和时间长度\",{\"1\":{\"184\":1}}],[\"减少碎片\",{\"1\":{\"40\":1}}],[\"减少热点阈值或增加方法体阈值\",{\"1\":{\"8\":1}}],[\"用trace工具可以看到sort\",{\"1\":{\"238\":2}}],[\"用版本比对\",{\"1\":{\"167\":1}}],[\"用户的朋友数\",{\"1\":{\"223\":1}}],[\"用户操作和表结构操作\",{\"1\":{\"206\":1}}],[\"用户名和密码正确\",{\"1\":{\"196\":1}}],[\"用户名或密码错误\",{\"1\":{\"196\":1}}],[\"用户\",{\"1\":{\"196\":1}}],[\"用户如果一周内有登录值就为1\",{\"1\":{\"139\":1}}],[\"用户几乎无感知\",{\"1\":{\"60\":1}}],[\"用完之后立即关闭\",{\"1\":{\"129\":1}}],[\"用了索引下推优化\",{\"1\":{\"128\":1}}],[\"用这一列构建\",{\"1\":{\"114\":1}}],[\"用来构建整个\",{\"1\":{\"104\":1}}],[\"用来判断是否需要对方法进行内联优化\",{\"1\":{\"8\":1}}],[\"用\",{\"1\":{\"89\":1,\"98\":1}}],[\"用于指定一个输出多少次数据\",{\"1\":{\"88\":1}}],[\"用于指定输出统计数据的周期\",{\"1\":{\"88\":1}}],[\"用于并发引用有关\",{\"1\":{\"66\":1}}],[\"用于放置4mb或以上的大对象\",{\"1\":{\"64\":1}}],[\"用于放置大于等于256kb但小于4mb的对象\",{\"1\":{\"64\":1}}],[\"用于放置小于256kb的小对象\",{\"1\":{\"64\":1}}],[\"用范围更大的扫描成本换取省去g1中记忆集的维护成本\",{\"1\":{\"65\":1}}],[\"用serial\",{\"1\":{\"39\":1}}],[\"特定的位置有\",{\"1\":{\"73\":1}}],[\"特别是在并发标记和并发清理阶段会出现\",{\"1\":{\"39\":1}}],[\"特出的一种标记算法\",{\"1\":{\"35\":1}}],[\"低停顿\",{\"1\":{\"39\":1}}],[\"重做日志关键参数\",{\"0\":{\"204\":1}}],[\"重复\",{\"1\":{\"240\":1}}],[\"重复步骤\",{\"1\":{\"239\":1}}],[\"重复上述过程\",{\"1\":{\"150\":1}}],[\"重复8次\",{\"1\":{\"57\":1}}],[\"重定位过程相关的数据\",{\"1\":{\"67\":1}}],[\"重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用\",{\"1\":{\"65\":1}}],[\"重分配是zgc执行过程中的核心阶段\",{\"1\":{\"65\":1}}],[\"重新执行后\",{\"1\":{\"69\":1}}],[\"重新深度扫描对象的话g1的代价会比cms高\",{\"1\":{\"47\":1}}],[\"重新扫描一次\",{\"1\":{\"43\":2}}],[\"重新标记漏标对象\",{\"1\":{\"52\":1}}],[\"重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"39\":1}}],[\"重新标记\",{\"1\":{\"39\":1}}],[\"重置本次gc过程中的标记数据\",{\"1\":{\"39\":1}}],[\"见下面三色标记算法详解\",{\"1\":{\"39\":1}}],[\"见下面详解\",{\"1\":{\"39\":1}}],[\"速度很快\",{\"1\":{\"39\":1}}],[\"直接从索引中读取主键信息\",{\"1\":{\"233\":1}}],[\"直接持久化到硬盘\",{\"1\":{\"205\":1}}],[\"直接读取即可\",{\"1\":{\"157\":1}}],[\"直接返回数据\",{\"1\":{\"116\":1}}],[\"直接能引用的对象\",{\"1\":{\"39\":1}}],[\"直至匹配到所有条件\",{\"1\":{\"102\":1}}],[\"直到不满足\",{\"1\":{\"239\":1,\"240\":1}}],[\"直到查找到可以展示的数据\",{\"1\":{\"189\":1}}],[\"直到查询到复合条件的数据\",{\"1\":{\"106\":1}}],[\"直到查询到我们所需的数据\",{\"1\":{\"98\":1}}],[\"直到完成范围查询\",{\"1\":{\"106\":1}}],[\"直到下一次eden区放满\",{\"1\":{\"54\":1}}],[\"直到它收集结束\",{\"1\":{\"36\":1}}],[\"初始标记\",{\"1\":{\"39\":1,\"52\":1}}],[\"初始化零值之后\",{\"1\":{\"18\":1}}],[\"初始化零值\",{\"0\":{\"17\":1}}],[\"整个\",{\"1\":{\"115\":1}}],[\"整个节点\",{\"1\":{\"115\":1}}],[\"整个查询是相当快的\",{\"1\":{\"107\":1}}],[\"整个树的高度小于二叉树\",{\"1\":{\"101\":1}}],[\"整个过程分为四个步骤\",{\"1\":{\"39\":1}}],[\"整理​算法\",{\"1\":{\"36\":1,\"37\":1,\"38\":1}}],[\"整理算法实现\",{\"1\":{\"64\":1}}],[\"整理算法\",{\"0\":{\"35\":1}}],[\"整理\",{\"1\":{\"32\":2,\"37\":1}}],[\"基于块的嵌套循环连接\",{\"0\":{\"149\":1}}],[\"基于慢sql查询做优化\",{\"0\":{\"138\":1}}],[\"基于正态分布统计\",{\"1\":{\"70\":1}}],[\"基于这种情况\",{\"1\":{\"0\":1}}],[\"基本等价于\",{\"1\":{\"152\":1}}],[\"基本可以满足之后数十年的发展\",{\"1\":{\"62\":1}}],[\"基本上\",{\"1\":{\"39\":1}}],[\"真正意义上的并发收集器\",{\"1\":{\"38\":1}}],[\"模式下的虚拟机的首要选择\",{\"1\":{\"38\":1}}],[\"都将\",{\"1\":{\"205\":3}}],[\"都需要从undo日志链中的最新数据开始\",{\"1\":{\"188\":1}}],[\"都是基于最初查询的值进行更新\",{\"1\":{\"165\":1}}],[\"都是把要回收的region里的存活对象放入其他region\",{\"1\":{\"57\":1}}],[\"都尽可能多的加载出数据\",{\"1\":{\"107\":1}}],[\"都留存在年轻代里\",{\"1\":{\"94\":1}}],[\"都会\",{\"1\":{\"107\":1}}],[\"都会加上一个load\",{\"1\":{\"68\":1}}],[\"都会面临相同的问题\",{\"1\":{\"48\":1}}],[\"都在标记阶段\",{\"1\":{\"40\":1}}],[\"都可以优先考虑\",{\"1\":{\"37\":1}}],[\"都不能分解\",{\"1\":{\"10\":1}}],[\"资源的场合\",{\"1\":{\"37\":1}}],[\"等多个存储引擎\",{\"1\":{\"201\":1}}],[\"等主要从磁盘读写数据的引擎\",{\"1\":{\"194\":1}}],[\"等价于\",{\"1\":{\"152\":1}}],[\"等\",{\"1\":{\"107\":1}}],[\"等到下一轮gc再深度扫描\",{\"1\":{\"47\":1}}],[\"等并发扫描结束之后\",{\"1\":{\"43\":1}}],[\"等垃圾收集器的关注点更多的是用户线程的停顿时间\",{\"1\":{\"37\":1}}],[\"等级\",{\"1\":{\"7\":1}}],[\"控制参数\",{\"1\":{\"37\":1}}],[\"另一种用途是作为\",{\"1\":{\"36\":1}}],[\"另外两个暂停也同样不会随着堆大小而变化\",{\"1\":{\"61\":1}}],[\"另外一个region花50ms能回收20m垃圾\",{\"1\":{\"52\":1}}],[\"另外\",{\"1\":{\"5\":1,\"8\":2,\"42\":1,\"62\":1}}],[\"寻找最优秀的垃圾收集器的过程仍然在继续\",{\"1\":{\"36\":1}}],[\"带来的不良用户体验\",{\"1\":{\"36\":1}}],[\"老年代的大小\",{\"1\":{\"89\":1}}],[\"老年代的对象引用着新生代的对象\",{\"1\":{\"48\":1}}],[\"老年代占用空间达到整堆内存阈值\",{\"1\":{\"57\":1}}],[\"老年代之间才有跨代引用的问题\",{\"1\":{\"48\":1}}],[\"老年代\",{\"1\":{\"48\":1}}],[\"老年代采用标记\",{\"1\":{\"36\":1,\"37\":1,\"38\":1}}],[\"老年代空间担保\",{\"0\":{\"24\":1}}],[\"更新操作会比反范式化快\",{\"1\":{\"216\":1}}],[\"更新操作日志\",{\"1\":{\"205\":1}}],[\"更新完\",{\"1\":{\"202\":1}}],[\"更新完binlog日志后\",{\"1\":{\"190\":1}}],[\"更新内存的性能是极高的\",{\"1\":{\"191\":1,\"203\":1}}],[\"更新前\",{\"1\":{\"190\":2,\"202\":2}}],[\"更新时尽可能让所有数据检索都通过索引来完成\",{\"1\":{\"184\":1}}],[\"更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程\",{\"1\":{\"36\":1}}],[\"更加没有万能的垃圾收集器\",{\"1\":{\"35\":1}}],[\"大小参数\",{\"1\":{\"204\":1}}],[\"大概\",{\"1\":{\"107\":1}}],[\"大概在左边还是右边\",{\"1\":{\"105\":1}}],[\"大多数同学可能为了图方便对于jvm级缓存就简单使用一个hashmap\",{\"1\":{\"95\":1}}],[\"大龄对象进入老年代的阈值等\",{\"1\":{\"89\":1}}],[\"大写h\",{\"1\":{\"84\":1}}],[\"大体实现思想是当垃圾收集需要中断线程的时候\",{\"1\":{\"73\":1}}],[\"大部分情况下\",{\"1\":{\"151\":1}}],[\"大部分工作jvm能很好的自动完成\",{\"1\":{\"69\":1}}],[\"大部分对象都是朝生夕死\",{\"1\":{\"63\":1}}],[\"大型region在zgc的实现中是不会被重分配的\",{\"1\":{\"64\":1}}],[\"大型region\",{\"1\":{\"64\":2}}],[\"大对象的阈值\",{\"1\":{\"89\":1}}],[\"大对象的判定规则就是一个大对象超过了一个region大小的50\",{\"1\":{\"52\":1}}],[\"大对象直接进入老年代\",{\"0\":{\"21\":1}}],[\"大家看名字就知道这个收集器是一个单线程收集器了\",{\"1\":{\"36\":1}}],[\"历史最悠久的垃圾收集器了\",{\"1\":{\"36\":1}}],[\"收集算法\",{\"1\":{\"37\":1}}],[\"收集算法出现了\",{\"1\":{\"33\":1}}],[\"收集器收集的速度逐渐跟不上分配器分配的速度\",{\"1\":{\"52\":1}}],[\"收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可\",{\"1\":{\"48\":1}}],[\"收集器外\",{\"1\":{\"38\":1}}],[\"收集器配合使用\",{\"1\":{\"38\":1}}],[\"收集器很类似\",{\"1\":{\"38\":1}}],[\"收集器其实跟\",{\"1\":{\"38\":1}}],[\"收集器其实就是\",{\"1\":{\"37\":1}}],[\"收集器\",{\"1\":{\"37\":1,\"38\":1}}],[\"收集器和\",{\"1\":{\"37\":1}}],[\"收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量\",{\"1\":{\"37\":1}}],[\"收集器关注点是吞吐量\",{\"1\":{\"37\":1}}],[\"收集器类似\",{\"1\":{\"37\":1}}],[\"收集器的多线程版本\",{\"1\":{\"37\":1}}],[\"收集器的后备方案\",{\"1\":{\"36\":1}}],[\"收集器的老年代版本\",{\"1\":{\"36\":1,\"37\":1}}],[\"收集器搭配使用\",{\"1\":{\"36\":1}}],[\"收集器是一种\",{\"1\":{\"39\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"39\":1}}],[\"收集器是\",{\"1\":{\"36\":1,\"37\":1}}],[\"收集器是最基本\",{\"1\":{\"36\":1}}],[\"收集器由于没有线程交互的开销\",{\"1\":{\"36\":1}}],[\"收集器有没有优于其他垃圾收集器的地方呢\",{\"1\":{\"36\":1}}],[\"串行化serializable\",{\"1\":{\"172\":1}}],[\"串行或jvm自己选择\",{\"1\":{\"71\":1}}],[\"串行\",{\"1\":{\"36\":1}}],[\"试想一下\",{\"1\":{\"35\":1}}],[\"然后预先在这张表增加100行或者更多数据\",{\"1\":{\"223\":1}}],[\"然后重启数据库\",{\"1\":{\"206\":1}}],[\"然后调用操作系统函数\",{\"1\":{\"205\":1}}],[\"然后就被更新失效掉了\",{\"1\":{\"197\":1}}],[\"然后缓存起来\",{\"1\":{\"196\":1}}],[\"然后顺序写磁盘上的日志文件的性能也是非常高的\",{\"1\":{\"191\":1,\"203\":1}}],[\"然后顺序写日志文件\",{\"1\":{\"191\":1,\"203\":1}}],[\"然后更新磁盘文件里的数据性能可能相当差\",{\"1\":{\"203\":1}}],[\"然后更新磁盘文件里的数据\",{\"1\":{\"191\":1}}],[\"然后与read\",{\"1\":{\"189\":1}}],[\"然后事务a再次读取该条数据时\",{\"1\":{\"165\":1}}],[\"然后根据分析结果进行优化\",{\"1\":{\"181\":1}}],[\"然后根据id关联查询b表中数据\",{\"1\":{\"152\":1}}],[\"然后根据主键查到对应的记录\",{\"1\":{\"146\":1}}],[\"然后在\",{\"1\":{\"238\":1}}],[\"然后在sort\",{\"1\":{\"238\":1}}],[\"然后在比对过程中\",{\"1\":{\"149\":1}}],[\"然后在聚集索引的叶子节点查询出完整数据\",{\"1\":{\"116\":1}}],[\"然后取t1数据进行比较\",{\"1\":{\"150\":1}}],[\"然后取两张表的合集\",{\"1\":{\"148\":1}}],[\"然后取出\",{\"1\":{\"105\":1}}],[\"然后将数据中a字段的值取出\",{\"1\":{\"148\":1}}],[\"然后将前面90000条数据丢弃\",{\"1\":{\"142\":1}}],[\"然后将索引和内存地址进行存储\",{\"1\":{\"99\":1}}],[\"然后用一两个辅助索引尽量抗下剩余的一些非典型查询\",{\"1\":{\"139\":1}}],[\"然后用需要查询的索引值去一一比对\",{\"1\":{\"105\":1}}],[\"然后做排序的成本可能会小很多\",{\"1\":{\"137\":1}}],[\"然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据\",{\"1\":{\"129\":1}}],[\"然后拿这些索引对应的主键逐个回表\",{\"1\":{\"127\":1}}],[\"然后进入叶子节点\",{\"1\":{\"111\":1}}],[\"然后进入下级节点\",{\"1\":{\"111\":1}}],[\"然后再扫描t1表\",{\"1\":{\"150\":1}}],[\"然后再通过主键回到原表查询需要的字段\",{\"1\":{\"240\":1}}],[\"然后再通过id到主键索引中找到完整的产品信息\",{\"1\":{\"116\":1}}],[\"然后再通过这个主键值去聚集索引树中查找完整的数据行\",{\"1\":{\"116\":1}}],[\"然后再进行一次查询\",{\"1\":{\"105\":1}}],[\"然后再把使用的空间一次清理掉\",{\"1\":{\"33\":1}}],[\"然后继续采用二分查找\",{\"1\":{\"105\":1}}],[\"然后遍历链表找到具体的索引值\",{\"1\":{\"99\":1}}],[\"然后立即根据region上的转发表记录将访问转发到新复制的对象上\",{\"1\":{\"65\":1}}],[\"然后50ms的卡顿其实完全能够接受\",{\"1\":{\"60\":1}}],[\"然后这个region中的垃圾对象全部清理掉\",{\"1\":{\"57\":1}}],[\"然后系统继续运行\",{\"1\":{\"57\":1}}],[\"然后采用单线程进行标记\",{\"1\":{\"56\":1}}],[\"然后垃圾回收又被触发的情况\",{\"1\":{\"39\":1}}],[\"然后直接清理掉端边界以外的内存\",{\"1\":{\"35\":1}}],[\"效率很高\",{\"1\":{\"155\":1}}],[\"效率很低\",{\"1\":{\"150\":1}}],[\"效率较低\",{\"1\":{\"153\":1}}],[\"效率比count\",{\"1\":{\"153\":1}}],[\"效率还是比较高的\",{\"1\":{\"148\":1}}],[\"效率不高\",{\"1\":{\"34\":1}}],[\"效率问题\",{\"1\":{\"34\":1}}],[\"效率高\",{\"1\":{\"25\":1}}],[\"统一回收所有未被标记的对象\",{\"1\":{\"34\":1}}],[\"倍以上\",{\"1\":{\"32\":1}}],[\"算法对索引值进行\",{\"1\":{\"99\":1}}],[\"算法不同\",{\"1\":{\"52\":1}}],[\"算法会导致收集结束时会有大量空间碎片产生\",{\"1\":{\"39\":1}}],[\"算法会比复制算法慢\",{\"1\":{\"32\":1}}],[\"算法实现的收集器\",{\"1\":{\"52\":1}}],[\"算法实现的\",{\"1\":{\"39\":1,\"52\":1}}],[\"算法\",{\"1\":{\"37\":1,\"149\":1}}],[\"算法一样\",{\"1\":{\"35\":1}}],[\"算法分为\",{\"1\":{\"34\":1}}],[\"算法进行垃圾收集\",{\"1\":{\"32\":1}}],[\"或my\",{\"1\":{\"206\":1}}],[\"或count\",{\"1\":{\"155\":1}}],[\"或者在一个语句有多表关联\",{\"1\":{\"199\":1}}],[\"或者\",{\"1\":{\"109\":1}}],[\"或者是红色\",{\"1\":{\"101\":1}}],[\"或者是当年轻代gc过后\",{\"1\":{\"58\":1}}],[\"或超过5分钟时\",{\"1\":{\"70\":1}}],[\"或\",{\"1\":{\"32\":2,\"101\":1,\"107\":1}}],[\"死去\",{\"1\":{\"32\":1}}],[\"近\",{\"1\":{\"32\":1}}],[\"堆分为新生代和老年代\",{\"1\":{\"32\":1}}],[\"堆中不存在该类的任何实例\",{\"1\":{\"29\":1}}],[\"堆中几乎放着所有的对象实例\",{\"1\":{\"24\":1}}],[\"上面那个查询在联合索引里匹配到名字是\",{\"1\":{\"127\":1}}],[\"上\",{\"0\":{\"31\":1}}],[\"无索引行锁会升级为表锁\",{\"1\":{\"178\":1}}],[\"无using\",{\"1\":{\"131\":1}}],[\"无需了解跨代引用指针的全部细节\",{\"1\":{\"48\":1}}],[\"无须重新扫描一遍\",{\"1\":{\"41\":1}}],[\"无法很好的利用索引\",{\"1\":{\"127\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"39\":1}}],[\"无法在任何地方通过反射访问该类的方法\",{\"1\":{\"29\":1}}],[\"无用的类\",{\"1\":{\"29\":1}}],[\"加载到\",{\"1\":{\"202\":1}}],[\"加载到bufferpool中\",{\"1\":{\"190\":1}}],[\"加载该类的\",{\"1\":{\"29\":1}}],[\"加锁慢\",{\"1\":{\"171\":1}}],[\"加锁开销大\",{\"1\":{\"171\":1}}],[\"加锁快\",{\"1\":{\"167\":1}}],[\"加写锁\",{\"1\":{\"170\":1}}],[\"加读锁\",{\"1\":{\"170\":1}}],[\"加了索引\",{\"1\":{\"100\":1}}],[\"加入一些处理\",{\"1\":{\"44\":1}}],[\"加入\",{\"1\":{\"8\":1}}],[\"类似如下写法\",{\"1\":{\"151\":1}}],[\"类似于\",{\"1\":{\"136\":1}}],[\"类似\",{\"1\":{\"114\":1}}],[\"类名称\",{\"1\":{\"79\":1}}],[\"类需要同时满足下面3个条件才能算是\",{\"1\":{\"29\":1}}],[\"类加载检查\",{\"0\":{\"15\":1}}],[\"u\",{\"1\":{\"196\":1}}],[\"uncommitted\",{\"1\":{\"172\":2,\"173\":1}}],[\"unknown\",{\"1\":{\"129\":1}}],[\"undefined\",{\"1\":{\"129\":1}}],[\"undo日志版本链是指一行数据被多个事务修改\",{\"1\":{\"188\":1}}],[\"undo日志版本链和read\",{\"0\":{\"188\":1}}],[\"undo\",{\"1\":{\"107\":2,\"202\":1}}],[\"usable\",{\"1\":{\"129\":3}}],[\"using\",{\"0\":{\"237\":1},\"1\":{\"121\":1,\"129\":1,\"131\":1,\"146\":1}}],[\"use\",{\"1\":{\"129\":1}}],[\"uses\",{\"1\":{\"129\":2}}],[\"usenix\",{\"1\":{\"61\":1}}],[\"userid=\",{\"1\":{\"28\":1}}],[\"user类需要重写finalize方法\",{\"1\":{\"28\":1}}],[\"user\",{\"1\":{\"27\":7,\"28\":2,\"69\":1,\"84\":3,\"139\":1,\"196\":1,\"198\":1}}],[\"usecompressedoops\",{\"1\":{\"19\":1}}],[\"update\",{\"1\":{\"43\":1,\"167\":1,\"177\":1,\"183\":4,\"209\":1}}],[\"uuid\",{\"1\":{\"28\":2,\"114\":1}}],[\"譬如设置为二十毫秒\",{\"1\":{\"52\":1}}],[\"譬如把自己赋值给某个类变量或对象的成员变量\",{\"1\":{\"28\":1}}],[\"譬如作为其他线程可访问对象的属性被引用\",{\"1\":{\"9\":1}}],[\"第四范式\",{\"1\":{\"209\":1}}],[\"第三范式\",{\"0\":{\"212\":1},\"1\":{\"209\":1}}],[\"第三阶段\",{\"1\":{\"129\":1}}],[\"第二范式\",{\"0\":{\"211\":1},\"1\":{\"209\":1,\"211\":1}}],[\"第二阶段\",{\"1\":{\"129\":1}}],[\"第二次标记\",{\"1\":{\"28\":1}}],[\"第一范式\",{\"0\":{\"210\":1},\"1\":{\"209\":1}}],[\"第一阶段\",{\"1\":{\"129\":1}}],[\"第一行代码我们尝试读取堆中的一个对象引用obj\",{\"1\":{\"68\":1}}],[\"第一次标记并进行一次筛选\",{\"1\":{\"28\":1}}],[\"第一部分用于存储对象自身的运行时数据\",{\"1\":{\"18\":1}}],[\"标志\",{\"1\":{\"202\":1}}],[\"标记整理\",{\"1\":{\"52\":1}}],[\"标记能达到所有对象\",{\"1\":{\"52\":1}}],[\"标记阶段就会减少一些标记时间\",{\"1\":{\"40\":1}}],[\"标记过程仍然与\",{\"1\":{\"35\":1}}],[\"标记清除后会产生大量不连续的碎片\",{\"1\":{\"34\":1}}],[\"标记出所有需要回收的对象\",{\"1\":{\"34\":1}}],[\"标记存活的对象\",{\"1\":{\"34\":1}}],[\"标记\",{\"0\":{\"33\":1,\"34\":1,\"35\":1},\"1\":{\"32\":4,\"34\":1,\"35\":1,\"37\":1,\"39\":1,\"52\":1}}],[\"标记的前提是对象在进行可达性分析后发现没有与gc\",{\"1\":{\"28\":1}}],[\"标量替换也是不可或缺的\",{\"1\":{\"11\":1}}],[\"标量替换对逃逸程度的要求更高\",{\"1\":{\"10\":1}}],[\"标量替换\",{\"0\":{\"10\":1}}],[\"阶段会短暂的暂停\",{\"1\":{\"65\":1}}],[\"阶段\",{\"1\":{\"28\":1,\"34\":1}}],[\"waits\",{\"1\":{\"181\":2,\"182\":2}}],[\"where与order\",{\"0\":{\"137\":1}}],[\"where高于having\",{\"1\":{\"131\":1}}],[\"where\",{\"1\":{\"98\":1,\"100\":1,\"123\":1,\"124\":3,\"125\":1,\"126\":4,\"127\":3,\"129\":7,\"139\":5,\"144\":1,\"145\":2,\"151\":2,\"152\":6,\"177\":1,\"197\":1,\"198\":1,\"200\":1}}],[\"while\",{\"1\":{\"28\":1,\"84\":1,\"121\":2}}],[\"windows\",{\"1\":{\"81\":1,\"206\":1}}],[\"wiki\",{\"1\":{\"7\":1,\"61\":1}}],[\"www\",{\"1\":{\"61\":1}}],[\"write\",{\"1\":{\"44\":2,\"45\":1,\"68\":1,\"168\":1,\"205\":4}}],[\"world停顿时间\",{\"1\":{\"52\":1}}],[\"world\",{\"1\":{\"36\":2,\"39\":1}}],[\"weakreference<user>\",{\"1\":{\"27\":2}}],[\"很少有多余的数据\",{\"1\":{\"216\":1}}],[\"很少用\",{\"1\":{\"27\":1}}],[\"很明显在实际的业务查询中会大量存在着表的关联查询\",{\"1\":{\"213\":1}}],[\"很多时候你就是要针对varchar\",{\"1\":{\"136\":1}}],[\"很显然\",{\"1\":{\"60\":1}}],[\"很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间\",{\"1\":{\"52\":1}}],[\"很可能出现的结果就是由于停顿目标时间太短\",{\"1\":{\"52\":1}}],[\"很耗费开销\",{\"1\":{\"0\":1}}],[\"​innodb\",{\"1\":{\"204\":4,\"205\":1}}],[\"​innodb存储引擎由于实现了行级锁定\",{\"1\":{\"179\":1}}],[\"​设置成\",{\"1\":{\"197\":1}}],[\"​b+\",{\"1\":{\"103\":1}}],[\"​标记\",{\"1\":{\"39\":1}}],[\"​\",{\"1\":{\"27\":4,\"38\":1,\"39\":1,\"48\":1}}],[\"​public\",{\"1\":{\"27\":3}}],[\"​​​​\",{\"1\":{\"129\":1,\"170\":1}}],[\"​​​​存储数据的时候会根据\",{\"1\":{\"99\":1}}],[\"​​\",{\"1\":{\"0\":2,\"4\":1,\"5\":2,\"8\":2,\"14\":1,\"16\":2,\"18\":2,\"19\":1,\"24\":1,\"26\":1,\"31\":1,\"33\":1,\"34\":1,\"35\":2,\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"41\":1,\"52\":3,\"62\":1,\"64\":1,\"65\":1,\"66\":1,\"68\":2,\"69\":1,\"71\":1,\"79\":2,\"80\":1,\"83\":3,\"84\":3,\"86\":1,\"87\":1,\"98\":1,\"99\":2,\"100\":1,\"101\":4,\"102\":1,\"103\":1,\"106\":2,\"107\":1,\"109\":3,\"110\":2,\"111\":1,\"112\":2,\"113\":2,\"115\":2,\"116\":1,\"117\":1,\"118\":2,\"123\":1,\"124\":1,\"125\":1,\"126\":4,\"127\":2,\"129\":2,\"131\":9,\"146\":1,\"148\":1,\"149\":1,\"151\":3,\"168\":2,\"169\":5,\"170\":3,\"177\":1,\"183\":1,\"188\":1,\"190\":1,\"194\":1,\"198\":2,\"202\":1,\"204\":1,\"205\":2,\"206\":1}}],[\"普通的变量引用\",{\"1\":{\"27\":1}}],[\"弱引用跟没引用差不多\",{\"1\":{\"27\":1}}],[\"弱引用\",{\"1\":{\"27\":2}}],[\"软引用在实际中有重要的应用\",{\"1\":{\"27\":1}}],[\"软引用可用来实现内存敏感的高速缓存\",{\"1\":{\"27\":1}}],[\"软引用\",{\"1\":{\"27\":2}}],[\"静态变量\",{\"1\":{\"26\":1}}],[\"rc级别不会升级为表锁\",{\"1\":{\"178\":1}}],[\"rr级别会升级为表锁\",{\"1\":{\"178\":1}}],[\"roworder\",{\"1\":{\"129\":3}}],[\"rowid\",{\"1\":{\"129\":1,\"238\":1}}],[\"rows\",{\"1\":{\"129\":7}}],[\"row\",{\"0\":{\"181\":1},\"1\":{\"114\":1,\"129\":1,\"181\":6,\"206\":1}}],[\"root\",{\"1\":{\"61\":1,\"196\":3}}],[\"roots能达到的第一个对象\",{\"1\":{\"52\":1}}],[\"roots开始标记gc\",{\"1\":{\"52\":1}}],[\"roots可达性分析遍历对象过程中遇到的对象\",{\"1\":{\"41\":1}}],[\"roots的直接关联对象开始遍历整个对象图的过程\",{\"1\":{\"39\":1}}],[\"roots相连接的引用链\",{\"1\":{\"28\":1}}],[\"roots根节点\",{\"1\":{\"26\":1}}],[\"roots\",{\"1\":{\"26\":1,\"39\":1}}],[\"rss\",{\"1\":{\"69\":1}}],[\"ram\",{\"1\":{\"166\":1}}],[\"rangeread\",{\"1\":{\"228\":1}}],[\"ranges\",{\"1\":{\"129\":3}}],[\"range\",{\"1\":{\"129\":12}}],[\"randomuuid\",{\"1\":{\"28\":2}}],[\"rate\",{\"1\":{\"69\":1}}],[\"redo\",{\"0\":{\"204\":1,\"205\":1},\"1\":{\"202\":2,\"204\":6,\"205\":7}}],[\"rednaxelafx\",{\"1\":{\"69\":1}}],[\"repeatable\",{\"1\":{\"175\":1}}],[\"readlog\",{\"1\":{\"202\":3}}],[\"readlog日志主要作用是在mysql启动时\",{\"1\":{\"190\":1}}],[\"read\",{\"1\":{\"168\":1,\"172\":2,\"173\":1,\"174\":1,\"175\":1,\"177\":1,\"188\":1}}],[\"reconsidering\",{\"1\":{\"129\":2}}],[\"refine\",{\"1\":{\"129\":2}}],[\"ref\",{\"1\":{\"129\":2}}],[\"reference类型等\",{\"1\":{\"10\":1}}],[\"resulting\",{\"1\":{\"129\":6}}],[\"relocation\",{\"1\":{\"65\":1,\"66\":1}}],[\"relocate\",{\"1\":{\"65\":2}}],[\"region是指在一段代码片段中\",{\"1\":{\"74\":1}}],[\"region中的存活对象低于这个值时才会回收该region\",{\"1\":{\"57\":1}}],[\"region的集合\",{\"1\":{\"52\":1}}],[\"region\",{\"0\":{\"74\":1},\"1\":{\"52\":2,\"64\":3,\"74\":1}}],[\"removal\",{\"1\":{\"129\":1}}],[\"remapped标识\",{\"1\":{\"66\":1}}],[\"remap\",{\"1\":{\"65\":1}}],[\"remark\",{\"1\":{\"45\":1,\"47\":1,\"52\":1}}],[\"remember\",{\"1\":{\"48\":1}}],[\"return\",{\"1\":{\"8\":4,\"12\":2,\"47\":1,\"84\":1}}],[\"回表查询其余列\",{\"1\":{\"233\":1}}],[\"回表效率不高\",{\"1\":{\"123\":1}}],[\"回表操作是一种数据库查询优化技术\",{\"1\":{\"116\":1}}],[\"回表\",{\"1\":{\"116\":2}}],[\"回到聚集索引中查询\",{\"1\":{\"116\":1}}],[\"回收的的意义不大\",{\"1\":{\"57\":1}}],[\"回收所有的young和部分old\",{\"1\":{\"55\":1}}],[\"回收阶段占到几十到一百甚至接近两百毫秒都很正常\",{\"1\":{\"52\":1}}],[\"回收算法主要用的是复制算法\",{\"1\":{\"52\":1}}],[\"回收策略等等\",{\"1\":{\"37\":1}}],[\"回收器回收他们\",{\"1\":{\"25\":1}}],[\"回边计数器阈值=方法调用计数器阈值×\",{\"1\":{\"6\":1}}],[\"回边计数器在默认情况下的阈值是1070\",{\"1\":{\"6\":1}}],[\"回边计数器\",{\"1\":{\"6\":1}}],[\"相对于每读取一条二级索引记录就立即执行回表操作\",{\"1\":{\"228\":1}}],[\"相对的filesort效率低\",{\"1\":{\"131\":1}}],[\"相当于是减少了磁盘\",{\"1\":{\"107\":1}}],[\"相同性质的堆可以不连续\",{\"1\":{\"52\":1}}],[\"相互引用着对方之外\",{\"1\":{\"25\":1}}],[\"相比较32位存储\",{\"1\":{\"19\":1}}],[\"相比于c1编译器\",{\"1\":{\"7\":1}}],[\"其他配置\",{\"1\":{\"206\":1}}],[\"其他session读取会阻塞\",{\"1\":{\"170\":1}}],[\"其他session的写操作和读操作会阻塞\",{\"1\":{\"167\":1}}],[\"其值也是400\",{\"1\":{\"173\":1}}],[\"其值不是男就是女\",{\"1\":{\"135\":1}}],[\"其实对比两个排序模式\",{\"1\":{\"240\":1}}],[\"其实还有一种方式是这类计数器类更新操作可以在程序中用线程实现\",{\"1\":{\"223\":1}}],[\"其实主要是最后那个20\",{\"1\":{\"178\":1}}],[\"其实我们可以再设计一个辅助的联合索引\",{\"1\":{\"139\":1}}],[\"其实我们可以试着再设计一个字段is\",{\"1\":{\"139\":1}}],[\"其实我们可以这么来优化下sql的写法\",{\"1\":{\"139\":1}}],[\"其实是应该的\",{\"1\":{\"139\":1}}],[\"其实质是先排序后分组\",{\"1\":{\"131\":1}}],[\"其实就是用到了索引下推优化\",{\"1\":{\"127\":1}}],[\"其实就是指在赋值操作前后\",{\"1\":{\"44\":1}}],[\"其实\",{\"1\":{\"107\":1}}],[\"其实在查询的过程中\",{\"1\":{\"107\":1}}],[\"其实简单来说就是尽量让每次young\",{\"1\":{\"94\":1}}],[\"其对应的卡表的元素标识就变成1\",{\"1\":{\"48\":1}}],[\"其并发标记时对漏标的处理方案如下\",{\"1\":{\"47\":1}}],[\"其底层代码大概长这样\",{\"1\":{\"44\":1}}],[\"其余范式以次类推\",{\"1\":{\"209\":1}}],[\"其余事务才可以继续操作数据\",{\"1\":{\"176\":1}}],[\"其余session修改会阻塞\",{\"1\":{\"169\":1}}],[\"其余session的写操作会阻塞\",{\"1\":{\"167\":1}}],[\"其余行为\",{\"1\":{\"37\":1}}],[\"其余未标记的对象都是垃圾对象\",{\"1\":{\"26\":1}}],[\"其最主要的原因是它很难解决对象之间相互循环引用的问题\",{\"1\":{\"25\":1}}],[\"其中每个部门有部门编号\",{\"1\":{\"212\":1}}],[\"其中的\",{\"1\":{\"204\":1}}],[\"其中\",{\"1\":{\"194\":1,\"234\":1}}],[\"其中未提交事务数组中最小的事务id为min\",{\"1\":{\"188\":1}}],[\"其中回滚的指针指向修改前的数据\",{\"1\":{\"188\":1}}],[\"其中有个性别字段\",{\"1\":{\"135\":1}}],[\"其中第一个是做根集合\",{\"1\":{\"61\":1}}],[\"其中一块区域\",{\"1\":{\"23\":1}}],[\"其中比率的值默认为140\",{\"1\":{\"6\":1}}],[\"其中前端编译是在\",{\"1\":{\"4\":1}}],[\"任何场景下都适用的完美收集器存在\",{\"1\":{\"35\":1}}],[\"任何计数为0的对象就是可回收对象\",{\"1\":{\"25\":1}}],[\"任何编程语言\",{\"1\":{\"4\":1}}],[\"8中新的原子类longadder也是这种处理方式\",{\"1\":{\"223\":1}}],[\"8b\",{\"1\":{\"107\":1}}],[\"8\",{\"1\":{\"98\":1,\"107\":1,\"115\":3,\"131\":1,\"177\":1,\"182\":2,\"232\":1}}],[\"89\",{\"1\":{\"98\":1}}],[\"8默认使用\",{\"1\":{\"71\":1}}],[\"8默认就设置了\",{\"1\":{\"24\":1}}],[\"8g以上可以用g1\",{\"1\":{\"71\":1}}],[\"8g可以用parnew+cms\",{\"1\":{\"71\":1}}],[\"8gb以上的堆内存\",{\"1\":{\"59\":1}}],[\"80\",{\"1\":{\"40\":1}}],[\"8的eden内存\",{\"1\":{\"0\":1}}],[\"检查\",{\"1\":{\"24\":1}}],[\"检查这个虚拟机栈对应的线程中是否引用了这个对象\",{\"1\":{\"11\":1}}],[\"包括间隙行记录\",{\"1\":{\"177\":1}}],[\"包括全局变量啊线程栈啊啥的里面的对象指针\",{\"1\":{\"61\":1}}],[\"包括移动对象的阶段\",{\"1\":{\"61\":1}}],[\"包括垃圾对象\",{\"1\":{\"24\":1}}],[\"包括启动速度较慢\",{\"1\":{\"7\":1}}],[\"年轻代大小\",{\"1\":{\"89\":1}}],[\"年轻代和老年代都是\",{\"1\":{\"71\":1}}],[\"年轻代可能都占用了堆内存的60\",{\"1\":{\"58\":1}}],[\"年轻代中的eden和survivor对应的region也跟之前一样\",{\"1\":{\"52\":1}}],[\"年轻代每次minor\",{\"1\":{\"24\":1}}],[\"年龄\",{\"1\":{\"121\":1,\"139\":1}}],[\"年龄1+年龄2+年龄n的多个年龄对象\",{\"1\":{\"57\":1}}],[\"年龄1+年龄2+年龄n的多个年龄对象总和超过了survivor区域的50\",{\"1\":{\"23\":1}}],[\"年龄就增加1岁\",{\"1\":{\"22\":1}}],[\"尽可能低级别事务隔离\",{\"1\":{\"184\":1}}],[\"尽可能减少检索条件范围\",{\"1\":{\"184\":1}}],[\"尽量不要频繁update\",{\"1\":{\"235\":1}}],[\"尽量在满足业务要求的条件下\",{\"1\":{\"230\":1}}],[\"尽量在索引列上完成排序\",{\"1\":{\"131\":1}}],[\"尽量控制事务大小\",{\"1\":{\"184\":1}}],[\"尽量缩小锁的范围\",{\"1\":{\"184\":1}}],[\"尽量让mysql自己来选择驱动表\",{\"1\":{\"151\":1}}],[\"尽量利用一两个复杂的多字段联合索引\",{\"1\":{\"139\":1}}],[\"尽量对字段类型较小的列设计索引\",{\"1\":{\"136\":1}}],[\"尽量使用那些基数比较大的字段\",{\"1\":{\"135\":1}}],[\"尽量少建单值索引\",{\"1\":{\"134\":1}}],[\"尽量减少full\",{\"1\":{\"94\":1}}],[\"尽量别让对象进入老年代\",{\"1\":{\"94\":1}}],[\"尽量把gc导致的停顿时间控制在我们指定的范围内\",{\"1\":{\"52\":1}}],[\"尽量多写小方法\",{\"1\":{\"8\":1}}],[\"尽管实现的方式不尽相同\",{\"1\":{\"47\":1}}],[\"尽早进入老年代\",{\"1\":{\"23\":1}}],[\"含\",{\"1\":{\"23\":1,\"57\":1}}],[\"例如员工信息表中加上了员工编号\",{\"1\":{\"211\":1}}],[\"例如\",{\"1\":{\"116\":1,\"212\":1,\"233\":1}}],[\"例如浏览器的后退按钮\",{\"1\":{\"27\":1}}],[\"例如survivor区域里现在有一批对象\",{\"1\":{\"23\":1}}],[\"例如作为调用参数传递到其他地方中\",{\"1\":{\"20\":1}}],[\"一级比一级要求得严格\",{\"1\":{\"209\":1}}],[\"一是需要前端修改分页逻辑\",{\"1\":{\"145\":1}}],[\"一定要按照联合索引中字段的创建顺序去过滤\",{\"1\":{\"118\":1}}],[\"一致性视图\",{\"1\":{\"188\":1}}],[\"一致性\",{\"1\":{\"116\":1,\"164\":1}}],[\"一张表对应两个文件\",{\"1\":{\"109\":1}}],[\"一页可以加载多少个索引\",{\"1\":{\"107\":1}}],[\"一页的大小是\",{\"0\":{\"107\":1}}],[\"一位表示的就是\",{\"1\":{\"107\":1}}],[\"一\",{\"0\":{\"98\":1}}],[\"一直占用着老年代的很多空间\",{\"1\":{\"95\":1}}],[\"一次一行的从第一张表\",{\"1\":{\"148\":1}}],[\"一次gc的最大持续时间\",{\"1\":{\"70\":1}}],[\"一次gc检测周期时间\",{\"1\":{\"70\":1}}],[\"一次gc最大持续时间\",{\"1\":{\"70\":1}}],[\"一次只回收掉一部分的region\",{\"1\":{\"57\":1}}],[\"一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起\",{\"1\":{\"73\":1}}],[\"一旦某个region的存活对象被移走之后\",{\"1\":{\"67\":1}}],[\"一旦所有指针都被修正之后\",{\"1\":{\"65\":1}}],[\"一旦重分配集中某个region的存活对象都复制完毕后\",{\"1\":{\"65\":1}}],[\"一旦空闲出来的region数量达到了堆内存的5\",{\"1\":{\"57\":1}}],[\"一个表的索引是\",{\"1\":{\"233\":1}}],[\"一个事务开启后\",{\"1\":{\"188\":1}}],[\"一个事务重新读取之前的查询结果\",{\"1\":{\"165\":1}}],[\"一个事务按相同查询条件查询数据\",{\"1\":{\"165\":1}}],[\"一个事务内的所有sql语句要么同时成功\",{\"1\":{\"164\":1}}],[\"一个方法对应一块栈帧内存区域\",{\"1\":{\"84\":1}}],[\"一个region可能之前是年轻代\",{\"1\":{\"52\":1}}],[\"一个卡页中可包含多个对象\",{\"1\":{\"48\":1}}],[\"一个对象的finalize\",{\"1\":{\"28\":1}}],[\"一律记录下来\",{\"1\":{\"47\":1}}],[\"一边回收\",{\"1\":{\"39\":1}}],[\"一种用途是在\",{\"1\":{\"36\":1}}],[\"一批对象的总大小大于这块survivor区域内存大小的50\",{\"1\":{\"23\":1}}],[\"一般13\",{\"1\":{\"232\":1}}],[\"一般会用以下命令链接\",{\"1\":{\"196\":1}}],[\"一般用于整表数据迁移场景\",{\"1\":{\"167\":1}}],[\"一般为创建时间\",{\"1\":{\"145\":1}}],[\"一般大家肯定希望跟活跃用户交友了\",{\"1\":{\"139\":1}}],[\"一般这种范围查找的条件都要放在最后\",{\"1\":{\"139\":1}}],[\"一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据\",{\"1\":{\"137\":1}}],[\"一般建议大家在静态表中使用缓存\",{\"1\":{\"197\":1}}],[\"一般建议将jvm参数\",{\"1\":{\"0\":1}}],[\"一般建立索引\",{\"1\":{\"135\":1}}],[\"一般应该等到主体业务功能开发完毕\",{\"1\":{\"133\":1}}],[\"一般是怎么给数据表建立索引的\",{\"1\":{\"133\":1}}],[\"一般情况都会走索引\",{\"0\":{\"127\":1}}],[\"一般电商架构可能会使用多级缓存架构\",{\"1\":{\"95\":1}}],[\"一般系统可能有高峰期和日常期\",{\"1\":{\"90\":1}}],[\"一般来说部署kafka需要用大内存机器\",{\"1\":{\"60\":1}}],[\"一般来说\",{\"1\":{\"52\":1,\"139\":1,\"209\":1}}],[\"一般region大小等于堆大小除以2048\",{\"1\":{\"52\":1}}],[\"一般cms的gc耗时\",{\"1\":{\"40\":1}}],[\"一般选择这种\",{\"1\":{\"34\":1}}],[\"一般将\",{\"1\":{\"32\":1}}],[\"一般可以设置成256m\",{\"1\":{\"0\":1}}],[\"放剩下20行数据\",{\"1\":{\"150\":1}}],[\"放对象的那块s区\",{\"1\":{\"23\":1}}],[\"放到缓存当中\",{\"1\":{\"5\":1}}],[\"来替代\",{\"1\":{\"155\":1}}],[\"来满足上面那种场景了\",{\"1\":{\"139\":1}}],[\"来存储更多的数据\",{\"1\":{\"107\":1}}],[\"来估算每秒eden大概新增多少对象\",{\"1\":{\"90\":1}}],[\"来源\",{\"1\":{\"69\":1}}],[\"来缩短stop\",{\"1\":{\"52\":1}}],[\"来制定回收计划\",{\"1\":{\"52\":1}}],[\"来给大家解释下\",{\"1\":{\"41\":1}}],[\"来设置\",{\"1\":{\"22\":1}}],[\"来对java对象寻址\",{\"1\":{\"19\":1}}],[\"空间整合\",{\"1\":{\"52\":1}}],[\"空间问题\",{\"1\":{\"34\":1}}],[\"空间中\",{\"1\":{\"22\":1}}],[\"空闲列表\",{\"1\":{\"16\":1}}],[\"此种方式常见于报表等情况\",{\"1\":{\"222\":1}}],[\"此种需要被关联的的关联关系建立了索引\",{\"1\":{\"148\":1}}],[\"此约束已经形成了规范\",{\"1\":{\"209\":1}}],[\"此为线程的十六进制表示\",{\"1\":{\"84\":1}}],[\"此命令能查看内存信息\",{\"1\":{\"78\":1}}],[\"此时查询语句执行效率变低\",{\"1\":{\"217\":1}}],[\"此时查询就是全表扫描\",{\"1\":{\"98\":1}}],[\"此时如果\",{\"1\":{\"205\":1}}],[\"此时不能执行更新操作\",{\"1\":{\"205\":1}}],[\"此时可以展示\",{\"1\":{\"189\":1}}],[\"此时可使用straight\",{\"1\":{\"151\":1}}],[\"此时客户端a再查一次\",{\"1\":{\"174\":1,\"175\":1}}],[\"此时b可以正常读取数据\",{\"1\":{\"176\":1}}],[\"此时b更新相同数据不提交\",{\"1\":{\"174\":1}}],[\"此时b开启事务\",{\"1\":{\"174\":1,\"175\":1}}],[\"此时b进行了回滚后\",{\"1\":{\"173\":1}}],[\"此时a开启事务\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"此时a如果再进行balance\",{\"1\":{\"173\":1}}],[\"此时a事务的基础数据即是错误数据\",{\"1\":{\"165\":1}}],[\"此时事务被阻塞\",{\"1\":{\"173\":1}}],[\"此时\",{\"1\":{\"169\":1}}],[\"此时mysql会先放80条数据在join\",{\"1\":{\"150\":1}}],[\"此时数据没有建立索引\",{\"1\":{\"150\":1}}],[\"此时你在where条件里搜索的时候\",{\"1\":{\"136\":1}}],[\"此时你在搜索的时候性能也会比较好一点\",{\"1\":{\"136\":1}}],[\"此时剩下的右边的字段并不是按照顺序排序的\",{\"1\":{\"118\":1}}],[\"此时当我们要查询\",{\"1\":{\"100\":1}}],[\"此时会确定出\",{\"1\":{\"105\":1}}],[\"此时会更新指针中marked0和marked1标志位\",{\"1\":{\"65\":1}}],[\"此时会进入stop\",{\"1\":{\"39\":1}}],[\"此时才触发年轻代gc\",{\"1\":{\"58\":1}}],[\"此时就会导致survivor区域放不下那么多的对象\",{\"1\":{\"58\":1}}],[\"此时就会立即停止混合回收\",{\"1\":{\"57\":1}}],[\"此时就会把年龄n\",{\"1\":{\"23\":1,\"57\":1}}],[\"此时大对象在s0和s1区域也无法存储\",{\"1\":{\"21\":1}}],[\"此参数在serial和parnew垃圾回收器下起作用\",{\"1\":{\"21\":1}}],[\"单路排序会把所有需要查询的字段都放到\",{\"1\":{\"240\":1}}],[\"单路排序\",{\"1\":{\"238\":1,\"240\":1}}],[\"单个binlog日志文件的大小限制\",{\"1\":{\"206\":1}}],[\"单位为毫秒\",{\"1\":{\"88\":1}}],[\"单位是字节\",{\"1\":{\"21\":1}}],[\"单线程\",{\"1\":{\"36\":1}}],[\"单独来看testinline\",{\"1\":{\"8\":1}}],[\"逃逸的对象无法进行栈上分配\",{\"1\":{\"20\":1}}],[\"逃逸分析是基础\",{\"1\":{\"11\":1}}],[\"逃逸分析\",{\"0\":{\"9\":1},\"1\":{\"20\":1}}],[\"它从\",{\"1\":{\"201\":1}}],[\"它提供链接建立\",{\"1\":{\"196\":1}}],[\"它和g1一样\",{\"1\":{\"69\":1}}],[\"它表示这个对象只能通过finalizer才能引用\",{\"1\":{\"66\":1}}],[\"它默认的停顿目标为两百毫秒\",{\"1\":{\"52\":1}}],[\"它具备以下特点\",{\"1\":{\"52\":1}}],[\"它就变回灰色对象了\",{\"1\":{\"43\":1}}],[\"它使用的回收算法\",{\"1\":{\"39\":1}}],[\"它第一次实现了让垃圾收集线程与用户线程\",{\"1\":{\"39\":1}}],[\"它非常符合在注重用户体验的应用上使用\",{\"1\":{\"39\":1}}],[\"它是一个mark\",{\"1\":{\"61\":1}}],[\"它是安全存活的\",{\"1\":{\"41\":1}}],[\"它是\",{\"1\":{\"39\":1}}],[\"它是许多运行在\",{\"1\":{\"38\":1}}],[\"它是最基础的收集算法\",{\"1\":{\"34\":1}}],[\"它是最弱的一种引用关系\",{\"1\":{\"27\":1}}],[\"它主要有两大用途\",{\"1\":{\"36\":1}}],[\"它同样是一个单线程收集器\",{\"1\":{\"36\":1}}],[\"它简单而高效\",{\"1\":{\"36\":1}}],[\"它的状态是可以确定的\",{\"1\":{\"73\":1}}],[\"它的初始标记\",{\"1\":{\"65\":1}}],[\"它的停顿时间不会随着堆的增大而增长\",{\"1\":{\"62\":1}}],[\"它的目标之一是将stw控制在10ms左右的同时\",{\"1\":{\"61\":1}}],[\"它的运作过程相比于前面几种垃圾收集器来说更加复杂一些\",{\"1\":{\"39\":1}}],[\"它的\",{\"1\":{\"36\":1}}],[\"它可以作为一种可扩展的存储结构用来记录更多与对象标记\",{\"1\":{\"67\":1}}],[\"它可以将内存分为大小相同的两块\",{\"1\":{\"33\":1}}],[\"它可能被外部方法所引用\",{\"1\":{\"20\":1}}],[\"它不允许对象逃逸出方法范围内\",{\"1\":{\"10\":1}}],[\"填充对齐\",{\"1\":{\"19\":1}}],[\"使得每一个节点可以有更多的子节点\",{\"1\":{\"101\":1}}],[\"使得我们的查询效率更高呢\",{\"1\":{\"98\":1}}],[\"使得jvm只用32位地址就可以支持更大的内存配置\",{\"1\":{\"19\":1}}],[\"使上次gc周期中修正的标志位失效\",{\"1\":{\"66\":1}}],[\"使其直接指向新对象\",{\"1\":{\"65\":1}}],[\"使用这个mrr优化措施的条件比较苛刻\",{\"1\":{\"228\":1}}],[\"使用定时任务对汇总表进行更新\",{\"1\":{\"222\":1}}],[\"使用用户和密码进行验证\",{\"1\":{\"196\":1}}],[\"使用小表驱动大表\",{\"1\":{\"151\":1}}],[\"使用where子句与order\",{\"1\":{\"131\":1}}],[\"使用该索引获取的记录是否按照主键排序\",{\"1\":{\"129\":1}}],[\"使用了索引下推优化后\",{\"1\":{\"127\":1}}],[\"使用两个文件存储\",{\"1\":{\"113\":1}}],[\"使用三个文件来存储\",{\"1\":{\"113\":1}}],[\"使用一个\",{\"1\":{\"107\":1}}],[\"使用链表连接\",{\"1\":{\"99\":1}}],[\"使用命令top\",{\"1\":{\"84\":1}}],[\"使用idea自带的内存泄漏分析工具\",{\"1\":{\"81\":1}}],[\"使用并发收集器\",{\"1\":{\"71\":1}}],[\"使用串行收集器\",{\"1\":{\"71\":1}}],[\"使用ps\",{\"1\":{\"69\":1}}],[\"使用marked1\",{\"1\":{\"66\":1}}],[\"使用marked0\",{\"1\":{\"66\":1}}],[\"使用g1收集器\",{\"1\":{\"57\":1}}],[\"使用多个cpu\",{\"1\":{\"52\":1}}],[\"使用多线程和\",{\"1\":{\"37\":1}}],[\"使用原始快照方式进行处理\",{\"1\":{\"52\":1}}],[\"使用低位的32位地址\",{\"1\":{\"19\":1}}],[\"使用较大指针在主内存和缓存之间移动\",{\"1\":{\"19\":1}}],[\"使用\",{\"1\":{\"16\":1}}],[\"使用c2编译器来执行\",{\"1\":{\"7\":1}}],[\"使用c1来将字节码编译为本地机器码\",{\"1\":{\"7\":1}}],[\"使用jps查看其进程id\",{\"1\":{\"77\":1}}],[\"使用jit实时编译的前提是需要识别出热点代码\",{\"1\":{\"6\":1}}],[\"使用java\",{\"1\":{\"5\":1}}],[\"执行自动删除距离当前15天以前的binlog日志文件的天数\",{\"1\":{\"206\":1}}],[\"执行器就会根据表的引擎定义\",{\"1\":{\"200\":1}}],[\"执行器\",{\"0\":{\"200\":1}}],[\"执行器等\",{\"1\":{\"195\":1}}],[\"执行器等功能\",{\"1\":{\"194\":1}}],[\"执行过程类似\",{\"1\":{\"154\":1}}],[\"执行过程中可能会触发一次fullgc\",{\"1\":{\"79\":1}}],[\"执行过程中的不确定性\",{\"1\":{\"39\":1}}],[\"执行时间0\",{\"1\":{\"124\":2}}],[\"执行时间就有比较大的差距\",{\"1\":{\"12\":1}}],[\"执行jstack\",{\"1\":{\"84\":1}}],[\"执行init方法\",{\"1\":{\"19\":1}}],[\"偏向时间戳等\",{\"1\":{\"18\":1}}],[\"偏向线程id\",{\"1\":{\"18\":1}}],[\"锁分析\",{\"0\":{\"180\":1}}],[\"锁分类\",{\"0\":{\"167\":1}}],[\"锁的就是两个值之间的空隙\",{\"1\":{\"177\":1}}],[\"锁定颗粒度小\",{\"1\":{\"171\":1}}],[\"锁定颗粒度大\",{\"1\":{\"167\":1}}],[\"锁冲突概率高\",{\"1\":{\"167\":1}}],[\"锁冲突也是影响并发效率的一个方面\",{\"1\":{\"166\":1}}],[\"锁是计算机协调多个线程或进程并发访问同一资源的机制\",{\"1\":{\"166\":1}}],[\"锁等机制来解决多事务并发问题\",{\"1\":{\"163\":1}}],[\"锁状态标志\",{\"1\":{\"18\":1}}],[\"锁消除\",{\"0\":{\"12\":1}}],[\"dual\",{\"1\":{\"167\":2}}],[\"dump\",{\"1\":{\"81\":1}}],[\"days\",{\"1\":{\"139\":2,\"206\":1}}],[\"data\",{\"1\":{\"18\":1,\"109\":1,\"182\":2,\"238\":3,\"240\":3}}],[\"dir\",{\"1\":{\"204\":1}}],[\"dir​\",{\"1\":{\"204\":1}}],[\"direction\",{\"1\":{\"129\":1}}],[\"dives\",{\"1\":{\"129\":1}}],[\"distinct\",{\"1\":{\"129\":1,\"231\":1,\"232\":14}}],[\"display\",{\"1\":{\"61\":1}}],[\"drop\",{\"1\":{\"121\":1}}],[\"dept\",{\"1\":{\"212\":1}}],[\"depends\",{\"1\":{\"129\":2}}],[\"dependencies\",{\"1\":{\"129\":2}}],[\"delete\",{\"1\":{\"209\":1}}],[\"delimiter\",{\"1\":{\"121\":2}}],[\"demand\",{\"1\":{\"197\":2}}],[\"denied\",{\"1\":{\"196\":1}}],[\"desc变成了降序\",{\"1\":{\"131\":1}}],[\"declare\",{\"1\":{\"121\":1}}],[\"dev\",{\"1\":{\"121\":3}}],[\"default\",{\"1\":{\"121\":5}}],[\"degree\",{\"1\":{\"103\":1}}],[\"deadlocktest\",{\"1\":{\"83\":1}}],[\"d\",{\"1\":{\"41\":12,\"44\":1,\"45\":1,\"46\":2,\"47\":3}}],[\"dosomething\",{\"1\":{\"68\":1}}],[\"do\",{\"1\":{\"8\":1,\"121\":1}}],[\"home\",{\"1\":{\"204\":2}}],[\"host\",{\"1\":{\"196\":1}}],[\"hobby\",{\"1\":{\"139\":3}}],[\"hotspot使用写屏障维护卡表状态\",{\"1\":{\"49\":1}}],[\"hotspot使用的卡页是2^9大小\",{\"1\":{\"48\":1}}],[\"hotspot使用一种叫做\",{\"1\":{\"48\":1}}],[\"hotspot\",{\"1\":{\"39\":1,\"47\":1}}],[\"hotspot虚拟机的对象头包括两部分信息\",{\"1\":{\"18\":1}}],[\"hotspot虚拟机在编译子系统中加入了分层编译的功能\",{\"1\":{\"7\":1}}],[\"hotspot虚拟机内置两个即时编译器\",{\"1\":{\"7\":1}}],[\"hotspot虚拟机并没有直接选择执行效率最高的编译执行模式\",{\"1\":{\"5\":1}}],[\"hire\",{\"1\":{\"121\":3,\"145\":2}}],[\"histo\",{\"0\":{\"79\":1},\"1\":{\"79\":2}}],[\"h\",{\"1\":{\"88\":1,\"196\":2}}],[\"hprof\",{\"1\":{\"81\":1}}],[\"heapdumppath=\",{\"1\":{\"81\":1}}],[\"heap\",{\"0\":{\"80\":1},\"1\":{\"69\":2,\"80\":2}}],[\"healing\",{\"1\":{\"65\":2}}],[\"header\",{\"1\":{\"18\":1}}],[\"http\",{\"1\":{\"61\":1}}],[\"https\",{\"1\":{\"61\":2}}],[\"humongous区专门存放短期巨型对象\",{\"1\":{\"52\":1}}],[\"have\",{\"1\":{\"198\":1}}],[\"hanmeimei\",{\"1\":{\"121\":1,\"126\":4}}],[\"handlepromotionfailure\",{\"1\":{\"24\":1}}],[\"hash\",{\"0\":{\"99\":1},\"1\":{\"99\":8,\"106\":1}}],[\"hashcode\",{\"1\":{\"18\":1}}],[\"主码\",{\"1\":{\"211\":1}}],[\"主键在设计时\",{\"1\":{\"235\":1}}],[\"主键\",{\"1\":{\"153\":4}}],[\"主键不连续\",{\"0\":{\"145\":1}}],[\"主键索引\",{\"1\":{\"129\":1}}],[\"主动触发\",{\"1\":{\"70\":1}}],[\"主动关闭锁清除后\",{\"1\":{\"12\":1}}],[\"主动关闭标量替换\",{\"1\":{\"10\":1}}],[\"主要包括连接器\",{\"1\":{\"195\":1}}],[\"主要用在索引查询过程中\",{\"1\":{\"116\":1}}],[\"主要用到三色标记里的增量更新算法\",{\"1\":{\"39\":1}}],[\"主要时统计gc时间\",{\"1\":{\"70\":1}}],[\"主要使用标记\",{\"1\":{\"64\":1}}],[\"主要使用读屏障\",{\"1\":{\"64\":1}}],[\"主要使用复制算法\",{\"1\":{\"55\":1}}],[\"主要指mixed\",{\"1\":{\"52\":1}}],[\"主要针对配备多颗处理器及大容量内存的机器\",{\"1\":{\"52\":1}}],[\"主要优点\",{\"1\":{\"39\":1}}],[\"主要保存对象类的路径\",{\"1\":{\"18\":1}}],[\"指每一个非主属性既不部分依赖于也不传递依赖于业务主键\",{\"1\":{\"212\":1}}],[\"指向某个白色对象\",{\"1\":{\"41\":1}}],[\"指定分区大小\",{\"1\":{\"57\":1}}],[\"指定gc工作的线程数量\",{\"1\":{\"57\":1}}],[\"指定\",{\"1\":{\"52\":1}}],[\"指定收集线程数\",{\"1\":{\"37\":1}}],[\"指定元空间触发fullgc的初始阈值\",{\"1\":{\"0\":1}}],[\"指针的作用是\",{\"1\":{\"104\":1}}],[\"指针压缩会失效\",{\"1\":{\"19\":1}}],[\"指针碰撞\",{\"1\":{\"16\":1}}],[\"为\",{\"1\":{\"197\":1}}],[\"为条件\",{\"1\":{\"145\":1}}],[\"为scan\",{\"1\":{\"129\":1}}],[\"为什么范围查找mysql没有用索引下推优化\",{\"0\":{\"128\":1}}],[\"为什么二级索引不做成聚集索引呢\",{\"1\":{\"116\":1}}],[\"为什么非主键索引\",{\"0\":{\"116\":1}}],[\"为什么推荐使用自增主键\",{\"0\":{\"115\":1}}],[\"为什么我们使用整型的数据作为自增索引呢\",{\"1\":{\"114\":1}}],[\"为什么\",{\"0\":{\"114\":1}}],[\"为什么g1用satb\",{\"1\":{\"47\":1}}],[\"为其他gc机制使用\",{\"1\":{\"70\":1}}],[\"为何\",{\"1\":{\"63\":1}}],[\"为50ms\",{\"1\":{\"60\":1}}],[\"为此\",{\"1\":{\"48\":1}}],[\"为了实现上方便\",{\"1\":{\"61\":1}}],[\"为了简化例子\",{\"1\":{\"41\":1}}],[\"为了解决效率问题\",{\"1\":{\"33\":1}}],[\"为了做到这一点\",{\"1\":{\"22\":1}}],[\"为了减少临时对象在堆内分配的数量\",{\"1\":{\"20\":1}}],[\"为了减少在64位平台下的内存消耗\",{\"1\":{\"19\":1}}],[\"为了在程序启动响应速度与运行效率之间达到最佳平衡\",{\"1\":{\"7\":1}}],[\"为对象分配空间\",{\"1\":{\"16\":1}}],[\"则order\",{\"1\":{\"233\":1}}],[\"则根据第三范式\",{\"1\":{\"212\":1}}],[\"则binlog文件默认会放在data数据目录下\",{\"1\":{\"206\":1}}],[\"则表明提交该数据的事务在生成视图时已经提交\",{\"1\":{\"189\":1}}],[\"则表明提交该数据的事务在生成视图时仍在活跃\",{\"1\":{\"189\":1}}],[\"则表明是该事务提交的数据\",{\"1\":{\"189\":1}}],[\"则其他session没法在这个范围所包含的所有行记录\",{\"1\":{\"177\":1}}],[\"则保留\",{\"1\":{\"152\":1}}],[\"则它的子节点必须是黑色的\",{\"1\":{\"101\":1}}],[\"则可能就要触发mixedgc了\",{\"1\":{\"57\":1}}],[\"则可以使用指针碰撞方法\",{\"1\":{\"16\":1}}],[\"则执行新生代和老年代的混合收集\",{\"1\":{\"57\":1}}],[\"则执行类加载过程\",{\"1\":{\"15\":1}}],[\"则region大小为2m\",{\"1\":{\"52\":1}}],[\"则按后退查看前面浏览过的页面时\",{\"1\":{\"27\":1}}],[\"则计数减1\",{\"1\":{\"25\":1}}],[\"则计数加1\",{\"1\":{\"25\":1}}],[\"则报oom\",{\"1\":{\"24\":2}}],[\"则会把这些软引用的对象回收掉\",{\"1\":{\"27\":1}}],[\"则会触发full\",{\"1\":{\"24\":1}}],[\"则会对老年代剩余可用空间大小和之前每一次minor\",{\"1\":{\"24\":1}}],[\"则无法进行内联\",{\"1\":{\"8\":2}}],[\"解决了不可重复读问题\",{\"1\":{\"175\":1}}],[\"解决了脏读问题\",{\"1\":{\"174\":1,\"175\":1}}],[\"解决存储空间\",{\"1\":{\"116\":1}}],[\"解析和初始化过程\",{\"1\":{\"15\":1}}],[\"解释器可能还要替编译器收集性能监控信息\",{\"1\":{\"7\":1}}],[\"解释器监控比率为33\",{\"1\":{\"6\":1}}],[\"解释器监控比率\",{\"1\":{\"6\":1}}],[\"解释执行与编译执行\",{\"0\":{\"5\":1}}],[\"两者最大的区别就是stringbuildr是线程不安全的\",{\"1\":{\"12\":1}}],[\"以存储各个实例的惟一标识\",{\"1\":{\"211\":1}}],[\"以两个文件为例子\",{\"1\":{\"205\":1}}],[\"以便于恢复磁盘数据\",{\"1\":{\"190\":1,\"202\":1}}],[\"以便日后进一步提高性能\",{\"1\":{\"67\":1}}],[\"以得到最终结果\",{\"1\":{\"188\":1}}],[\"以下语句执行效率\",{\"1\":{\"153\":1}}],[\"以下优化方式各有优缺点\",{\"1\":{\"143\":1}}],[\"以下命令都是在测试环境执行\",{\"1\":{\"69\":1}}],[\"以社交场景app来举例\",{\"1\":{\"139\":1}}],[\"以此来减少树高度的快速增大\",{\"1\":{\"101\":1}}],[\"以前的垃圾回收器的gc信息都保存在对象头中\",{\"1\":{\"66\":1}}],[\"以及一些\",{\"1\":{\"199\":1}}],[\"以及行记录所在的间隙里插入或修改任何数据\",{\"1\":{\"177\":1}}],[\"以及加载类的数量\",{\"1\":{\"88\":1}}],[\"以及此速率下内存将要耗尽的时间点\",{\"1\":{\"70\":1}}],[\"以及大对象区\",{\"1\":{\"55\":1}}],[\"以及以前的版本中与\",{\"1\":{\"36\":1}}],[\"以极高概率满足gc停顿时间要求的同时\",{\"1\":{\"52\":1}}],[\"以java\",{\"1\":{\"47\":1}}],[\"以上条件在实际生产中一般不会出现\",{\"1\":{\"144\":1}}],[\"以上的查询\",{\"1\":{\"139\":1}}],[\"以上的堆被存活对象占用\",{\"1\":{\"59\":1}}],[\"以上的对象都放入老年代\",{\"1\":{\"23\":1,\"57\":1}}],[\"以上无论是对引用关系记录的插入还是删除\",{\"1\":{\"43\":1}}],[\"以上代码分别测试了stringbuffer和stringbuilder的字符串构建方法\",{\"1\":{\"12\":1}}],[\"以字节为单位\",{\"1\":{\"0\":1}}],[\"bcnf\",{\"1\":{\"209\":1}}],[\"balance\",{\"1\":{\"173\":1}}],[\"barriers的存在\",{\"1\":{\"68\":1}}],[\"barriers\",{\"1\":{\"68\":1}}],[\"barrier\",{\"1\":{\"44\":2,\"45\":1,\"47\":2,\"68\":2}}],[\"b=t2\",{\"1\":{\"149\":1,\"151\":1}}],[\"bnl\",{\"0\":{\"149\":1},\"1\":{\"149\":2}}],[\"block\",{\"0\":{\"149\":1},\"1\":{\"149\":1}}],[\"blocked\",{\"1\":{\"83\":1}}],[\"bin=mysql\",{\"1\":{\"206\":1}}],[\"bin设置binlog的存放位置\",{\"1\":{\"206\":1}}],[\"bin\",{\"1\":{\"206\":1}}],[\"binlog保存了所有修改操作\",{\"1\":{\"206\":1}}],[\"binlog二进制归档日志\",{\"0\":{\"206\":1}}],[\"binlog\",{\"1\":{\"202\":3,\"206\":2}}],[\"bits\",{\"1\":{\"129\":2}}],[\"bit\",{\"1\":{\"129\":1}}],[\"bigint所占空间是依次增大的\",{\"1\":{\"230\":1}}],[\"bigint\",{\"1\":{\"107\":1}}],[\"best\",{\"1\":{\"129\":2}}],[\"be\",{\"1\":{\"129\":1}}],[\"begin\",{\"1\":{\"83\":2,\"121\":1,\"189\":1}}],[\"beginning\",{\"1\":{\"43\":1}}],[\"by同理\",{\"1\":{\"233\":1}}],[\"by和group\",{\"1\":{\"233\":1}}],[\"by后面的条件列创建索引\",{\"1\":{\"233\":1}}],[\"by语句的排序\",{\"1\":{\"139\":1}}],[\"by语句使用索引最左前列\",{\"1\":{\"131\":1}}],[\"by用上索引\",{\"1\":{\"137\":1}}],[\"by设计索引\",{\"1\":{\"137\":1}}],[\"by出现索引设计冲突时\",{\"1\":{\"137\":1}}],[\"by冲突时优先where\",{\"0\":{\"137\":1}}],[\"by也是同理\",{\"1\":{\"136\":1}}],[\"by的顺序\",{\"1\":{\"233\":1}}],[\"by的字段\",{\"1\":{\"134\":1}}],[\"by的优化如果不需要排序的可以加上order\",{\"1\":{\"131\":1}}],[\"by的条件不在索引列上\",{\"1\":{\"131\":1}}],[\"by很类似\",{\"1\":{\"131\":1}}],[\"by与order\",{\"1\":{\"131\":1}}],[\"by与group\",{\"0\":{\"131\":1}}],[\"by子句条件列组合满足索引最左前列\",{\"1\":{\"131\":1}}],[\"by满足两种情况会使用using\",{\"1\":{\"131\":1}}],[\"by默认升序\",{\"1\":{\"131\":1}}],[\"by优化\",{\"0\":{\"131\":1}}],[\"by\",{\"1\":{\"129\":6,\"131\":1,\"134\":1,\"136\":1,\"139\":2,\"146\":2,\"216\":1,\"233\":3}}],[\"byte\",{\"1\":{\"79\":1}}],[\"bytes\",{\"1\":{\"79\":1}}],[\"btree\",{\"1\":{\"121\":1}}],[\"b+树索引\",{\"1\":{\"226\":1}}],[\"b+tree\",{\"0\":{\"103\":1}}],[\"b+\",{\"0\":{\"104\":1,\"105\":1,\"106\":1},\"1\":{\"99\":2,\"103\":4,\"104\":3,\"105\":1,\"106\":1,\"107\":4,\"112\":1,\"113\":1,\"114\":4,\"115\":2}}],[\"b\",{\"0\":{\"102\":1,\"104\":1,\"117\":1},\"1\":{\"25\":8,\"41\":6,\"44\":1,\"45\":1,\"47\":1,\"79\":1,\"84\":2,\"102\":3,\"104\":2,\"106\":1,\"107\":4,\"148\":1,\"149\":1,\"151\":1,\"152\":8,\"183\":2}}],[\"bbbbbb\",{\"1\":{\"12\":2}}],[\"buffer内存排序一般情况下效率会高于磁盘文件排序\",{\"1\":{\"240\":1}}],[\"bufferpool\",{\"1\":{\"202\":5,\"203\":1,\"205\":1}}],[\"bufferpool的磁盘i\",{\"1\":{\"190\":1}}],[\"buffer默认256k\",{\"1\":{\"150\":1}}],[\"buffer中进行排序\",{\"1\":{\"238\":1}}],[\"buffer中数据删除\",{\"1\":{\"150\":1}}],[\"buffer中可以存放80条数据\",{\"1\":{\"150\":1}}],[\"buffer中的t2表数据\",{\"1\":{\"149\":1}}],[\"buffer中\",{\"1\":{\"149\":1,\"150\":1}}],[\"buffer\",{\"1\":{\"16\":1,\"149\":1,\"150\":1,\"204\":3,\"205\":2,\"238\":1,\"239\":2,\"240\":9}}],[\"bufferstring\",{\"1\":{\"12\":2}}],[\"builderstring\",{\"1\":{\"12\":2}}],[\"场景举例\",{\"1\":{\"12\":1}}],[\"要求数据库表中的每个实例或行必须可以被惟一地区分\",{\"1\":{\"211\":1}}],[\"要先判断一下你对这个表\",{\"1\":{\"200\":1}}],[\"要远高于随机读写磁盘文件\",{\"1\":{\"191\":1,\"203\":1}}],[\"要么都失败\",{\"1\":{\"164\":1}}],[\"要么都成功\",{\"1\":{\"164\":1}}],[\"要么同时失败\",{\"1\":{\"164\":1}}],[\"要查询\",{\"1\":{\"111\":1}}],[\"要回收的集合\",{\"1\":{\"52\":1}}],[\"要真正宣告一个对象死亡\",{\"1\":{\"28\":1}}],[\"要开启栈上分配\",{\"1\":{\"11\":1}}],[\"要知道某段代码是否是热点代码\",{\"1\":{\"6\":1}}],[\"拆分成最精简的标量\",{\"1\":{\"11\":1}}],[\"才真正启动事务\",{\"1\":{\"189\":1}}],[\"才会执行其它进程的读写操作\",{\"1\":{\"170\":1}}],[\"才会执行其它进程的写操作\",{\"1\":{\"170\":1}}],[\"才会进入\",{\"1\":{\"8\":1}}],[\"才能使用索引\",{\"1\":{\"233\":1}}],[\"才能让我们的\",{\"1\":{\"203\":1}}],[\"才能让我们的mysql数据库在较高配置的机器上每秒可以抗下几干甚至上万的读写请求\",{\"1\":{\"191\":1}}],[\"才能定位到具体数据\",{\"1\":{\"99\":1}}],[\"才能放到栈中\",{\"1\":{\"11\":1}}],[\"也可能会导致一些表索引失效\",{\"1\":{\"217\":1}}],[\"也可以是相对路径\",{\"1\":{\"206\":1}}],[\"也可以在my\",{\"1\":{\"205\":1}}],[\"也可以设置内存溢出自动导出dump文件\",{\"1\":{\"81\":1}}],[\"也可以反过来\",{\"1\":{\"34\":1}}],[\"也应该构建它\",{\"1\":{\"212\":1}}],[\"也提供按需使用\",{\"1\":{\"197\":1}}],[\"也不是绝对的\",{\"1\":{\"136\":1}}],[\"也不一定就会走索引下推\",{\"1\":{\"128\":1}}],[\"也叫聚簇索引\",{\"1\":{\"113\":1}}],[\"也是向后移动循环使用\",{\"1\":{\"205\":1}}],[\"也是\",{\"1\":{\"107\":1}}],[\"也是6g左右\",{\"1\":{\"69\":1}}],[\"也是目前最常用的一种方式\",{\"1\":{\"48\":1}}],[\"也没有从堆中读取数据\",{\"1\":{\"68\":1}}],[\"也会导致结果不准确\",{\"1\":{\"144\":1}}],[\"也会根据大小进行排序\",{\"1\":{\"115\":1}}],[\"也会快速导致一些对象进入老年代中\",{\"1\":{\"58\":1}}],[\"也会将humongous区一并回收\",{\"1\":{\"52\":1}}],[\"也会对年轻代一起做标记\",{\"1\":{\"40\":1}}],[\"也会触发full\",{\"1\":{\"24\":1}}],[\"也许没回收完就再次触发full\",{\"1\":{\"39\":1}}],[\"也并非是\",{\"1\":{\"28\":1}}],[\"也间接影响了应用的性能\",{\"1\":{\"20\":1}}],[\"也必须要对对象进行最大程度的瘦身\",{\"1\":{\"11\":1}}],[\"也就加大了编译执行的难度\",{\"1\":{\"8\":1}}],[\"也就是在第二范式的基础上消除了非主键对主键的传递依赖\",{\"1\":{\"212\":1}}],[\"也就是之前执行过相同的\",{\"1\":{\"197\":1}}],[\"也就是\",{\"1\":{\"29\":1,\"39\":1}}],[\"也就是需要使用invokevirtual指令调用\",{\"1\":{\"8\":1}}],[\"也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的\",{\"1\":{\"228\":1}}],[\"也就是说如果我们在\",{\"1\":{\"201\":1}}],[\"也就是说可以给年轻代分配个三四十g的内存用来支撑高并发处理\",{\"1\":{\"60\":1}}],[\"也就是说region的区域功能可能会动态变化\",{\"1\":{\"52\":1}}],[\"也就是说通过调用finalize方法自我救命的机会就一次\",{\"1\":{\"28\":1}}],[\"也就是说\",{\"1\":{\"5\":1,\"62\":1}}],[\"可将其拆分\",{\"1\":{\"210\":1}}],[\"可显式的指定查询缓存\",{\"1\":{\"197\":1}}],[\"可重复读\",{\"0\":{\"175\":1}}],[\"可重复读repeatable\",{\"1\":{\"172\":1}}],[\"可正常修改\",{\"1\":{\"170\":1}}],[\"可改写为以主键为条件\",{\"1\":{\"144\":1}}],[\"可大大减少存储的空间\",{\"1\":{\"116\":1}}],[\"可使得g1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡\",{\"1\":{\"52\":1}}],[\"可预测的停顿\",{\"1\":{\"52\":1}}],[\"可能需要关联多张表\",{\"1\":{\"217\":1}}],[\"可能需要多次磁盘\",{\"1\":{\"99\":1}}],[\"可能存储了大量不需要的冗余信息\",{\"1\":{\"209\":1}}],[\"可能出现\",{\"1\":{\"172\":6}}],[\"可能的最大分配速率\",{\"1\":{\"70\":1}}],[\"可能回收其中800个region刚好需要200ms\",{\"1\":{\"52\":1}}],[\"可能会出现数据错误或不一致情况\",{\"1\":{\"220\":1}}],[\"可能会让innodb的整体性能表现不仅不能比myisam高\",{\"1\":{\"179\":1}}],[\"可能会生成类似sql语句执行\",{\"1\":{\"139\":1}}],[\"可能会导不出来\",{\"1\":{\"81\":1}}],[\"可能会横跨多个region来存放\",{\"1\":{\"52\":1}}],[\"可能会有导致已经标记过的对象状态发生改变\",{\"1\":{\"39\":1}}],[\"可能隶属于多个线程\",{\"1\":{\"11\":1}}],[\"可达性分析\",{\"0\":{\"26\":1},\"1\":{\"47\":1}}],[\"可通过二进制文件排查\",{\"1\":{\"206\":1}}],[\"可通过该命令查找死锁\",{\"1\":{\"82\":1}}],[\"可通过jvisualvm命令工具导入该hprof文件分析\",{\"1\":{\"81\":1}}],[\"可通过zproactive参数配置\",{\"1\":{\"70\":1}}],[\"可通过zcollectioninterval参数配置\",{\"1\":{\"70\":1}}],[\"可通过\",{\"1\":{\"21\":1}}],[\"可以适当增大\",{\"1\":{\"240\":1}}],[\"可以适当把\",{\"1\":{\"240\":1}}],[\"可以过滤掉更多的行\",{\"1\":{\"231\":1}}],[\"可以查询官方文档\",{\"1\":{\"228\":1}}],[\"可以采用这种写热点的分散的方式\",{\"1\":{\"223\":1}}],[\"可以增加一个槽\",{\"1\":{\"223\":1}}],[\"可以更好的进行索引优化\",{\"1\":{\"219\":1}}],[\"可以更少的使用distinct和order\",{\"1\":{\"216\":1}}],[\"可以减少表的关联\",{\"1\":{\"219\":1}}],[\"可以是绝对路径\",{\"1\":{\"206\":1}}],[\"可以将计数器保存在多行中\",{\"1\":{\"223\":1}}],[\"可以将\",{\"1\":{\"197\":1}}],[\"可以将统计计数的数据维护到数据库的一个表中\",{\"1\":{\"160\":1}}],[\"可以省略后续查询硬盘等步骤\",{\"1\":{\"197\":1}}],[\"可以使用如下命令\",{\"1\":{\"158\":1}}],[\"可以根据监控后台的一些慢sql\",{\"1\":{\"138\":1}}],[\"可以稍微优化下\",{\"1\":{\"136\":1}}],[\"可以有效的减少回表次数\",{\"1\":{\"127\":1}}],[\"可以有效解决大内存带来的垃圾回收时间过长问题\",{\"1\":{\"60\":1}}],[\"可以在sort\",{\"1\":{\"240\":1}}],[\"可以在索引遍历过程中\",{\"1\":{\"127\":1}}],[\"可以在周期性数据输出后\",{\"1\":{\"88\":1}}],[\"可以看到其实计划都一样\",{\"1\":{\"153\":1}}],[\"可以看到\",{\"1\":{\"115\":1,\"149\":1}}],[\"可以看到数据对应的是该数据库中的数据表\",{\"1\":{\"109\":1}}],[\"可以用来恢复硬盘上的数据库数据\",{\"1\":{\"206\":1}}],[\"可以用覆盖索引优化\",{\"1\":{\"129\":1,\"131\":1}}],[\"可以用\",{\"1\":{\"98\":1}}],[\"可以用jvm参数\",{\"1\":{\"52\":1}}],[\"可以把频率1秒换成1分钟\",{\"1\":{\"90\":1}}],[\"可以执行命令\",{\"1\":{\"90\":1}}],[\"可以调优的参数都比较少\",{\"1\":{\"69\":1}}],[\"可以动态变化\",{\"1\":{\"64\":1}}],[\"可以由用户指定期望的停顿时间是g1收集器很强大的一个功能\",{\"1\":{\"52\":1}}],[\"可以节约老年代的空间\",{\"1\":{\"52\":1}}],[\"可以类比为java语言中hashmap与map的关系\",{\"1\":{\"48\":1}}],[\"可以参考aop的概念\",{\"1\":{\"44\":1}}],[\"可以与垃圾收集线程一起并发运行\",{\"1\":{\"39\":1}}],[\"可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择\",{\"1\":{\"37\":1}}],[\"可以给对象添加一个引用计数\",{\"1\":{\"25\":1}}],[\"可以进行干预内联行为\",{\"1\":{\"8\":1}}],[\"可以通过参数\",{\"1\":{\"22\":1}}],[\"可以通过对对象指针存入堆内存时压缩编码\",{\"1\":{\"19\":1}}],[\"可以通过添加参数\",{\"1\":{\"10\":1}}],[\"可以通过调整jvm参数\",{\"1\":{\"8\":1}}],[\"可以通过\",{\"1\":{\"6\":1,\"52\":2}}],[\"那就知道是需要进行查询\",{\"1\":{\"198\":1}}],[\"那就必须扫描所有的虚拟机栈\",{\"1\":{\"11\":1}}],[\"那客户端a查询到的数据其实就是脏数据\",{\"1\":{\"173\":1}}],[\"那个表参与连接的数据小\",{\"1\":{\"151\":1}}],[\"那怎么办了\",{\"1\":{\"139\":1}}],[\"那怎么来优化这种情况了\",{\"1\":{\"139\":1}}],[\"那怎么优化了\",{\"1\":{\"139\":1}}],[\"那我们是否能把\",{\"1\":{\"139\":1}}],[\"那我们是否应该设计一个联合索引\",{\"1\":{\"139\":1}}],[\"那用索引就没有太大的意义了\",{\"1\":{\"135\":1}}],[\"那基本上它就真的被回收了\",{\"1\":{\"28\":1}}],[\"那在第二次标记时它将移除出\",{\"1\":{\"28\":1}}],[\"那大量的对象就会随着方法的结束而自动销毁了\",{\"1\":{\"11\":1}}],[\"那让这个对象在栈上分配内存将会是一个很不错的主意\",{\"1\":{\"11\":1}}],[\"那么使用双路排序模式\",{\"1\":{\"238\":1}}],[\"那么使用单路排序模式\",{\"1\":{\"238\":1}}],[\"那么在员工信息表中列出部门编号后就不能再将部门名称\",{\"1\":{\"212\":1}}],[\"那么在不超过\",{\"1\":{\"0\":1}}],[\"那么缓存中对应的表的缓存全部会失效\",{\"1\":{\"197\":1}}],[\"那么上面那个索引是很难用上的\",{\"1\":{\"139\":1}}],[\"那么一般性能还是比较高的\",{\"1\":{\"139\":1}}],[\"那么一页就是\",{\"1\":{\"107\":1}}],[\"那么此时你的name因为在索引树里仅仅包含了前20个字符\",{\"1\":{\"136\":1}}],[\"那么此时就会先到索引树里根据name字段的前20个字符去搜索\",{\"1\":{\"136\":1}}],[\"那么此时大于等于这批对象年龄最大值的对象\",{\"1\":{\"23\":1}}],[\"那么才能发挥出b+树快速二分查找的优势来\",{\"1\":{\"135\":1}}],[\"那么该字段的基数就是2\",{\"1\":{\"135\":1}}],[\"那么为什么呢\",{\"1\":{\"118\":1}}],[\"那么当我们通过name或price进行查询时\",{\"1\":{\"116\":1}}],[\"那么整个\",{\"1\":{\"107\":1}}],[\"那么我们就可以把索引设计成\",{\"1\":{\"139\":1}}],[\"那么我们怎样维护这个联合索引呢\",{\"1\":{\"117\":1}}],[\"那么我们来算算\",{\"1\":{\"107\":1}}],[\"那么我们的\",{\"1\":{\"35\":1}}],[\"那么需要\",{\"1\":{\"98\":1}}],[\"那么可以执行命令\",{\"1\":{\"92\":1}}],[\"那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢\",{\"1\":{\"68\":1}}],[\"那么正常往下执行即可\",{\"1\":{\"68\":1}}],[\"那么程序还不能往下执行\",{\"1\":{\"68\":1}}],[\"那么程序真正执行的时候将可能不去创建这个对象\",{\"1\":{\"10\":1}}],[\"那么\",{\"1\":{\"68\":2}}],[\"那么设置\",{\"1\":{\"60\":1}}],[\"那么意味着整个系统每运行一两分钟就会因为young\",{\"1\":{\"60\":1}}],[\"那么存活下来的对象可能就会很多\",{\"1\":{\"58\":1}}],[\"那么增加年轻代的region\",{\"1\":{\"54\":1}}],[\"那么就会继续执行后续的阶段\",{\"1\":{\"197\":1}}],[\"那么就会触发young\",{\"1\":{\"54\":1}}],[\"那么就只会回收800个region\",{\"1\":{\"52\":1}}],[\"那么就没有必要太过深⼊的去了解了\",{\"1\":{\"4\":1}}],[\"那么通过之前回收成本计算得知\",{\"1\":{\"52\":1}}],[\"那么年轻代就是200m左右内存\",{\"1\":{\"52\":1}}],[\"那么本轮gc不会回收这部分内存\",{\"1\":{\"42\":1}}],[\"那么垃圾收集器就是内存回收的具体实现\",{\"1\":{\"35\":1}}],[\"那么如何判断一个类是无用的类呢\",{\"1\":{\"29\":1}}],[\"那么内存回收时就必须能识别哪些对象应放在新生代\",{\"1\":{\"22\":1}}],[\"那么他内部的锁就不会存在竞争\",{\"1\":{\"12\":1}}],[\"那么堆中的同一个对象\",{\"1\":{\"11\":1}}],[\"那么这些变量就可以称为标量\",{\"1\":{\"10\":1}}],[\"那么具体调用的方法\",{\"1\":{\"8\":1}}],[\"那么server模式下的虚拟机回边计数器的阈值就为10700\",{\"1\":{\"6\":1}}],[\"那么jvm如何执行class的字节码文件呢\",{\"1\":{\"5\":1}}],[\"并回滚产生死锁的那个事务\",{\"1\":{\"183\":1}}],[\"并在a中查询\",{\"1\":{\"173\":1}}],[\"并将该数据所在的页\",{\"1\":{\"190\":1,\"202\":1}}],[\"并将符合条件的数据返回\",{\"1\":{\"150\":1}}],[\"并将对象年龄设为1\",{\"1\":{\"22\":1}}],[\"并根据关联关系\",{\"1\":{\"148\":1}}],[\"并不是数据库级别的\",{\"1\":{\"109\":1}}],[\"并通过标记整理算法清除垃圾对象\",{\"1\":{\"66\":1}}],[\"并同时修正更新该引用的值\",{\"1\":{\"65\":1}}],[\"并为重分配集中的每个region维护一个转发表\",{\"1\":{\"65\":1}}],[\"并行与并发\",{\"1\":{\"52\":1}}],[\"并发影响的越小\",{\"1\":{\"172\":1}}],[\"并发能力高\",{\"1\":{\"171\":1}}],[\"并发事务带来的问题\",{\"0\":{\"165\":1}}],[\"并发重映射\",{\"1\":{\"65\":1}}],[\"并发重分配\",{\"1\":{\"65\":1}}],[\"并发重置\",{\"1\":{\"39\":1}}],[\"并发预备重分配\",{\"1\":{\"65\":1}}],[\"并发的gc线程数\",{\"1\":{\"40\":1}}],[\"并发收集\",{\"1\":{\"39\":1}}],[\"并发清理\",{\"1\":{\"39\":1}}],[\"并发标记也是遍历对象图做可达性分析的阶段\",{\"1\":{\"65\":1}}],[\"并发标记阶段就是从gc\",{\"1\":{\"39\":1}}],[\"并发标记\",{\"1\":{\"39\":1,\"52\":1,\"65\":1}}],[\"并发分配时解决办法\",{\"1\":{\"16\":1}}],[\"并记录下\",{\"1\":{\"39\":1}}],[\"并检查这个类的符号引用所指向的类是否已加载\",{\"1\":{\"15\":1}}],[\"并由\",{\"1\":{\"11\":1}}],[\"并且可以使用一些更高级的技巧\",{\"1\":{\"223\":1}}],[\"并且用两个字段trx\",{\"1\":{\"188\":1}}],[\"并且该索引不能失效\",{\"1\":{\"178\":1}}],[\"并且根据主键排序时\",{\"0\":{\"144\":1}}],[\"并且推荐使用整型的自增主键\",{\"0\":{\"114\":1}}],[\"并且不能超过1秒\",{\"1\":{\"71\":1}}],[\"并且没有停顿时间的要求\",{\"1\":{\"71\":1}}],[\"并且把堆里的这个指针\",{\"1\":{\"68\":1}}],[\"并且能被\",{\"1\":{\"22\":1}}],[\"并且这个对象可以被拆散\",{\"1\":{\"10\":1}}],[\"并且逻辑非常简单的方法\",{\"1\":{\"8\":1}}],[\"并且解释器不开启性能监控\",{\"1\":{\"7\":1}}],[\"并且设置的比初始值要大\",{\"1\":{\"0\":1}}],[\"error\",{\"1\":{\"198\":1}}],[\"eq\",{\"1\":{\"129\":1}}],[\"equality\",{\"1\":{\"129\":1}}],[\"estimation\",{\"1\":{\"129\":2}}],[\"escape\",{\"0\":{\"9\":1}}],[\"extra\",{\"1\":{\"149\":1}}],[\"execution\",{\"1\":{\"129\":4}}],[\"exp\",{\"1\":{\"231\":1,\"232\":2}}],[\"expire\",{\"1\":{\"206\":1}}],[\"expanded\",{\"1\":{\"129\":1}}],[\"explain\",{\"1\":{\"123\":1,\"124\":1,\"125\":1,\"126\":4,\"127\":2,\"129\":3,\"148\":1,\"149\":1}}],[\"exists子句返回0\",{\"1\":{\"152\":1}}],[\"exists子句返回1\",{\"1\":{\"152\":1}}],[\"exists执行逻辑\",{\"1\":{\"152\":1}}],[\"exists优先in\",{\"1\":{\"152\":1}}],[\"exists\",{\"1\":{\"121\":1,\"152\":1}}],[\"emp\",{\"1\":{\"121\":3,\"211\":1}}],[\"employees\",{\"1\":{\"121\":4,\"123\":1,\"124\":3,\"125\":1,\"126\":4,\"127\":3,\"129\":5,\"142\":1,\"144\":1,\"145\":2,\"146\":3}}],[\"engine\",{\"1\":{\"182\":1}}],[\"engine=innodb\",{\"1\":{\"121\":1}}],[\"enabled=off\",{\"1\":{\"129\":1}}],[\"enabled=on\",{\"1\":{\"129\":1}}],[\"end\",{\"0\":{\"142\":1},\"1\":{\"65\":1,\"83\":3,\"121\":2,\"129\":1}}],[\"e\",{\"1\":{\"83\":2,\"146\":1}}],[\"events\",{\"1\":{\"61\":1}}],[\"eden区的使用\",{\"1\":{\"90\":1}}],[\"eden区对应800个\",{\"1\":{\"52\":1}}],[\"eden和survivor的比例\",{\"1\":{\"89\":1}}],[\"eden\",{\"1\":{\"22\":1}}],[\"eliminatelocks​\",{\"1\":{\"12\":1}}],[\"eliminateallocations​\",{\"1\":{\"10\":1}}],[\"elision\",{\"0\":{\"12\":1}}],[\"中一次排序更多的行\",{\"1\":{\"240\":1}}],[\"中进行排序\",{\"1\":{\"238\":1,\"240\":1}}],[\"中数据刷入磁盘相应数据\",{\"1\":{\"202\":1}}],[\"中数据\",{\"1\":{\"202\":1}}],[\"中没有关键字时\",{\"1\":{\"198\":1}}],[\"中读取数据\",{\"1\":{\"148\":1}}],[\"中间就是可写区域\",{\"1\":{\"205\":1}}],[\"中间字段不能断\",{\"1\":{\"131\":1}}],[\"中间是指针作为内存临界标识\",{\"1\":{\"16\":1}}],[\"中占\",{\"1\":{\"107\":1}}],[\"中的字段\",{\"1\":{\"240\":1}}],[\"中的数据按照字段\",{\"1\":{\"239\":1}}],[\"中的数据进行更新\",{\"1\":{\"202\":1}}],[\"中的日志\",{\"1\":{\"205\":1}}],[\"中的\",{\"1\":{\"100\":1,\"103\":1}}],[\"中型region\",{\"1\":{\"64\":1}}],[\"中\",{\"1\":{\"64\":1,\"66\":1,\"113\":1,\"149\":1,\"202\":1,\"205\":1,\"239\":1,\"240\":3}}],[\"中用于运行用户代码的时间与\",{\"1\":{\"37\":1}}],[\"中成功拯救自己\",{\"1\":{\"28\":1}}],[\"中每熬过一次\",{\"1\":{\"22\":1}}],[\"中所有对象都应该创建在堆上\",{\"1\":{\"11\":1}}],[\"中默认开启了标量替换\",{\"1\":{\"10\":1}}],[\"中后会发现\",{\"1\":{\"8\":1}}],[\"如时间\",{\"1\":{\"195\":1}}],[\"如有t1表\",{\"1\":{\"148\":1}}],[\"如主键插入是\",{\"1\":{\"115\":1}}],[\"如下所示\",{\"1\":{\"200\":1}}],[\"如下\",{\"1\":{\"100\":1,\"129\":1}}],[\"如下面的代码\",{\"1\":{\"68\":1}}],[\"如下面代码所示\",{\"1\":{\"25\":1}}],[\"如下图所示\",{\"1\":{\"66\":1}}],[\"如\",{\"1\":{\"44\":2,\"127\":1,\"194\":1,\"210\":1}}],[\"如实际是32位的地址\",{\"1\":{\"19\":1}}],[\"如哈希码\",{\"1\":{\"18\":1}}],[\"如何创建高性能索引\",{\"0\":{\"229\":1}}],[\"如何保证事务较高的隔离级别\",{\"1\":{\"187\":1}}],[\"如何保证数据在并发情况下的一致性\",{\"1\":{\"166\":1}}],[\"如何选择垃圾回收器\",{\"0\":{\"71\":1}}],[\"如何更新卡表对应的标识为1\",{\"1\":{\"49\":1}}],[\"如何才能找到类的元信息\",{\"1\":{\"18\":1}}],[\"如何划分\",{\"1\":{\"16\":1}}],[\"如int的0值等\",{\"1\":{\"17\":1}}],[\"如上方法中\",{\"1\":{\"9\":1}}],[\"如果字段的总长度大于max\",{\"1\":{\"238\":1}}],[\"如果字段的总长度小于max\",{\"1\":{\"238\":1}}],[\"如果索引中的顺序和查询的排序顺序一致\",{\"1\":{\"234\":1}}],[\"如果mysql服务意外停止\",{\"1\":{\"206\":1}}],[\"如果命中查询缓存\",{\"1\":{\"200\":1}}],[\"如果缓存中没有对应的结果\",{\"1\":{\"197\":1}}],[\"如果更新条件为非索引字段\",{\"1\":{\"178\":1}}],[\"如果事务a需要修改数据\",{\"1\":{\"175\":1}}],[\"如果只需要知道表的总行数估值\",{\"1\":{\"158\":1}}],[\"如果在b表中存在\",{\"1\":{\"152\":1}}],[\"如果在minor\",{\"1\":{\"40\":1}}],[\"如果表b的数据集大小小于表a\",{\"1\":{\"152\":1}}],[\"如果表中没有符合条件的列\",{\"1\":{\"114\":1}}],[\"如果表中有主键索引的话\",{\"1\":{\"114\":1}}],[\"如果放不下t2表数据\",{\"1\":{\"150\":1}}],[\"如果走辅助索引\",{\"1\":{\"146\":1}}],[\"如果order\",{\"1\":{\"131\":1}}],[\"如果用name索引需要遍历name字段联合索引树\",{\"1\":{\"129\":1}}],[\"如果用户线程此时并发访问了位于重分配集中的对象\",{\"1\":{\"65\":1}}],[\"如果同一张表有多个聚集索引\",{\"1\":{\"116\":1}}],[\"如果同时打开了对应的工程\",{\"1\":{\"81\":1}}],[\"如果查询的字段包括在索引中\",{\"1\":{\"116\":1}}],[\"如果\",{\"1\":{\"111\":1,\"240\":2}}],[\"如果使用\",{\"1\":{\"107\":1}}],[\"如果使用tlab\",{\"1\":{\"17\":1}}],[\"如果发生了\",{\"1\":{\"99\":1}}],[\"如果发生了线程逃逸\",{\"1\":{\"11\":1}}],[\"如果我们想使用联合索引\",{\"1\":{\"118\":1}}],[\"如果我们使用id作为主键索引\",{\"1\":{\"116\":1}}],[\"如果我们使用二叉树给表\",{\"1\":{\"100\":1}}],[\"如果我们不根据联合索引字段去查询\",{\"1\":{\"118\":1}}],[\"如果我们不建立主键索引\",{\"1\":{\"114\":1}}],[\"如果我们不使用数据结构存储\",{\"1\":{\"98\":1}}],[\"如果我们可以使用二叉树存储数据\",{\"1\":{\"98\":1}}],[\"如果系统负载不高\",{\"1\":{\"90\":1}}],[\"如果响应时间最重要\",{\"1\":{\"71\":1}}],[\"如果允许停顿时间超过1秒\",{\"1\":{\"71\":1}}],[\"如果是根据name字段来搜索\",{\"1\":{\"136\":1}}],[\"如果是联合索引\",{\"1\":{\"118\":1}}],[\"如果是递增\",{\"1\":{\"115\":1}}],[\"如果是增量的范围查询\",{\"1\":{\"106\":1}}],[\"如果是单核\",{\"1\":{\"71\":1}}],[\"如果是小于或参数未设置\",{\"1\":{\"24\":1}}],[\"如果内存小于100m\",{\"1\":{\"71\":1}}],[\"如果指针是good\",{\"1\":{\"68\":1}}],[\"如果指针是bad\",{\"1\":{\"68\":1}}],[\"如果这时候对象在gc时被移动了\",{\"1\":{\"68\":1}}],[\"如果这个对象覆盖了finalize方法\",{\"1\":{\"28\":1}}],[\"如果超过这个值\",{\"1\":{\"57\":1}}],[\"如果回收时间远远小于参数\",{\"1\":{\"54\":1}}],[\"如果回收完还没有足够的空间\",{\"1\":{\"24\":2}}],[\"如果region进行了垃圾回收\",{\"1\":{\"52\":1}}],[\"如果堆大小为4096m\",{\"1\":{\"52\":1}}],[\"如果由于方法运行结束导致部分局部变量\",{\"1\":{\"42\":1}}],[\"如果有权限\",{\"1\":{\"200\":1}}],[\"如果有\",{\"1\":{\"197\":1}}],[\"如果有接近1000个region都是老年代的region\",{\"1\":{\"57\":1}}],[\"如果有其他对象引用指向了黑色对象\",{\"1\":{\"41\":1}}],[\"如果有一种四海之内\",{\"1\":{\"35\":1}}],[\"如果不存在部门信息表\",{\"1\":{\"212\":1}}],[\"如果不按照最左匹配原则来查询\",{\"1\":{\"118\":1}}],[\"如果不指定\",{\"1\":{\"40\":1}}],[\"如果不会逃逸可以将该对象在栈上分配内存\",{\"1\":{\"20\":1}}],[\"如果对这种小基数字段建立索引的话\",{\"1\":{\"135\":1}}],[\"如果对于收集器运作不太了解的话\",{\"1\":{\"37\":1}}],[\"如果对象这时候还没逃脱\",{\"1\":{\"28\":1}}],[\"如果对象要在finalize\",{\"1\":{\"28\":1}}],[\"如果对象在\",{\"1\":{\"22\":1}}],[\"如果对象数量较多的时候\",{\"1\":{\"20\":1}}],[\"如果说收集算法是内存回收的方法论\",{\"1\":{\"35\":1}}],[\"如果需要标记的对象太多\",{\"1\":{\"34\":1}}],[\"如果将浏览过的网页存储到内存中会造成内存的大量浪费\",{\"1\":{\"27\":1}}],[\"如果将循环次数减少\",{\"1\":{\"8\":1}}],[\"如果该对象被引用\",{\"1\":{\"25\":1}}],[\"如果该空间小于年轻代所有剩余对象之和\",{\"1\":{\"24\":1}}],[\"如果比对结果为大于\",{\"1\":{\"24\":1}}],[\"如果设置了\",{\"1\":{\"24\":1}}],[\"如果设置了的话\",{\"1\":{\"0\":1}}],[\"如果新生代的eden区域无法存放\",{\"1\":{\"21\":1}}],[\"如果java内存绝对规整\",{\"1\":{\"16\":1}}],[\"如果没有被引用\",{\"1\":{\"25\":1}}],[\"如果没有\",{\"1\":{\"15\":1,\"200\":1}}],[\"如果能从缓存中获取到查询结果\",{\"1\":{\"197\":1}}],[\"如果能使用栈上分配\",{\"1\":{\"11\":1}}],[\"如果能保证一个方法不会逃逸出方法或线程\",{\"1\":{\"9\":1}}],[\"如果确定一个对象不会逃逸出线程之外\",{\"1\":{\"11\":1}}],[\"如果把一个java对象拆散\",{\"1\":{\"10\":1}}],[\"如果被其他线程访问\",{\"1\":{\"9\":1}}],[\"如果被方法外部所引用或者作为参数传递给其他方法\",{\"1\":{\"9\":1}}],[\"如果一个红色节点上有了两个黑色节点\",{\"1\":{\"101\":1}}],[\"如果一个节点是红色的\",{\"1\":{\"101\":1}}],[\"如果一个网页在浏览结束时就进行内容的回收\",{\"1\":{\"27\":1}}],[\"如果一个方法没有发生逃逸\",{\"1\":{\"12\":1}}],[\"如果一个方法编译后的字节码大于这个值\",{\"1\":{\"8\":1}}],[\"如果一个方法编译后的字节码大小大于这个值\",{\"1\":{\"8\":1}}],[\"如果一个对象的属性无法再分解为更小的数据来表示了\",{\"1\":{\"10\":1}}],[\"如果一个热点方法编译后的字节码大于这个值\",{\"1\":{\"8\":1}}],[\"如果都取默认值\",{\"1\":{\"6\":1}}],[\"如果你不是想要专⻔去研究语⾔\",{\"1\":{\"4\":1}}],[\"如果释放了很少的空间\",{\"1\":{\"0\":1}}],[\"如果释放了大量的空间\",{\"1\":{\"0\":1}}],[\"对数据修改需要考虑的地方更多\",{\"1\":{\"220\":1}}],[\"对\",{\"1\":{\"198\":1,\"239\":1,\"240\":1}}],[\"对同一行数据的读默认不加互斥锁来保证隔离性\",{\"1\":{\"187\":1}}],[\"对各个状态量的说明如下\",{\"1\":{\"181\":1}}],[\"对代码编写有很大影响\",{\"1\":{\"174\":1}}],[\"对mylsam表的写操作\",{\"1\":{\"170\":1}}],[\"对myisam表的读操作\",{\"1\":{\"170\":1}}],[\"对表添加读锁后\",{\"1\":{\"169\":1}}],[\"对某一个表加表锁\",{\"1\":{\"168\":1}}],[\"对应后台sql可能是这样\",{\"1\":{\"139\":1}}],[\"对应大概是100个region\",{\"1\":{\"52\":1}}],[\"对这个字段里的每个值的前20个字符放在索引树里\",{\"1\":{\"136\":1}}],[\"对索引中包含的所有字段先做判断​\",{\"1\":{\"127\":1}}],[\"对我们的查询几乎没有帮助\",{\"1\":{\"100\":1}}],[\"对比距上次gc的间隔时间跟\",{\"1\":{\"70\":1}}],[\"对region回收都是基于复制算法进行的\",{\"1\":{\"57\":1}}],[\"对cpu资源敏感\",{\"1\":{\"39\":1}}],[\"对堆垃圾回收前的第一步就是要判断哪些对象已经死亡\",{\"1\":{\"24\":1}}],[\"对堆内存进行回收\",{\"1\":{\"24\":2}}],[\"对于任何想要更新这一行的事务来说\",{\"1\":{\"223\":1}}],[\"对于高并发下的处理\",{\"1\":{\"223\":1}}],[\"对于一般的\",{\"1\":{\"197\":1}}],[\"对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源\",{\"1\":{\"95\":1}}],[\"对于更新频繁的系统来说\",{\"1\":{\"197\":1}}],[\"对于myisam不带where条件的总行数要求\",{\"1\":{\"157\":1}}],[\"对于爱好之类的字段也可以类似sex字段处理\",{\"1\":{\"139\":1}}],[\"对于后台程序来说除了过滤用户的各种条件\",{\"1\":{\"139\":1}}],[\"对于这种varchar\",{\"1\":{\"136\":1}}],[\"对于这种情况如何合理设计索引\",{\"1\":{\"139\":1}}],[\"对于这种情况\",{\"1\":{\"60\":1}}],[\"对于group\",{\"1\":{\"131\":1}}],[\"对于排序来说\",{\"1\":{\"131\":1}}],[\"对于上面这两种\",{\"1\":{\"129\":1}}],[\"对于innodb引擎的表索引下推只能用于二级索引\",{\"1\":{\"127\":1}}],[\"对于辅助的联合索引\",{\"1\":{\"127\":1}}],[\"对于较高版本的\",{\"1\":{\"107\":1}}],[\"对于根节点\",{\"1\":{\"107\":1}}],[\"对于单边增长的数据\",{\"1\":{\"100\":1}}],[\"对于范围查找并不支持\",{\"1\":{\"99\":1}}],[\"对于kafka来说\",{\"1\":{\"60\":1}}],[\"对于读写屏障\",{\"1\":{\"47\":1}}],[\"对于大部分处理器\",{\"1\":{\"19\":1}}],[\"对于8g内存的系统来说\",{\"1\":{\"0\":1}}],[\"对象的引用关系不会发生变化\",{\"1\":{\"74\":1}}],[\"对象的哈希码\",{\"1\":{\"18\":1}}],[\"对象地址\",{\"1\":{\"66\":1}}],[\"对象分配和晋升的速度变化非常大\",{\"1\":{\"59\":1}}],[\"对象间的引用可能发生变化\",{\"1\":{\"41\":1}}],[\"对象没有在任何地方被引用\",{\"1\":{\"29\":1}}],[\"对象将直接被回收\",{\"1\":{\"28\":1}}],[\"对象作为起点\",{\"1\":{\"26\":1}}],[\"对象动态年龄判断机制一般是在minor\",{\"1\":{\"23\":1}}],[\"对象动态年龄判断\",{\"0\":{\"23\":1}}],[\"对象晋升到老年代的年龄阈值\",{\"1\":{\"22\":1}}],[\"对象以8字节整数倍来对齐填充都是最高效的存取方式\",{\"1\":{\"19\":1}}],[\"对象指针在堆中是32位\",{\"1\":{\"19\":1}}],[\"对象头的另外一部分是类型指针\",{\"1\":{\"18\":1}}],[\"对象头\",{\"1\":{\"18\":1}}],[\"对象头除外\",{\"1\":{\"17\":1}}],[\"对象在\",{\"1\":{\"22\":1}}],[\"对象在内存中存储的布局可以分为3块区域\",{\"1\":{\"18\":1}}],[\"对象在方法中创建后\",{\"1\":{\"9\":1}}],[\"对象gc分代年龄信息等\",{\"1\":{\"18\":1}}],[\"对象所需的内存大小\",{\"1\":{\"16\":1}}],[\"对象所占用的内存空间就可以随栈帧出栈而销毁\",{\"1\":{\"11\":1}}],[\"对象加载完成过后\",{\"1\":{\"16\":1}}],[\"编译器很难在编译时得出绝对正确的结论\",{\"1\":{\"8\":1}}],[\"让优化器优先选择全字段排序\",{\"1\":{\"240\":1}}],[\"让优化器选择使用双路排序算法\",{\"1\":{\"240\":1}}],[\"让他们在同一个事务中处理\",{\"1\":{\"160\":1}}],[\"让mysql尽量走嵌套循环连接\",{\"1\":{\"151\":1}}],[\"让每一个联合索引都尽量去包含sql语句里的where\",{\"1\":{\"134\":1}}],[\"让同事使用top命令查看了一下\",{\"1\":{\"69\":1}}],[\"让更多的方法可以进行内联\",{\"1\":{\"8\":1}}],[\"让编译出来的机器码运行效率更高\",{\"1\":{\"7\":1}}],[\"避免的频繁加锁解锁带来的性能问题\",{\"1\":{\"187\":1}}],[\"避免间隙锁\",{\"1\":{\"184\":1}}],[\"避免无索引行锁升级为表锁\",{\"1\":{\"184\":1}}],[\"避免频繁full\",{\"1\":{\"94\":1}}],[\"避免存活对象太多快速进入老年代\",{\"1\":{\"58\":1}}],[\"避免因为老年代空间不够的gc开销\",{\"1\":{\"52\":1}}],[\"避免把整个老年代加入gcroots扫描范围\",{\"1\":{\"48\":1}}],[\"避免写大方法\",{\"1\":{\"8\":1}}],[\"避免发生真实的方法调用\",{\"1\":{\"8\":1}}],[\"从索引\",{\"1\":{\"240\":2}}],[\"从索引name找到下一个满足\",{\"1\":{\"239\":1}}],[\"从索引name找到第一个满足\",{\"1\":{\"239\":1}}],[\"从文件头开始顺序写日志\",{\"1\":{\"205\":1}}],[\"从执行步骤可以看出\",{\"1\":{\"197\":1}}],[\"从系统启动到现在等待最长的一次所花时间\",{\"1\":{\"181\":1}}],[\"从系统启动到现在锁定总时间长度\",{\"1\":{\"181\":1}}],[\"从对数据的操作粒度上分为表锁和行锁\",{\"1\":{\"167\":1}}],[\"从对数据库的操作上分为读锁和写锁\",{\"1\":{\"167\":1}}],[\"从性能上分为乐观锁\",{\"1\":{\"167\":1}}],[\"从叶子节点扫描\",{\"1\":{\"153\":1}}],[\"从过程中可以看到\",{\"1\":{\"150\":1}}],[\"从t2表取出一条数据\",{\"1\":{\"150\":1}}],[\"从explain的执行结果来看\",{\"1\":{\"131\":1}}],[\"从key\",{\"1\":{\"131\":1}}],[\"从存储结构上来讲\",{\"1\":{\"113\":1}}],[\"从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点\",{\"1\":{\"101\":1}}],[\"从而提升排序效率\",{\"1\":{\"240\":1}}],[\"从而产生using\",{\"1\":{\"131\":1}}],[\"从而存储更多的数据\",{\"1\":{\"101\":1}}],[\"从而可以推算出老年代对象增长速率\",{\"1\":{\"92\":1}}],[\"从而避免真实的调用\",{\"1\":{\"8\":1}}],[\"从堆栈信息中cpu飙高的代码行信息\",{\"1\":{\"84\":1}}],[\"从局部上来看是基于\",{\"1\":{\"52\":1}}],[\"从第一步标记的对象开始\",{\"1\":{\"52\":1}}],[\"从gc\",{\"1\":{\"52\":1}}],[\"从它的名字就可以看出它是一款优秀的垃圾收集器\",{\"1\":{\"39\":1}}],[\"从名字中的\",{\"1\":{\"39\":1}}],[\"从这些节点开始向下搜索引用的对象\",{\"1\":{\"26\":1}}],[\"从这几个相关参数可以看到\",{\"1\":{\"8\":1}}],[\"通俗来说就是个需要关联关系表将相关信息进行关联\",{\"1\":{\"212\":1}}],[\"通俗来说\",{\"1\":{\"211\":1}}],[\"通过比较系统变量\",{\"1\":{\"238\":1}}],[\"通过索引筛选出的数据较少\",{\"1\":{\"231\":1}}],[\"通过表结构\",{\"1\":{\"222\":1}}],[\"通过检查innodb\",{\"0\":{\"181\":1}}],[\"通过这么一个多字段的索引是能够过滤掉绝大部分数据的\",{\"1\":{\"139\":1}}],[\"通过这个指令可以看到哪些方法进行了内联\",{\"1\":{\"8\":1}}],[\"通过观察eu\",{\"1\":{\"90\":1}}],[\"通过printf\",{\"1\":{\"84\":1}}],[\"通过软件方式设计的\",{\"1\":{\"61\":1}}],[\"通过参数\",{\"1\":{\"52\":1}}],[\"通常只修改一处即可\",{\"1\":{\"216\":1}}],[\"通常在实现来说\",{\"1\":{\"211\":1}}],[\"通常的做法是直接全部当成黑色\",{\"1\":{\"42\":1}}],[\"通常指那些只包含一两行语句\",{\"1\":{\"8\":1}}],[\"通常要编译出优化程度越高的代码\",{\"1\":{\"7\":1}}],[\"通常认为将java文件编译成class的字节码文件乘坐前端编译\",{\"1\":{\"3\":1}}],[\"通常是元空间发生了大小调整\",{\"1\":{\"0\":1}}],[\"g\",{\"1\":{\"182\":1}}],[\"group​\",{\"1\":{\"204\":1}}],[\"group\",{\"1\":{\"129\":3,\"131\":1,\"134\":1,\"136\":1,\"204\":4,\"233\":2}}],[\"generated\",{\"1\":{\"129\":2}}],[\"gettrivialvalue\",{\"1\":{\"8\":1}}],[\"global\",{\"1\":{\"107\":1,\"124\":2,\"197\":1,\"205\":1}}],[\"g命令看却又占用了5g\",{\"1\":{\"69\":1}}],[\"good\",{\"1\":{\"68\":1}}],[\"garbage\",{\"1\":{\"52\":1}}],[\"g1可以调节停顿时间\",{\"1\":{\"62\":1}}],[\"g1垃圾回收器天生适合这种大jvm内存的场景\",{\"1\":{\"60\":1}}],[\"g1垃圾收集分类\",{\"0\":{\"53\":1}}],[\"g1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样\",{\"1\":{\"52\":1}}],[\"g1垃圾收集器\",{\"0\":{\"52\":1}}],[\"g1heapwastepercent\",{\"1\":{\"57\":1}}],[\"g1heapregionsize\",{\"1\":{\"57\":1}}],[\"g1heapregionsize​手动指定region大小\",{\"1\":{\"52\":1}}],[\"g1mixedgccounttarget\",{\"1\":{\"57\":1}}],[\"g1mixedgclivethresholdpercent\",{\"1\":{\"57\":1}}],[\"g1maxnewsizepercent\",{\"1\":{\"57\":1}}],[\"g1maxnewsizepercent​调整\",{\"1\":{\"52\":1}}],[\"g1newsizepercent\",{\"1\":{\"57\":1}}],[\"g1newsizepercent设置新生代初始占比\",{\"1\":{\"52\":1}}],[\"g1计算回收时间接近参数\",{\"1\":{\"54\":1}}],[\"g1会计算下现在eden区回收大概要多久时间\",{\"1\":{\"54\":1}}],[\"g1从整体来看是基于\",{\"1\":{\"52\":1}}],[\"g1能充分利用cpu\",{\"1\":{\"52\":1}}],[\"g1被视为jdk1\",{\"1\":{\"52\":1}}],[\"g1在处理多标和漏标的方式为\",{\"1\":{\"52\":1}}],[\"g1当然会优先选择后面这个region回收\",{\"1\":{\"52\":1}}],[\"g1收集器仍然可以通过并发的方式让java程序继续执行\",{\"1\":{\"52\":1}}],[\"g1收集器在后台维护了一个优先列表\",{\"1\":{\"52\":1}}],[\"g1收集器一次gc\",{\"1\":{\"52\":1}}],[\"g1因为内部实现太复杂暂时没实现并发回收\",{\"1\":{\"52\":1}}],[\"g1因为很多对象都位于不同的region\",{\"1\":{\"47\":1}}],[\"g1采用复制算法回收几乎不会有太多内存碎片\",{\"1\":{\"52\":1}}],[\"g1有专门分配大对象的region叫humongous区\",{\"1\":{\"52\":1}}],[\"g1保留了年轻代和老年代的概念\",{\"1\":{\"52\":1}}],[\"g1将java堆划分为多个大小相等的独立区域\",{\"1\":{\"52\":1}}],[\"g1\",{\"1\":{\"47\":1,\"52\":1,\"71\":1}}],[\"gc非常频繁\",{\"1\":{\"95\":1}}],[\"gc对jvm性能的影响\",{\"1\":{\"94\":1}}],[\"gc后的存活对象小于survivor区域的50\",{\"1\":{\"94\":1}}],[\"gc后进去老年代大概多少对象\",{\"1\":{\"92\":1}}],[\"gc后进入老年代对象的平均大小进行比较\",{\"1\":{\"24\":1}}],[\"gc后存活的对象\",{\"1\":{\"92\":1}}],[\"gc的每次耗时可以用公式\",{\"1\":{\"93\":1}}],[\"gc的触发频率了\",{\"1\":{\"93\":1}}],[\"gc的频率\",{\"1\":{\"92\":1,\"94\":1}}],[\"gc的执行而卡顿多久\",{\"1\":{\"91\":1}}],[\"gc的平均耗时可以通过\",{\"1\":{\"91\":1}}],[\"gc的时候除了收集年轻代和老年代之外\",{\"1\":{\"52\":1}}],[\"gc大概多久触发一次\",{\"1\":{\"91\":1}}],[\"gcpermcapacity\",{\"1\":{\"88\":1}}],[\"gcoldcapacity\",{\"1\":{\"88\":1}}],[\"gcold\",{\"1\":{\"88\":1}}],[\"gcnewcapacity\",{\"1\":{\"88\":1}}],[\"gcnew\",{\"1\":{\"88\":1}}],[\"gcutil\",{\"1\":{\"88\":2}}],[\"gccause\",{\"1\":{\"88\":1}}],[\"gccapacity\",{\"1\":{\"88\":1}}],[\"gc则可以有效降低这种情况下对堆大小\",{\"1\":{\"69\":1}}],[\"gc周期2\",{\"1\":{\"66\":1}}],[\"gc周期1\",{\"1\":{\"66\":1}}],[\"gc一样采用分代机制\",{\"1\":{\"63\":1}}],[\"gc一般都需要100ms以上\",{\"1\":{\"62\":1}}],[\"gc停顿时间在10ms左右\",{\"1\":{\"62\":1}}],[\"gc卡顿几秒钟没法处理新消息\",{\"1\":{\"60\":1}}],[\"gc是很快的\",{\"1\":{\"60\":1}}],[\"gc过程中空出来的region是否充足阈值\",{\"1\":{\"57\":1}}],[\"gc反而降低性能\",{\"1\":{\"52\":1}}],[\"gcroot\",{\"1\":{\"42\":1}}],[\"gc就干掉了很多对垃圾对象\",{\"1\":{\"40\":1}}],[\"gc标记阶段\",{\"1\":{\"40\":1}}],[\"gc前启动一次minor\",{\"1\":{\"40\":1}}],[\"gc会直接回收掉\",{\"1\":{\"27\":1}}],[\"gc之后需要存放到老年代的对象大小仍然超过了老年代剩余可用空间大小\",{\"1\":{\"24\":1}}],[\"gc之后触发的\",{\"1\":{\"23\":1}}],[\"gc时\",{\"1\":{\"24\":1,\"48\":1}}],[\"gc分代年龄\",{\"1\":{\"18\":1}}],[\"gc\",{\"1\":{\"11\":1,\"21\":1,\"22\":2,\"24\":2,\"25\":1,\"26\":2,\"39\":2,\"40\":1,\"48\":1,\"52\":1,\"54\":2,\"58\":1,\"61\":1,\"69\":1,\"88\":1,\"89\":1,\"90\":1,\"92\":1,\"95\":1}}],[\"gc进行类型卸载\",{\"1\":{\"0\":1}}],[\"fsync\",{\"1\":{\"205\":1}}],[\"flush\",{\"1\":{\"205\":5}}],[\"flags\",{\"0\":{\"86\":1}}],[\"female\",{\"1\":{\"139\":3}}],[\"few\",{\"1\":{\"129\":1}}],[\"false\",{\"1\":{\"129\":10}}],[\"failure\",{\"1\":{\"39\":1}}],[\"fro\",{\"1\":{\"198\":1}}],[\"from\",{\"1\":{\"98\":1,\"100\":1,\"123\":1,\"124\":3,\"125\":1,\"126\":4,\"127\":3,\"129\":8,\"139\":1,\"142\":1,\"144\":1,\"145\":2,\"146\":3,\"148\":1,\"149\":1,\"151\":3,\"152\":10,\"153\":4,\"167\":2,\"182\":5,\"183\":4,\"197\":1,\"198\":2,\"200\":1,\"231\":1,\"232\":1}}],[\"frm\",{\"1\":{\"110\":1,\"112\":1}}],[\"freqinlinesize=size\",{\"1\":{\"8\":1}}],[\"fgc\",{\"1\":{\"93\":1}}],[\"fgct\",{\"1\":{\"93\":1}}],[\"fulltext\",{\"1\":{\"226\":1}}],[\"fullgc\",{\"0\":{\"56\":1}}],[\"fullgc之后做压缩整理\",{\"1\":{\"40\":1}}],[\"full\",{\"1\":{\"52\":1,\"61\":1,\"93\":1}}],[\"file\",{\"1\":{\"204\":3}}],[\"files\",{\"1\":{\"204\":3}}],[\"filesort文件排序方式\",{\"0\":{\"238\":1}}],[\"filesort文件排序原理\",{\"0\":{\"237\":1}}],[\"filesort\",{\"1\":{\"131\":7,\"146\":1}}],[\"file=dump\",{\"1\":{\"81\":1}}],[\"filtering\",{\"1\":{\"129\":1}}],[\"final\",{\"1\":{\"84\":1}}],[\"finalizable标识\",{\"1\":{\"66\":1}}],[\"finalize\",{\"1\":{\"28\":1}}],[\"finalize方法是对象脱逃死亡命运的最后一次机会\",{\"1\":{\"28\":1}}],[\"first的由来\",{\"1\":{\"52\":1}}],[\"first\",{\"1\":{\"52\":1}}],[\"fields\",{\"1\":{\"238\":2}}],[\"fieldb不是对象引用\",{\"1\":{\"68\":1}}],[\"fielda也是一个对象时才会加上读屏障\",{\"1\":{\"68\":1}}],[\"fielda并赋给引用o\",{\"1\":{\"68\":1}}],[\"field\",{\"1\":{\"44\":9,\"45\":2,\"47\":6}}],[\"found\",{\"1\":{\"242\":1}}],[\"foo\",{\"1\":{\"8\":2}}],[\"form\",{\"1\":{\"209\":1}}],[\"format\",{\"1\":{\"206\":1}}],[\"format=b\",{\"1\":{\"81\":1}}],[\"force\",{\"1\":{\"124\":2}}],[\"forward\",{\"1\":{\"65\":1}}],[\"for\",{\"1\":{\"8\":2,\"12\":2,\"65\":1,\"129\":6,\"152\":2,\"167\":1,\"183\":4,\"196\":1,\"238\":3,\"240\":3}}],[\"设计原因\",{\"0\":{\"191\":1,\"203\":1}}],[\"设计索引后可以减少回表的操作\",{\"1\":{\"139\":1}}],[\"设置innodb\",{\"1\":{\"205\":1}}],[\"设置单个\",{\"1\":{\"204\":1}}],[\"设置\",{\"1\":{\"204\":3}}],[\"设置隔离级别为读未提交\",{\"1\":{\"173\":2}}],[\"设置数据库事务隔离级别的语句\",{\"1\":{\"172\":1}}],[\"设置jvm参数即可\",{\"1\":{\"69\":1}}],[\"设置的值很大\",{\"1\":{\"58\":1}}],[\"设置不同的期望停顿时间\",{\"1\":{\"52\":1}}],[\"设置对象头\",{\"0\":{\"18\":1}}],[\"设置堆的最大可用大小\",{\"1\":{\"0\":1}}],[\"设置堆的初始可用大小\",{\"1\":{\"0\":1}}],[\"设定的值\",{\"1\":{\"54\":2}}],[\"设定要进行内联的琐碎方法的最大字节数\",{\"1\":{\"8\":1}}],[\"设定热点方法进行内联的最大字节数\",{\"1\":{\"8\":1}}],[\"设定内联方法的最大字节数\",{\"1\":{\"8\":1}}],[\"启动时\",{\"1\":{\"202\":1}}],[\"启动快\",{\"1\":{\"7\":1}}],[\"启用binlog会影响服务器性能\",{\"1\":{\"206\":1}}],[\"启用zgc比较简单\",{\"1\":{\"69\":1}}],[\"启用cms\",{\"1\":{\"40\":1}}],[\"启用方法内联\",{\"1\":{\"8\":1}}],[\"提高索引效率\",{\"1\":{\"232\":1}}],[\"提高用户体验\",{\"1\":{\"37\":1}}],[\"提供的客户端\",{\"1\":{\"196\":1}}],[\"提供多个跟inline内联相关参数\",{\"1\":{\"8\":1}}],[\"提前编译出来放到缓存当中\",{\"1\":{\"5\":1}}],[\"的值\",{\"1\":{\"240\":1}}],[\"的值回到原表中取出所有字段的值返回给客户端\",{\"1\":{\"240\":1}}],[\"的主键id\",{\"1\":{\"240\":1}}],[\"的主键和非主键索引存储都是一样的\",{\"1\":{\"116\":1}}],[\"的大小和需要查询的字段总大小来判断使用哪种排序模式\",{\"1\":{\"238\":1}}],[\"的大字段可能会比较占用磁盘空间\",{\"1\":{\"136\":1}}],[\"的优化措施\",{\"1\":{\"228\":1}}],[\"的写入策略\",{\"1\":{\"205\":1}}],[\"的磁盘\",{\"1\":{\"202\":1}}],[\"的报错\",{\"1\":{\"198\":1}}],[\"的语法\",{\"1\":{\"198\":1}}],[\"的结果\",{\"1\":{\"197\":1}}],[\"的结果会以\",{\"1\":{\"197\":1}}],[\"的客户端发起链接请求时\",{\"1\":{\"196\":1}}],[\"的整个区间可以叫做临键锁\",{\"1\":{\"178\":1}}],[\"的执行空间\",{\"1\":{\"164\":1}}],[\"的执行结果\",{\"1\":{\"129\":1}}],[\"的using\",{\"1\":{\"149\":1}}],[\"的概念\",{\"1\":{\"127\":1}}],[\"的非主键索引和主键索引是不同的\",{\"1\":{\"116\":1}}],[\"的时间\",{\"1\":{\"107\":1}}],[\"的时候\",{\"1\":{\"100\":1,\"103\":1,\"107\":1,\"199\":1}}],[\"的存储容量\",{\"1\":{\"107\":1}}],[\"的记录\",{\"1\":{\"105\":1}}],[\"的次数\",{\"1\":{\"102\":1}}],[\"的问题\",{\"1\":{\"101\":1}}],[\"的叶子节点上保存的是全行数据\",{\"1\":{\"127\":1}}],[\"的叶子节点数据\",{\"1\":{\"105\":1}}],[\"的叶子节点\",{\"1\":{\"101\":1}}],[\"的效率要优于\",{\"1\":{\"99\":1}}],[\"的数据默认都存储在\",{\"1\":{\"109\":1}}],[\"的数据\",{\"1\":{\"98\":1,\"107\":1,\"111\":1}}],[\"的数据结构\",{\"1\":{\"48\":1}}],[\"的需求\",{\"1\":{\"69\":1}}],[\"的话会跟不上\",{\"1\":{\"69\":1}}],[\"的开销\",{\"1\":{\"68\":1}}],[\"的假设\",{\"1\":{\"63\":1}}],[\"的运作过程大致分为以下几个步骤\",{\"1\":{\"52\":1}}],[\"的方式实现记忆集\",{\"1\":{\"48\":1}}],[\"的指针集合\",{\"1\":{\"48\":1}}],[\"的垃圾回收器几乎都借鉴了三色标记的算法思想\",{\"1\":{\"47\":1}}],[\"的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作\",{\"1\":{\"36\":1}}],[\"的集合\",{\"1\":{\"28\":1}}],[\"的\",{\"1\":{\"28\":1,\"107\":1}}],[\"的参数是否设置\",{\"1\":{\"24\":1}}],[\"的代码复制到test\",{\"1\":{\"8\":1}}],[\"的情况下\",{\"1\":{\"0\":1}}],[\"是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行\",{\"1\":{\"238\":1}}],[\"是一次性取出满足条件行的所有字段\",{\"1\":{\"238\":1}}],[\"是一款面向服务器的垃圾收集器\",{\"1\":{\"52\":1}}],[\"是什么\",{\"1\":{\"198\":1}}],[\"是执行的\",{\"1\":{\"197\":1}}],[\"是所有数据库需要解决的一个问题\",{\"1\":{\"166\":1}}],[\"是例外\",{\"1\":{\"155\":1}}],[\"是建完表马上就建立索引吗\",{\"1\":{\"133\":1}}],[\"是根据联合字段进行综合排序的\",{\"1\":{\"118\":1}}],[\"是索引\",{\"1\":{\"111\":1}}],[\"是常驻内存的\",{\"1\":{\"107\":1}}],[\"是将放到内存的\",{\"1\":{\"107\":1}}],[\"是经过计算得到的较优的数据大小\",{\"1\":{\"107\":1}}],[\"是\",{\"1\":{\"107\":1}}],[\"是指为空\",{\"1\":{\"101\":1}}],[\"是黑色\",{\"1\":{\"101\":1}}],[\"是因为实现复杂度还是另有考虑\",{\"1\":{\"63\":1}}],[\"是否选择该索引\",{\"1\":{\"129\":1}}],[\"是否使用覆盖索引\",{\"1\":{\"129\":1}}],[\"是否访问过\",{\"1\":{\"41\":1}}],[\"是否需要即时编译\",{\"1\":{\"6\":1}}],[\"是两个单独的方法但是当出现方法内联\",{\"1\":{\"8\":1}}],[\"length\",{\"1\":{\"238\":3,\"240\":3}}],[\"len=74\",{\"1\":{\"131\":1}}],[\"len=74也能看出\",{\"1\":{\"131\":1}}],[\"left\",{\"1\":{\"151\":1,\"232\":13}}],[\"legacy\",{\"1\":{\"61\":1}}],[\"lucy\",{\"1\":{\"121\":1,\"126\":2}}],[\"linux\",{\"1\":{\"206\":1}}],[\"limit\",{\"0\":{\"142\":1},\"1\":{\"139\":2,\"142\":2,\"144\":1,\"145\":2,\"146\":2}}],[\"lilei\",{\"1\":{\"121\":1,\"123\":1,\"124\":3,\"125\":1,\"126\":4,\"127\":5}}],[\"like\",{\"0\":{\"127\":1},\"1\":{\"107\":1,\"127\":4,\"128\":2,\"158\":1,\"172\":1,\"181\":1,\"197\":1,\"204\":4,\"205\":1,\"206\":1}}],[\"live\",{\"1\":{\"79\":1}}],[\"list\",{\"1\":{\"28\":3}}],[\"list<object>\",{\"1\":{\"28\":1}}],[\"latest\",{\"1\":{\"139\":5}}],[\"large\",{\"1\":{\"64\":1}}],[\"lang\",{\"1\":{\"29\":1,\"83\":1}}],[\"loop\",{\"0\":{\"148\":1,\"149\":1},\"1\":{\"149\":1}}],[\"logs\",{\"1\":{\"206\":1}}],[\"logfile1\",{\"1\":{\"204\":1}}],[\"logfile0\",{\"1\":{\"204\":2}}],[\"log来实现\",{\"1\":{\"164\":1}}],[\"login\",{\"1\":{\"139\":5}}],[\"log\",{\"0\":{\"204\":1,\"205\":1},\"1\":{\"107\":1,\"202\":2,\"204\":16,\"205\":12,\"206\":3}}],[\"load\",{\"1\":{\"47\":3,\"68\":1,\"107\":1}}],[\"local\",{\"1\":{\"16\":1,\"69\":1}}],[\"lock状态变量来分析系统上的行锁的争夺情况\",{\"0\":{\"181\":1}}],[\"locks\",{\"0\":{\"178\":1},\"1\":{\"182\":2}}],[\"lock2\",{\"1\":{\"83\":3}}],[\"lock1\",{\"1\":{\"83\":3}}],[\"lockelisiondemo\",{\"1\":{\"12\":1}}],[\"lock\",{\"0\":{\"12\":1},\"1\":{\"167\":1,\"168\":1,\"181\":6,\"182\":2}}],[\"long\",{\"1\":{\"8\":1,\"10\":1,\"12\":2}}],[\"l\",{\"1\":{\"8\":2}}],[\"nbinlog\",{\"1\":{\"206\":1}}],[\"n\",{\"1\":{\"178\":1}}],[\"nlj\",{\"0\":{\"148\":1},\"1\":{\"151\":1}}],[\"no\",{\"1\":{\"231\":1}}],[\"now\",{\"1\":{\"121\":3}}],[\"note\",{\"1\":{\"232\":15}}],[\"not\",{\"1\":{\"121\":5,\"129\":2,\"242\":1}}],[\"node\",{\"1\":{\"107\":1}}],[\"n​ame\",{\"1\":{\"118\":1}}],[\"nil\",{\"1\":{\"101\":2}}],[\"nid=0x2d64\",{\"1\":{\"83\":1}}],[\"name>\",{\"1\":{\"129\":2}}],[\"name\",{\"1\":{\"79\":1,\"117\":1,\"118\":1,\"121\":5,\"123\":1,\"124\":5,\"125\":2,\"126\":6,\"127\":4,\"129\":10,\"136\":2,\"146\":2,\"153\":1,\"177\":1,\"210\":3,\"233\":3,\"239\":3,\"240\":5}}],[\"next\",{\"0\":{\"178\":1}}],[\"nested\",{\"0\":{\"148\":1,\"149\":1},\"1\":{\"149\":1}}],[\"net\",{\"1\":{\"61\":2}}],[\"new\",{\"1\":{\"8\":1,\"9\":2,\"12\":2,\"25\":2,\"27\":5,\"28\":3,\"41\":4,\"44\":5,\"83\":4,\"84\":2,\"129\":1}}],[\"newratio\",{\"1\":{\"0\":1}}],[\"num\",{\"1\":{\"79\":1}}],[\"number\",{\"1\":{\"52\":1}}],[\"null禁止排序\",{\"1\":{\"131\":1}}],[\"null\",{\"1\":{\"8\":1,\"41\":2,\"44\":1,\"45\":1,\"101\":1,\"121\":5,\"129\":1}}],[\"tcp\",{\"1\":{\"196\":1}}],[\"tx\",{\"1\":{\"172\":2}}],[\"t2小表为驱动表\",{\"1\":{\"148\":1}}],[\"t2\",{\"1\":{\"148\":1,\"149\":1,\"151\":3}}],[\"t2表做全表扫描\",{\"1\":{\"150\":1}}],[\"t2表\",{\"1\":{\"148\":1}}],[\"t1表100行\",{\"1\":{\"148\":1}}],[\"t1\",{\"1\":{\"148\":2,\"149\":2,\"151\":8,\"153\":4}}],[\"tmp\",{\"1\":{\"129\":1}}],[\"type=2\",{\"1\":{\"197\":1}}],[\"type=0\",{\"1\":{\"124\":1}}],[\"type有3个值\",{\"1\":{\"197\":1}}],[\"type\",{\"1\":{\"129\":1,\"197\":2}}],[\"total\",{\"1\":{\"232\":1}}],[\"to\",{\"1\":{\"129\":3}}],[\"too\",{\"1\":{\"129\":1}}],[\"tostring\",{\"1\":{\"12\":2,\"28\":2}}],[\"tuling\",{\"1\":{\"84\":1}}],[\"tid=0x000000001fa9e000\",{\"1\":{\"83\":1}}],[\"time>\",{\"1\":{\"145\":2}}],[\"time>=\",{\"1\":{\"139\":1}}],[\"timestamp\",{\"1\":{\"121\":2}}],[\"time`\",{\"1\":{\"121\":1,\"129\":2}}],[\"time\",{\"1\":{\"69\":1,\"121\":3,\"139\":2,\"181\":3}}],[\"tieredstopatlevel=1可以指定使用那一层编译器\",{\"1\":{\"7\":1}}],[\"tty\",{\"1\":{\"69\":1}}],[\"tb级别的堆内存支持\",{\"1\":{\"62\":1}}],[\"targetsurvivorratio\",{\"1\":{\"57\":1}}],[\"targetsurvivorratio可以指定\",{\"1\":{\"23\":1}}],[\"tablename\",{\"1\":{\"158\":1}}],[\"tables\",{\"1\":{\"129\":2,\"168\":1}}],[\"table\",{\"1\":{\"48\":1,\"65\":1,\"121\":1,\"129\":11,\"158\":1,\"168\":1,\"201\":1,\"232\":1}}],[\"the\",{\"1\":{\"36\":2,\"39\":1,\"43\":1,\"52\":1}}],[\"this\",{\"1\":{\"28\":1}}],[\"threecolorremark\",{\"1\":{\"41\":1}}],[\"thread2\",{\"1\":{\"83\":2}}],[\"thread1\",{\"1\":{\"83\":2}}],[\"thread\",{\"1\":{\"16\":1,\"83\":7,\"182\":2}}],[\"throwable\",{\"1\":{\"28\":1}}],[\"throws\",{\"1\":{\"28\":1}}],[\"trx表里查看到\",{\"1\":{\"182\":1}}],[\"trx\",{\"1\":{\"182\":3,\"188\":2,\"189\":7,\"205\":5}}],[\"transformation\",{\"1\":{\"129\":3}}],[\"transaction并不是一个事务的起点\",{\"1\":{\"189\":1}}],[\"transaction\",{\"1\":{\"107\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1}}],[\"trace\",{\"1\":{\"129\":2}}],[\"trace=\",{\"1\":{\"129\":2}}],[\"tree\",{\"0\":{\"102\":1},\"1\":{\"107\":1}}],[\"try\",{\"1\":{\"83\":2}}],[\"true\",{\"1\":{\"28\":1,\"84\":1,\"129\":6}}],[\"trivial\",{\"1\":{\"8\":1,\"129\":1}}],[\"tlabsize来指定缓冲区大小\",{\"1\":{\"16\":1}}],[\"tlab\",{\"1\":{\"16\":1}}],[\"t\",{\"1\":{\"9\":9,\"88\":1,\"98\":1,\"100\":2,\"146\":2,\"200\":1}}],[\"test\",{\"1\":{\"25\":1,\"197\":1,\"200\":1}}],[\"test2\",{\"1\":{\"9\":1}}],[\"test1方法内的t对象就没有被方法外部引用\",{\"1\":{\"9\":1}}],[\"test1\",{\"1\":{\"9\":1}}],[\"testinline\",{\"1\":{\"8\":2}}],[\"o读取带来的消耗\",{\"1\":{\"230\":1}}],[\"o会不定时将bufferpool中数据刷入磁盘相应数据\",{\"1\":{\"190\":1}}],[\"only\",{\"1\":{\"129\":1}}],[\"on\",{\"1\":{\"129\":2,\"146\":1,\"148\":1,\"149\":1,\"151\":3}}],[\"open\",{\"1\":{\"168\":1}}],[\"openjdk\",{\"1\":{\"7\":1,\"61\":2}}],[\"optimization\",{\"1\":{\"129\":2}}],[\"optimizer\",{\"1\":{\"129\":6}}],[\"o\",{\"1\":{\"68\":1,\"69\":1,\"166\":1,\"202\":1}}],[\"o这行代码并没有从堆中读取数据\",{\"1\":{\"68\":1}}],[\"original\",{\"1\":{\"129\":3}}],[\"ordering\",{\"1\":{\"129\":2}}],[\"ordered\",{\"1\":{\"129\":1}}],[\"order\",{\"0\":{\"131\":1},\"1\":{\"129\":9,\"131\":2,\"134\":1,\"139\":2,\"146\":2,\"231\":2,\"232\":17,\"233\":2}}],[\"or\",{\"1\":{\"126\":2,\"129\":1}}],[\"oracle官方提到了它最大的优点是\",{\"1\":{\"62\":1}}],[\"org\",{\"1\":{\"61\":1}}],[\"oop\",{\"1\":{\"44\":6,\"45\":2,\"47\":5}}],[\"oomtest\",{\"1\":{\"28\":2}}],[\"old垃圾收集器来回收\",{\"1\":{\"39\":1}}],[\"old\",{\"1\":{\"36\":1,\"37\":2,\"45\":2,\"47\":2}}],[\"override\",{\"1\":{\"28\":1}}],[\"out\",{\"1\":{\"8\":2,\"12\":2,\"28\":1,\"83\":5}}],[\"objb\",{\"1\":{\"25\":1}}],[\"obj=\",{\"1\":{\"8\":1}}],[\"obj\",{\"1\":{\"8\":5,\"68\":1}}],[\"object\",{\"1\":{\"8\":2,\"68\":1,\"83\":4}}],[\"实现更好的业务体验\",{\"1\":{\"223\":1}}],[\"实时维护数据和定期重建\",{\"1\":{\"222\":1}}],[\"实时编译\",{\"1\":{\"8\":1}}],[\"实例是否开启缓存\",{\"1\":{\"197\":1}}],[\"实例数量\",{\"1\":{\"79\":1}}],[\"实例数据\",{\"1\":{\"18\":1}}],[\"实例个数及占用内存大小\",{\"1\":{\"78\":1}}],[\"实际工作中的反范式化\",{\"0\":{\"221\":1}}],[\"实际可以超过该值\",{\"1\":{\"52\":1}}],[\"实际上\",{\"1\":{\"8\":1}}],[\"<18\",{\"1\":{\"177\":1}}],[\"<\",{\"1\":{\"8\":2,\"12\":2,\"129\":1,\"189\":1}}],[\"iblogfilen\",{\"1\":{\"204\":1}}],[\"iblogfile1\",{\"1\":{\"204\":1}}],[\"ib\",{\"1\":{\"204\":3}}],[\"ibd\",{\"1\":{\"112\":1,\"113\":1,\"114\":1}}],[\"ip\",{\"1\":{\"196\":1}}],[\"item\",{\"1\":{\"129\":1}}],[\"items\",{\"1\":{\"129\":2}}],[\"icp\",{\"1\":{\"127\":1}}],[\"i=i+1\",{\"1\":{\"121\":1}}],[\"i=1\",{\"1\":{\"121\":1}}],[\"i<=100000\",{\"1\":{\"121\":1}}],[\"io\",{\"1\":{\"98\":4,\"99\":2,\"102\":2,\"107\":5}}],[\"isolaticton=\",{\"1\":{\"172\":1}}],[\"isolation=\",{\"1\":{\"173\":1,\"174\":1,\"175\":1,\"176\":1}}],[\"isolation\",{\"1\":{\"172\":2}}],[\"is\",{\"1\":{\"79\":5,\"129\":1,\"139\":1}}],[\"id是数据库服务器id\",{\"1\":{\"206\":1}}],[\"id不在read\",{\"1\":{\"189\":1}}],[\"id和当前事务id一致时\",{\"1\":{\"189\":1}}],[\"id和roll\",{\"1\":{\"188\":1}}],[\"id在read\",{\"1\":{\"189\":1}}],[\"ids时\",{\"1\":{\"189\":2}}],[\"ids\",{\"1\":{\"188\":2,\"189\":2}}],[\"id可以从innodb\",{\"1\":{\"182\":1}}],[\"id=10\",{\"1\":{\"200\":1}}],[\"id=1\",{\"1\":{\"197\":1,\"206\":1}}],[\"id=a\",{\"1\":{\"152\":3}}],[\"id=b\",{\"1\":{\"152\":1}}],[\"id=e\",{\"1\":{\"146\":1}}],[\"idx\",{\"1\":{\"124\":2,\"129\":2}}],[\"idea\",{\"1\":{\"81\":1}}],[\"idea中通过view\",{\"1\":{\"81\":1}}],[\"idea分析堆文件\",{\"1\":{\"81\":1}}],[\"id\",{\"1\":{\"28\":1,\"114\":1,\"129\":1,\"144\":1,\"146\":2,\"152\":7,\"153\":1,\"177\":2,\"182\":1,\"189\":4,\"210\":2,\"211\":1,\"212\":1,\"238\":1,\"239\":3,\"240\":6}}],[\"if条件永远为false\",{\"1\":{\"8\":1}}],[\"if\",{\"1\":{\"8\":1,\"121\":1}}],[\"i++\",{\"1\":{\"8\":2,\"12\":2,\"28\":1}}],[\"i\",{\"1\":{\"8\":4,\"12\":4,\"28\":1,\"79\":2,\"121\":3,\"166\":1,\"202\":1}}],[\"ini\",{\"1\":{\"206\":1}}],[\"ini或my\",{\"1\":{\"205\":1}}],[\"initdata\",{\"1\":{\"84\":1}}],[\"initiatingheapoccupancypercent\",{\"1\":{\"57\":1}}],[\"initiatingheapoccupancypercent​设置的值时则触发\",{\"1\":{\"55\":1}}],[\"init\",{\"1\":{\"52\":1}}],[\"info\",{\"1\":{\"198\":1}}],[\"information\",{\"1\":{\"129\":2,\"182\":3}}],[\"in优先exists\",{\"1\":{\"152\":1}}],[\"in和exists\",{\"0\":{\"152\":1}}],[\"in和or在表数据量比较大的情况会走索引\",{\"0\":{\"126\":1}}],[\"inner\",{\"1\":{\"146\":1,\"148\":1,\"149\":1,\"151\":3}}],[\"innodb原理与mysql日志机制\",{\"0\":{\"193\":1}}],[\"innodb的行级锁定同样也有其脆弱的一面\",{\"1\":{\"179\":1}}],[\"innodb的行锁是针对索引加的锁\",{\"1\":{\"178\":1}}],[\"innodb的整体性能和myisam相比就会有比较明显的优势了\",{\"1\":{\"179\":1}}],[\"innodb的主键索引\",{\"1\":{\"127\":1}}],[\"innodb支持事务及行级锁\",{\"1\":{\"171\":1}}],[\"innodb\",{\"0\":{\"112\":1,\"113\":1,\"114\":1,\"202\":1},\"1\":{\"107\":4,\"109\":1,\"112\":1,\"113\":2,\"114\":1,\"116\":2,\"181\":6,\"182\":4,\"194\":1,\"201\":3,\"204\":7,\"205\":3}}],[\"in\",{\"1\":{\"126\":2,\"129\":1,\"139\":5,\"152\":1,\"167\":1,\"198\":1,\"204\":3}}],[\"index效率高\",{\"1\":{\"131\":1}}],[\"index是指mysql扫描索引本身完成排序\",{\"1\":{\"131\":1}}],[\"indexes\",{\"1\":{\"129\":2}}],[\"index\",{\"1\":{\"124\":2,\"127\":1,\"129\":13,\"131\":2,\"136\":1}}],[\"insert\",{\"1\":{\"121\":7,\"209\":1}}],[\"instances\",{\"1\":{\"79\":1}}],[\"instance\",{\"1\":{\"18\":1}}],[\"increment=1\",{\"1\":{\"121\":1}}],[\"increment\",{\"1\":{\"121\":1}}],[\"incremental\",{\"1\":{\"43\":1}}],[\"intersect\",{\"1\":{\"129\":2}}],[\"interruptedexception\",{\"1\":{\"83\":2}}],[\"into\",{\"1\":{\"121\":4}}],[\"int\",{\"1\":{\"8\":16,\"12\":2,\"28\":2,\"79\":2,\"84\":5,\"107\":1,\"121\":3,\"230\":1}}],[\"inlinesmallcode=size\",{\"1\":{\"8\":1}}],[\"inlinedemo\",{\"1\":{\"8\":1}}],[\"inline\",{\"0\":{\"8\":1},\"1\":{\"8\":1}}],[\"次就能查询到数据\",{\"1\":{\"98\":1}}],[\"次才能找到\",{\"1\":{\"98\":1}}],[\"次\",{\"1\":{\"8\":1,\"100\":1}}],[\"超过则触发\",{\"1\":{\"70\":1}}],[\"超过1秒\",{\"1\":{\"59\":1}}],[\"超过方法调用计数器的阈值\",{\"1\":{\"8\":1}}],[\"超过了设定的某一个阈值\",{\"1\":{\"6\":1}}],[\"=6\",{\"1\":{\"100\":1}}],[\"=null\",{\"1\":{\"8\":1}}],[\"=\",{\"1\":{\"8\":4,\"9\":2,\"12\":6,\"25\":4,\"27\":3,\"28\":3,\"41\":8,\"44\":2,\"45\":2,\"46\":1,\"47\":2,\"68\":1,\"83\":2,\"84\":6,\"98\":1,\"107\":2,\"123\":2,\"124\":2,\"125\":2,\"126\":12,\"127\":6,\"139\":1,\"177\":1,\"206\":3,\"239\":3,\"240\":3}}],[\"actor\",{\"1\":{\"183\":2}}],[\"account\",{\"1\":{\"177\":1,\"183\":2}}],[\"access\",{\"1\":{\"129\":7,\"196\":1}}],[\"avg\",{\"1\":{\"181\":1}}],[\"a的数据\",{\"1\":{\"152\":1}}],[\"a和b表连接字段需要添加索引\",{\"1\":{\"152\":1}}],[\"a<80\",{\"1\":{\"151\":1}}],[\"a<10\",{\"1\":{\"151\":1}}],[\"a=t2\",{\"1\":{\"148\":1,\"151\":2}}],[\"alter\",{\"1\":{\"232\":1}}],[\"alternatives\",{\"1\":{\"129\":4}}],[\"allocation\",{\"1\":{\"69\":1}}],[\"allcation\",{\"1\":{\"16\":1}}],[\"applicable\",{\"1\":{\"129\":1}}],[\"append\",{\"1\":{\"12\":4}}],[\"as\",{\"1\":{\"129\":5,\"232\":14}}],[\"an\",{\"1\":{\"198\":1}}],[\"analyzing\",{\"1\":{\"129\":4}}],[\"analysis\",{\"0\":{\"9\":1},\"1\":{\"129\":2}}],[\"and\",{\"1\":{\"123\":2,\"124\":2,\"125\":2,\"126\":8,\"127\":6,\"139\":13,\"177\":1}}],[\"auto\",{\"1\":{\"121\":2}}],[\"azul\",{\"1\":{\"61\":1}}],[\"attached\",{\"1\":{\"129\":5}}],[\"attaching\",{\"1\":{\"129\":2}}],[\"at\",{\"1\":{\"43\":1,\"205\":5}}],[\"arraylist<>\",{\"1\":{\"28\":1}}],[\"args\",{\"1\":{\"8\":2,\"12\":1,\"28\":1,\"41\":1,\"83\":1,\"84\":1}}],[\"a\",{\"0\":{\"117\":1},\"1\":{\"25\":10,\"41\":7,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"79\":5,\"84\":3,\"129\":12,\"148\":2,\"151\":2,\"152\":5,\"183\":2}}],[\"age不符合第一范式\",{\"1\":{\"210\":1}}],[\"age<=xx\",{\"1\":{\"139\":3}}],[\"age>=xx\",{\"1\":{\"139\":3}}],[\"age和position用于排序\",{\"1\":{\"131\":1}}],[\"age索引列用在排序过程中\",{\"1\":{\"131\":1}}],[\"age\",{\"1\":{\"22\":1,\"117\":1,\"118\":2,\"121\":5,\"123\":1,\"124\":3,\"125\":2,\"126\":4,\"127\":4,\"129\":4,\"131\":1,\"136\":1,\"139\":4,\"210\":2,\"233\":3}}],[\"aaaaa\",{\"1\":{\"12\":2}}],[\"additional\",{\"1\":{\"238\":2}}],[\"add\",{\"1\":{\"8\":1,\"28\":2,\"45\":1,\"47\":1,\"232\":1}}],[\"add2\",{\"1\":{\"8\":3}}],[\"add1\",{\"1\":{\"8\":2}}],[\"view中最小的事务id还小\",{\"1\":{\"189\":1}}],[\"view比较\",{\"1\":{\"189\":1}}],[\"view做比较\",{\"1\":{\"188\":1}}],[\"view由生成时仍在活跃的事务id\",{\"1\":{\"188\":1}}],[\"view\",{\"1\":{\"188\":2}}],[\"variables\",{\"1\":{\"172\":1,\"197\":1,\"204\":4,\"205\":1,\"206\":1}}],[\"varchar\",{\"1\":{\"121\":2}}],[\"values\",{\"1\":{\"121\":4}}],[\"value\",{\"1\":{\"44\":6,\"45\":2,\"47\":2,\"98\":1,\"197\":2}}],[\"vsz\",{\"1\":{\"69\":1}}],[\"vmid\",{\"1\":{\"88\":1}}],[\"vm里的实现还是有三个非常短暂的safepoint\",{\"1\":{\"61\":1}}],[\"vm为例\",{\"1\":{\"47\":1}}],[\"veiw的活跃事务数组中时\",{\"1\":{\"189\":2}}],[\"veiw视图中\",{\"1\":{\"189\":1}}],[\"veiw时最大的事务id还大\",{\"1\":{\"189\":1}}],[\"veiw机制\",{\"0\":{\"188\":1}}],[\"version\",{\"1\":{\"187\":1}}],[\"version就可以看到当前使用的是那种模式\",{\"1\":{\"5\":1}}],[\"vee05\",{\"1\":{\"61\":1}}],[\"void\",{\"1\":{\"8\":4,\"9\":2,\"12\":1,\"25\":1,\"28\":2,\"41\":1,\"44\":2,\"45\":1,\"47\":1,\"83\":1,\"84\":1}}],[\"simple\",{\"1\":{\"129\":1}}],[\"size​\",{\"1\":{\"204\":2}}],[\"size参数进行设置\",{\"1\":{\"150\":1}}],[\"size=0\",{\"1\":{\"124\":1}}],[\"size\",{\"1\":{\"107\":1,\"204\":3,\"206\":1}}],[\"summary\",{\"1\":{\"129\":4}}],[\"substitute\",{\"1\":{\"129\":2}}],[\"survivor和老年代都有可能增长\",{\"1\":{\"92\":1}}],[\"survivor和老年代使用的变化情况\",{\"1\":{\"92\":1}}],[\"survivor区域里的一批对象\",{\"1\":{\"57\":1}}],[\"survivor区的填充容量\",{\"1\":{\"57\":1}}],[\"survivor\",{\"1\":{\"22\":3}}],[\"survivorratio\",{\"1\":{\"0\":1}}],[\"score\",{\"1\":{\"139\":2}}],[\"scans\",{\"1\":{\"129\":1}}],[\"scan\",{\"1\":{\"129\":6}}],[\"scavenge\",{\"1\":{\"36\":1,\"37\":4}}],[\"schema`\",{\"1\":{\"182\":2}}],[\"schema库中锁相关表\",{\"0\":{\"182\":1}}],[\"schema\",{\"1\":{\"129\":2,\"182\":3}}],[\"sql改写如下\",{\"1\":{\"146\":1}}],[\"sql执行阶段\",{\"1\":{\"129\":1}}],[\"sql优化阶段\",{\"1\":{\"129\":1}}],[\"sql准备阶段\",{\"1\":{\"129\":1}}],[\"sql\",{\"1\":{\"118\":2,\"197\":9,\"198\":7}}],[\"syntax\",{\"1\":{\"198\":1}}],[\"synchronized\",{\"1\":{\"83\":4}}],[\"sysprops\",{\"0\":{\"87\":1}}],[\"system\",{\"1\":{\"8\":4,\"12\":6,\"28\":1,\"83\":5,\"107\":2}}],[\"share\",{\"1\":{\"167\":1}}],[\"show\",{\"1\":{\"107\":1,\"158\":1,\"168\":1,\"172\":1,\"181\":1,\"182\":1,\"197\":1,\"204\":4,\"205\":1,\"206\":1}}],[\"short\",{\"1\":{\"79\":1}}],[\"shenandoah优化成多线程收集了\",{\"1\":{\"56\":1}}],[\"shenandoah可以看成是g1的升级版本\",{\"1\":{\"52\":1}}],[\"shenandoah就实现了并发收集\",{\"1\":{\"52\":1}}],[\"shenandoah\",{\"1\":{\"47\":1}}],[\"s\",{\"1\":{\"79\":1}}],[\"smem\",{\"1\":{\"69\":1}}],[\"small\",{\"1\":{\"64\":1}}],[\"slot\",{\"1\":{\"223\":2}}],[\"slow\",{\"1\":{\"68\":1}}],[\"slelect\",{\"1\":{\"167\":1}}],[\"sleep\",{\"1\":{\"83\":2}}],[\"slides\",{\"1\":{\"61\":1}}],[\"s0对应100个\",{\"1\":{\"52\":1}}],[\"safe\",{\"0\":{\"73\":1,\"74\":1},\"1\":{\"74\":3}}],[\"satb相对增量更新效率会高\",{\"1\":{\"47\":1}}],[\"satb\",{\"1\":{\"43\":1,\"47\":1}}],[\"savet\",{\"1\":{\"9\":1}}],[\"snapshot\",{\"1\":{\"43\":1}}],[\"sweepmulti\",{\"1\":{\"228\":1}}],[\"sweep\",{\"1\":{\"39\":2}}],[\"sex\",{\"1\":{\"139\":9,\"233\":3}}],[\"session\",{\"1\":{\"129\":2}}],[\"sel15\",{\"1\":{\"232\":1}}],[\"sel14\",{\"1\":{\"232\":1}}],[\"sel13\",{\"1\":{\"232\":1}}],[\"sel12\",{\"1\":{\"232\":1}}],[\"sel11\",{\"1\":{\"232\":1}}],[\"sel10\",{\"1\":{\"232\":1}}],[\"sel9\",{\"1\":{\"232\":1}}],[\"sel8\",{\"1\":{\"232\":1}}],[\"sel7\",{\"1\":{\"232\":1}}],[\"sel6\",{\"1\":{\"232\":1}}],[\"sel5\",{\"1\":{\"232\":1}}],[\"sel4\",{\"1\":{\"232\":1}}],[\"sel3\",{\"1\":{\"232\":1}}],[\"select\",{\"1\":{\"98\":1,\"100\":1,\"123\":1,\"124\":3,\"125\":1,\"126\":4,\"127\":3,\"129\":12,\"139\":1,\"142\":1,\"144\":1,\"145\":2,\"146\":3,\"148\":1,\"149\":1,\"151\":3,\"152\":9,\"153\":4,\"167\":1,\"182\":5,\"183\":4,\"197\":1,\"198\":2,\"200\":1,\"231\":1,\"232\":1}}],[\"self\",{\"1\":{\"65\":2}}],[\"setup\",{\"1\":{\"129\":2}}],[\"set\",{\"1\":{\"45\":1,\"47\":1,\"48\":1,\"52\":1,\"61\":1,\"65\":1,\"66\":1,\"121\":2,\"124\":2,\"129\":2,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"205\":1}}],[\"setage\",{\"1\":{\"9\":2}}],[\"service\",{\"0\":{\"195\":1},\"1\":{\"194\":2,\"197\":1}}],[\"server\",{\"1\":{\"38\":1,\"206\":2}}],[\"serializable\",{\"1\":{\"176\":1}}],[\"serial\",{\"1\":{\"36\":5,\"37\":2,\"38\":1}}],[\"sort\",{\"1\":{\"129\":1,\"238\":7,\"239\":2,\"240\":10}}],[\"softreference<user>\",{\"1\":{\"27\":2}}],[\"something\",{\"1\":{\"8\":1}}],[\"sb\",{\"1\":{\"12\":8}}],[\"s2\",{\"1\":{\"12\":4}}],[\"s1对应100个\",{\"1\":{\"52\":1}}],[\"s1\",{\"1\":{\"12\":4}}],[\"straight\",{\"1\":{\"151\":2}}],[\"stringbuilder耗时\",{\"1\":{\"12\":3}}],[\"stringbuilder\",{\"1\":{\"12\":2}}],[\"stringbuffer耗时\",{\"1\":{\"12\":3}}],[\"stringbuffer\",{\"1\":{\"12\":2}}],[\"string\",{\"1\":{\"8\":2,\"12\":7,\"28\":1,\"41\":1,\"83\":1,\"84\":1}}],[\"steps\",{\"1\":{\"129\":12}}],[\"store\",{\"1\":{\"44\":2}}],[\"stop\",{\"1\":{\"36\":2}}],[\"stw\",{\"1\":{\"39\":1,\"52\":3}}],[\"statudy\",{\"0\":{\"244\":1}}],[\"status\",{\"1\":{\"107\":1,\"158\":1,\"181\":1,\"182\":1}}],[\"state\",{\"1\":{\"83\":1}}],[\"stat\",{\"1\":{\"69\":1}}],[\"static关键字修饰方法\",{\"1\":{\"8\":1}}],[\"static\",{\"1\":{\"8\":4,\"12\":3,\"27\":3,\"28\":1,\"41\":1,\"83\":3,\"84\":3}}],[\"start\",{\"0\":{\"142\":1},\"1\":{\"65\":1,\"69\":1,\"83\":2,\"189\":1}}],[\"starttime2\",{\"1\":{\"12\":2}}],[\"starttime\",{\"1\":{\"12\":2}}],[\"内部结构\",{\"0\":{\"194\":1}}],[\"内完成垃圾收集\",{\"1\":{\"52\":1}}],[\"内存采用一个\",{\"1\":{\"112\":1}}],[\"内存泄漏的一些事\",{\"0\":{\"95\":1}}],[\"内存很大的时候\",{\"1\":{\"81\":1}}],[\"内存使用会多出1\",{\"1\":{\"19\":1}}],[\"内存分配完成后\",{\"1\":{\"17\":1}}],[\"内存占用多\",{\"1\":{\"7\":1}}],[\"内联优化\",{\"1\":{\"8\":1}}],[\"+heapdumponoutofmemoryerror\",{\"1\":{\"81\":1}}],[\"+cmsparallelremarkenabled\",{\"1\":{\"40\":1}}],[\"+cmsparallellnitialmarkenabled\",{\"1\":{\"40\":1}}],[\"+cmsscavengebeforeremark\",{\"1\":{\"40\":1}}],[\"+eliminateallocations\",{\"1\":{\"20\":1}}],[\"+unlockexperimentalvmoptions\",{\"1\":{\"69\":1}}],[\"+unlockdiagnosticvmoptions\",{\"1\":{\"8\":2}}],[\"+usezgc\",{\"1\":{\"69\":1}}],[\"+useg1gc\",{\"0\":{\"52\":1},\"1\":{\"57\":1}}],[\"+usecmsinitiatingoccupancyonly\",{\"1\":{\"40\":1}}],[\"+usecmscompactatfullcollection\",{\"1\":{\"40\":1}}],[\"+usecmscompactatfullcollection可以让jvm在执行完标记清除后再做整理\",{\"1\":{\"39\":1}}],[\"+useconcmarksweepgc\",{\"1\":{\"40\":1}}],[\"+usetlab参数来关闭和开启本地线程分配缓冲\",{\"1\":{\"16\":1}}],[\"+inline\",{\"1\":{\"8\":1}}],[\"+printgcdetails\",{\"1\":{\"20\":1}}],[\"+printinlining\",{\"1\":{\"8\":2}}],[\"+printcompilation\",{\"1\":{\"8\":1}}],[\"+\",{\"1\":{\"8\":2,\"12\":2,\"19\":1,\"28\":2,\"47\":2,\"84\":1,\"107\":1}}],[\"pct\",{\"1\":{\"129\":1}}],[\"plan\",{\"1\":{\"129\":8}}],[\"plans\",{\"1\":{\"129\":2}}],[\"pushdown\",{\"1\":{\"127\":1}}],[\"public\",{\"1\":{\"8\":7,\"12\":4,\"25\":3,\"28\":2,\"41\":2,\"83\":2,\"84\":5}}],[\"pid​显示你的java进程内存情况\",{\"1\":{\"84\":1}}],[\"pid才发现命令变了\",{\"1\":{\"69\":1}}],[\"pid\",{\"0\":{\"83\":1,\"86\":1,\"87\":1},\"1\":{\"69\":5,\"79\":2,\"80\":3,\"81\":1,\"84\":1,\"89\":1,\"90\":1,\"92\":1}}],[\"p\",{\"1\":{\"68\":1,\"69\":1,\"84\":1,\"196\":3}}],[\"potential\",{\"1\":{\"129\":2}}],[\"pos\",{\"1\":{\"205\":3}}],[\"position`\",{\"1\":{\"121\":1}}],[\"position\",{\"1\":{\"117\":1,\"118\":2,\"121\":4,\"123\":1,\"124\":3,\"125\":2,\"126\":4,\"127\":4,\"129\":6,\"131\":1,\"136\":1,\"239\":1,\"240\":4}}],[\"post\",{\"1\":{\"44\":1}}],[\"pointer查找到上一个版本的数据\",{\"1\":{\"189\":1}}],[\"pointer来记录本次修改的事务id和回滚的指针\",{\"1\":{\"188\":1}}],[\"pointers的4个颜色位\",{\"1\":{\"68\":1}}],[\"pointers\",{\"1\":{\"66\":1}}],[\"point是针对正在执行线程设计的\",{\"1\":{\"74\":1}}],[\"point\",{\"0\":{\"73\":1},\"1\":{\"205\":4}}],[\"pgc在azul\",{\"1\":{\"61\":1}}],[\"pgc虽然算法上可以做成完全并发\",{\"1\":{\"61\":1}}],[\"pgc简单来说是\",{\"1\":{\"61\":1}}],[\"p46\",{\"1\":{\"61\":1}}],[\"pdf\",{\"1\":{\"61\":2}}],[\"packed\",{\"1\":{\"238\":1}}],[\"package\",{\"1\":{\"84\":1}}],[\"page\",{\"1\":{\"107\":8,\"205\":3}}],[\"paths\",{\"1\":{\"129\":4}}],[\"path\",{\"1\":{\"68\":1,\"129\":2}}],[\"pause\",{\"1\":{\"65\":2}}],[\"papers\",{\"1\":{\"61\":1}}],[\"parts\",{\"1\":{\"129\":2}}],[\"partial\",{\"1\":{\"48\":1}}],[\"param\",{\"1\":{\"44\":2}}],[\"parallelgcthreads\",{\"1\":{\"37\":1,\"57\":1}}],[\"parallel\",{\"1\":{\"36\":1,\"37\":7,\"38\":1,\"71\":1}}],[\"parnew\",{\"1\":{\"38\":1}}],[\"padding\",{\"1\":{\"18\":1}}],[\"province=xx\",{\"1\":{\"139\":3}}],[\"province\",{\"1\":{\"139\":5}}],[\"provides\",{\"1\":{\"129\":1}}],[\"propagation\",{\"1\":{\"129\":2}}],[\"processing\",{\"1\":{\"129\":4}}],[\"procedure\",{\"1\":{\"121\":2}}],[\"protected\",{\"1\":{\"28\":1}}],[\"prefix\",{\"1\":{\"129\":2}}],[\"preparation\",{\"1\":{\"129\":2}}],[\"prepare\",{\"1\":{\"65\":1}}],[\"pre\",{\"1\":{\"44\":1,\"45\":1,\"47\":2}}],[\"pretenuresizethreshold参数设置大对象阈值\",{\"1\":{\"21\":1}}],[\"primary\",{\"1\":{\"121\":1,\"129\":1}}],[\"printcompilation\",{\"1\":{\"88\":1}}],[\"println\",{\"1\":{\"8\":2,\"12\":2,\"28\":1,\"83\":5}}],[\"prio=5\",{\"1\":{\"83\":1}}],[\"private\",{\"1\":{\"8\":4,\"9\":2,\"83\":2}}],[\"per大大毫无遮掩地表示当前的zgc如果遇到非常高的对象分配速率\",{\"1\":{\"69\":1}}],[\"performancetacticindex\",{\"1\":{\"7\":2}}],[\"permsize代表永久代的初始容量\",{\"1\":{\"0\":1}}],[\"permsize参数意思不一样\",{\"1\":{\"0\":1}}],[\"进一步减少频繁创建栈帧的性能开销\",{\"1\":{\"8\":1}}],[\"进行排序\",{\"1\":{\"239\":1,\"240\":1}}],[\"进行更新即可\",{\"1\":{\"223\":1}}],[\"进行词法\",{\"1\":{\"198\":1}}],[\"进行内联优化\",{\"1\":{\"8\":1}}],[\"进行简单的优化\",{\"1\":{\"7\":1}}],[\"进行优化的耗时也更长等\",{\"1\":{\"7\":1}}],[\"即先读取一部分二级索引记录\",{\"1\":{\"228\":1}}],[\"即数据项不可分\",{\"1\":{\"210\":1}}],[\"即数据量大的表为驱动表\",{\"1\":{\"151\":1}}],[\"即为where\",{\"1\":{\"233\":1}}],[\"即为\",{\"1\":{\"204\":1}}],[\"即为属性赋值\",{\"1\":{\"19\":1}}],[\"即id在\",{\"1\":{\"177\":1}}],[\"即事务a读取一次数据后\",{\"1\":{\"165\":1}}],[\"即count\",{\"1\":{\"153\":1}}],[\"即需要扫描10100次磁盘\",{\"1\":{\"149\":1}}],[\"即此时的排序不使用于不满足最左匹配原则的查询\",{\"1\":{\"118\":1}}],[\"即跳过左边的某个字段去查询\",{\"1\":{\"118\":1}}],[\"即\",{\"1\":{\"115\":1,\"204\":2}}],[\"即可\",{\"1\":{\"106\":1}}],[\"即表示\",{\"1\":{\"103\":1}}],[\"即红黑树的特性就是\",{\"1\":{\"101\":1}}],[\"即我们要在尽可能少的比对次数中\",{\"1\":{\"98\":1}}],[\"即一个事务内多条sql修改的数据\",{\"1\":{\"164\":1}}],[\"即一行一行的比对数据\",{\"1\":{\"98\":1}}],[\"即一部分空闲的和已使用的相互交错\",{\"1\":{\"16\":1}}],[\"即周期结束标识为10\",{\"1\":{\"66\":1}}],[\"即周期结束标识为01\",{\"1\":{\"66\":1}}],[\"即颜色指针\",{\"1\":{\"66\":1}}],[\"即发生引用字段赋值时\",{\"1\":{\"49\":1}}],[\"即512字节\",{\"1\":{\"48\":1}}],[\"即代表不可达\",{\"1\":{\"41\":1}}],[\"即将被回收\",{\"1\":{\"28\":1}}],[\"即将回收\",{\"1\":{\"28\":1}}],[\"即使在可达性分析算法中不可达的对象\",{\"1\":{\"28\":1}}],[\"即使程序员写的代码不够优化\",{\"1\":{\"7\":1}}],[\"即不能再被任何途径使用的对象\",{\"1\":{\"24\":1}}],[\"即8字节\",{\"1\":{\"19\":1}}],[\"即对象按照程序员意愿进行初始化\",{\"1\":{\"19\":1}}],[\"即对象指向它的类元数据的指针\",{\"1\":{\"18\":1}}],[\"即左边都是内存\",{\"1\":{\"16\":1}}],[\"即jvm将java堆内一部分区域划分给这个对象使用\",{\"1\":{\"16\":1}}],[\"即1\",{\"1\":{\"0\":1}}],[\"5nf\",{\"1\":{\"209\":1}}],[\"512g\",{\"1\":{\"204\":2}}],[\"56\",{\"1\":{\"105\":3,\"111\":1}}],[\"50但不提交\",{\"1\":{\"173\":1}}],[\"5061\",{\"1\":{\"129\":1}}],[\"5000\",{\"1\":{\"83\":2}}],[\"50\",{\"1\":{\"59\":1,\"106\":1,\"173\":2}}],[\"5倍左右\",{\"1\":{\"19\":1}}],[\"5\",{\"0\":{\"19\":1,\"127\":1,\"137\":1},\"1\":{\"7\":1,\"36\":1,\"127\":1,\"131\":1,\"173\":1,\"175\":1,\"201\":3,\"232\":1}}],[\"虚引用也称为幽灵引用或者幻影引用\",{\"1\":{\"27\":1}}],[\"虚引用\",{\"1\":{\"27\":2}}],[\"虚方法调用版本等全部信息\",{\"1\":{\"7\":1}}],[\"虚拟机的记录操作都是通过写屏障实现的\",{\"1\":{\"43\":1}}],[\"虚拟机的设计者们当然知道\",{\"1\":{\"36\":1}}],[\"虚拟机第一款真正意义上的并发收集器\",{\"1\":{\"39\":1}}],[\"虚拟机就不会实现那么多不同的垃圾收集器了\",{\"1\":{\"35\":1}}],[\"虚拟机给每个对象一个对象年龄\",{\"1\":{\"22\":1}}],[\"虚拟机采用分代的算法进行对象管理和垃圾收集\",{\"1\":{\"22\":1}}],[\"虚拟机采用cas+重新分配方式保证更新时的原子性来保证并发时的内存分配\",{\"1\":{\"16\":1}}],[\"虚拟机不会将一个对象完整的分配到栈上\",{\"1\":{\"20\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"18\":1}}],[\"虚拟机需要对对象设置对象头\",{\"1\":{\"18\":1}}],[\"虚拟机需要将分配的空间都初始化为零值\",{\"1\":{\"17\":1}}],[\"虚拟机会维护一个列表\",{\"1\":{\"16\":1}}],[\"虚拟机会对新生对象分配内存操作\",{\"1\":{\"16\":1}}],[\"虚拟机执行new方法指令时\",{\"1\":{\"15\":1}}],[\"虚拟机执⾏\",{\"1\":{\"4\":1}}],[\"虚拟机中的内联过程却远没有想象中那么容易\",{\"1\":{\"8\":1}}],[\"虚拟机没有太⼤的关系\",{\"1\":{\"4\":1}}],[\"虚拟机之外执⾏\",{\"1\":{\"4\":1}}],[\"还要先经过优化器的处理\",{\"1\":{\"199\":1}}],[\"还要确保这些联合索引的字段顺序尽量满足sql查询的最左前缀原则\",{\"1\":{\"134\":1}}],[\"还涉及回表操作\",{\"1\":{\"146\":1}}],[\"还需要进行语法识别\",{\"1\":{\"198\":1}}],[\"还需要取出字段\",{\"1\":{\"154\":1}}],[\"还需要分页之类的处理\",{\"1\":{\"139\":1}}],[\"还需要解释执行来帮助提供一些信息支持\",{\"1\":{\"5\":1}}],[\"还是让order\",{\"1\":{\"137\":1}}],[\"还是针对order\",{\"1\":{\"137\":1}}],[\"还不如全表扫描了\",{\"1\":{\"135\":1}}],[\"还不如就全表扫描\",{\"1\":{\"123\":1}}],[\"还可以用jvisualvm自动检测死锁\",{\"1\":{\"83\":1}}],[\"还可以为后续进一步的优化手段创建条件\",{\"1\":{\"10\":1}}],[\"还可直接检测到这个类的哪一行不断产生大对象导致堆溢出\",{\"1\":{\"81\":1}}],[\"还得考虑每次gc过后的存活对象有多少\",{\"1\":{\"58\":1}}],[\"还能建立可预测的停顿时间模型\",{\"1\":{\"52\":1}}],[\"还具备高吞吐量性能特征\",{\"1\":{\"52\":1}}],[\"还有一种一般以最初查询出的数据最后一条的某个字段\",{\"1\":{\"145\":1}}],[\"还有根据性别去筛选\",{\"1\":{\"139\":1}}],[\"还有可能导致oom\",{\"1\":{\"95\":1}}],[\"还有性能的考虑\",{\"1\":{\"47\":1}}],[\"还有并发清理\",{\"1\":{\"42\":1}}],[\"还会占用更多的codecache\",{\"1\":{\"8\":1}}],[\"还会收集如分支跳转\",{\"1\":{\"7\":1}}],[\"仍然需要查询\",{\"1\":{\"100\":1}}],[\"仍然是白色的对象\",{\"1\":{\"41\":1}}],[\"仍然还有停顿\",{\"1\":{\"36\":1}}],[\"仍然使用c1编译器来执行\",{\"1\":{\"7\":1}}],[\"仍使用c1编译器来执行\",{\"1\":{\"7\":1}}],[\"不建议轻易调整\",{\"1\":{\"240\":1}}],[\"不仅给数据库的编程人员制造麻烦\",{\"1\":{\"209\":1}}],[\"不加启动会报错\",{\"1\":{\"206\":1}}],[\"不保存查询操作\",{\"1\":{\"206\":1}}],[\"不是针对记录加的锁\",{\"1\":{\"178\":1}}],[\"不释放锁\",{\"1\":{\"167\":1}}],[\"不符合隔离性\",{\"1\":{\"165\":1}}],[\"不符合隔离性要求\",{\"1\":{\"165\":1}}],[\"不符合一致性要求\",{\"1\":{\"165\":1}}],[\"不同时间点出现了数据前后不一致情况\",{\"1\":{\"165\":1}}],[\"不同的叶子节点存储了其左右相邻的叶子节点的内存地址\",{\"1\":{\"104\":1}}],[\"不同的垃圾收集器会略微有点不同\",{\"1\":{\"22\":1}}],[\"不应受系统影响\",{\"1\":{\"164\":1}}],[\"不受其他事务影响\",{\"1\":{\"164\":1}}],[\"不可重复读\",{\"1\":{\"165\":1,\"172\":1}}],[\"不可重复读等问题\",{\"1\":{\"163\":1}}],[\"不可能出现\",{\"1\":{\"172\":6}}],[\"不可能\",{\"1\":{\"60\":1}}],[\"不取值\",{\"1\":{\"155\":1}}],[\"不需要取出字段统计\",{\"1\":{\"154\":1}}],[\"不需要手动启用指针压缩\",{\"1\":{\"19\":1}}],[\"不能大于最大值\",{\"1\":{\"204\":1}}],[\"不能把太多的字段以及太多的值都用\",{\"1\":{\"139\":1}}],[\"不能异想天开\",{\"1\":{\"52\":1}}],[\"不在小基数字段上建立索引\",{\"0\":{\"135\":1}}],[\"不包含数据\",{\"1\":{\"113\":1}}],[\"不使用\",{\"1\":{\"107\":1}}],[\"不使用二叉树的原因\",{\"1\":{\"100\":1}}],[\"不直接对线程操作\",{\"1\":{\"73\":1}}],[\"不会发生插入\",{\"1\":{\"209\":1}}],[\"不会因为服务宕机而丢失数据但效率会差一些\",{\"1\":{\"205\":1}}],[\"不会阻塞其他进程对同一表的读请求\",{\"1\":{\"170\":1}}],[\"不会出现using\",{\"1\":{\"131\":1}}],[\"不会在单边增长的情况下退化为链表\",{\"1\":{\"101\":1}}],[\"不会移动大对象\",{\"1\":{\"69\":1}}],[\"不会马上做young\",{\"1\":{\"54\":1}}],[\"不如说是标记指针\",{\"1\":{\"65\":1}}],[\"不像c4\",{\"1\":{\"63\":1}}],[\"不区分年轻代和老年代\",{\"1\":{\"63\":1}}],[\"不分代\",{\"0\":{\"63\":1}}],[\"不过一般来说\",{\"1\":{\"222\":1}}],[\"不过count\",{\"1\":{\"154\":1}}],[\"不过有时可能用户会这么来查询\",{\"1\":{\"139\":1}}],[\"不过会根据线程的多少啊\",{\"1\":{\"61\":1}}],[\"不过\",{\"1\":{\"52\":1}}],[\"不过到了zgc\",{\"1\":{\"52\":1}}],[\"不管是年轻代或是老年代\",{\"1\":{\"52\":1}}],[\"不用直接进老年代\",{\"1\":{\"52\":1}}],[\"不经过灰色对象\",{\"1\":{\"41\":1}}],[\"不存在线程竞争\",{\"1\":{\"12\":1}}],[\"不开启性能监控\",{\"1\":{\"7\":1}}],[\"不限制\",{\"1\":{\"0\":1}}],[\"纯解释执行\",{\"1\":{\"7\":1}}],[\"描述\",{\"1\":{\"7\":1}}],[\"划分出不同的编译层次\",{\"1\":{\"7\":1}}],[\"分成几个等级\",{\"1\":{\"209\":1}}],[\"分段放\",{\"1\":{\"150\":1}}],[\"分多次存放\",{\"1\":{\"150\":1}}],[\"分页查询\",{\"0\":{\"142\":1}}],[\"分析的过程\",{\"1\":{\"198\":1}}],[\"分析器对\",{\"1\":{\"198\":1}}],[\"分析器会先做\",{\"1\":{\"198\":1}}],[\"分析你发送过来的\",{\"1\":{\"198\":1}}],[\"分析\",{\"1\":{\"131\":7}}],[\"分析各个索引使用成本\",{\"1\":{\"129\":1}}],[\"分为几种类型\",{\"1\":{\"107\":1}}],[\"分代收集\",{\"1\":{\"52\":1}}],[\"分代收集理论\",{\"0\":{\"32\":1}}],[\"分配速率\",{\"1\":{\"70\":1}}],[\"分配给这个对象\",{\"1\":{\"16\":1}}],[\"分配内存\",{\"0\":{\"16\":1}}],[\"分层编译根据编译器编译\",{\"1\":{\"7\":1}}],[\"分别被称为\",{\"1\":{\"7\":1}}],[\"所在节点的内存地址\",{\"1\":{\"105\":1}}],[\"所截获\",{\"1\":{\"65\":1}}],[\"所有跨存储引擎的功能都在这一层实现\",{\"1\":{\"195\":1}}],[\"所有不可展示的条件\",{\"1\":{\"189\":1}}],[\"所有的操作都将会被撤销\",{\"1\":{\"173\":1}}],[\"所有的对象都是白色的\",{\"1\":{\"41\":1}}],[\"所有期望的引用都能被重新标记\",{\"1\":{\"66\":1}}],[\"所有标志都变成了未标记\",{\"1\":{\"66\":1}}],[\"所有涉及部分区域收集\",{\"1\":{\"48\":1}}],[\"所有使用过的内存都在一边\",{\"1\":{\"16\":1}}],[\"所谓得反范式化就是为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反\",{\"1\":{\"213\":1}}],[\"所谓的写屏障\",{\"1\":{\"44\":1}}],[\"所谓吞吐量就是\",{\"1\":{\"37\":1}}],[\"所谓对象之间的相互引用问题\",{\"1\":{\"25\":1}}],[\"所分配内存仅仅是把指针向空闲一边移动所需大小的相等的距离\",{\"1\":{\"16\":1}}],[\"所花费的时间便会越长\",{\"1\":{\"7\":1}}],[\"所以直接更新磁盘文件是不能让数据库抗住很高并发的\",{\"1\":{\"191\":1,\"203\":1}}],[\"所以数据库设计了事务隔离\",{\"1\":{\"163\":1}}],[\"所以不需要用count\",{\"1\":{\"155\":1}}],[\"所以理论上count\",{\"1\":{\"154\":1}}],[\"所以此时会多扫一次t1表\",{\"1\":{\"150\":1}}],[\"所以索引未颠倒\",{\"1\":{\"131\":1}}],[\"所以mysql最终选择索引扫描\",{\"1\":{\"129\":1}}],[\"所以mysql最终选择全表扫描\",{\"1\":{\"129\":1}}],[\"所以即使我们创建的时候不是按照顺序插入的\",{\"1\":{\"115\":1}}],[\"所以说我们最好使用自增主键\",{\"1\":{\"115\":1}}],[\"所以说我们要尽可能减少磁盘\",{\"1\":{\"107\":1}}],[\"所以说\",{\"1\":{\"107\":1,\"118\":1}}],[\"所以可以让排序和分页操作先查出主键\",{\"1\":{\"146\":1}}],[\"所以可以把爱好字段也加入索引\",{\"1\":{\"139\":1}}],[\"所以可以很快的访问到\",{\"1\":{\"105\":1}}],[\"所以可以选择复制算法\",{\"1\":{\"32\":1}}],[\"所以我们直接认为每读取一条二级索引记录就立即执行回表操作\",{\"1\":{\"228\":1}}],[\"所以我们范围查询的时候就可以根据第一个叶子节点以及指针\",{\"1\":{\"106\":1}}],[\"所以我们要考虑是否可以增加同一个节点上存储的数据的个数\",{\"1\":{\"101\":1}}],[\"所以我们必须选择\",{\"1\":{\"32\":1}}],[\"所以需要在不同的时间分别估算不同情况下对象增长速率\",{\"1\":{\"90\":1}}],[\"所以只能临时分析sql使用\",{\"1\":{\"129\":1}}],[\"所以只能在下次gc的时候进行回收\",{\"1\":{\"69\":1}}],[\"所以只有第一次访问旧对象会变慢\",{\"1\":{\"65\":1}}],[\"所以受限于目前的硬件\",{\"1\":{\"68\":1}}],[\"所以会导致配置zgc的应用的吞吐量会变低\",{\"1\":{\"68\":1}}],[\"所以gc正常工作的时候除了会在自己的线程上吃点cpu之外并不会显著干扰应用的运行\",{\"1\":{\"61\":1}}],[\"所以g1选择satb不深度扫描对象\",{\"1\":{\"47\":1}}],[\"所以这里大家要对前缀索引有一个了解\",{\"1\":{\"136\":1}}],[\"所以这里mysql选择给\",{\"1\":{\"128\":1}}],[\"所以这里的优化核心还是在于调节\",{\"1\":{\"58\":1}}],[\"所以这个排序是没法用上索引的\",{\"1\":{\"136\":1}}],[\"所以这个时候索引下推并不会起到减少查询全行数据的效果\",{\"1\":{\"127\":1}}],[\"所以这个重映射操作并不是很迫切\",{\"1\":{\"65\":1}}],[\"所以这个暂停就不会随着gc堆的大小而变化\",{\"1\":{\"61\":1}}],[\"所以这个sychronized没有起作用\",{\"1\":{\"12\":1}}],[\"所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的\",{\"1\":{\"52\":1}}],[\"所以通常想要检查锁是否存在多线程竞争比较困难\",{\"1\":{\"12\":1}}],[\"所以对于选择哪种\",{\"1\":{\"47\":1}}],[\"所以在后续的垃圾收集器设计中停顿时间在不断缩短\",{\"1\":{\"36\":1}}],[\"所以\",{\"1\":{\"11\":2,\"98\":1,\"107\":1,\"240\":1}}],[\"所以没有办法提前维护出一个完整的字节码缓存\",{\"1\":{\"5\":1}}],[\"所以与\",{\"1\":{\"4\":1}}],[\"比对方式\",{\"0\":{\"189\":1}}],[\"比对数据消耗的实现是非常短暂的\",{\"1\":{\"107\":1}}],[\"比count\",{\"1\":{\"154\":1}}],[\"比较简单\",{\"1\":{\"34\":1}}],[\"比较适合资源相对充裕的服务器\",{\"1\":{\"7\":1}}],[\"比较适合一些小巧的桌面应用\",{\"1\":{\"7\":1}}],[\"比如tinyint\",{\"1\":{\"230\":1}}],[\"比如假设有一个计数器表\",{\"1\":{\"223\":1}}],[\"比如网站点击数\",{\"1\":{\"223\":1}}],[\"比如下面这句因为将\",{\"1\":{\"198\":1}}],[\"比如下面两个语句\",{\"1\":{\"151\":1}}],[\"比如识别\",{\"1\":{\"198\":1}}],[\"比如不常修改的字典表\",{\"1\":{\"197\":1}}],[\"比如存储过程\",{\"1\":{\"195\":1}}],[\"比如join\",{\"1\":{\"150\":1}}],[\"比如sql\",{\"1\":{\"139\":1}}],[\"比如要筛选最近一周登录过的用户\",{\"1\":{\"139\":1}}],[\"比如用户可能经常会根据省市优先筛选同城的用户\",{\"1\":{\"139\":1}}],[\"比如用户的受欢迎程度评分\",{\"1\":{\"139\":1}}],[\"比如针对这个字段的前20个字符建立索引\",{\"1\":{\"136\":1}}],[\"比如说什么tinyint之类的\",{\"1\":{\"136\":1}}],[\"比如说老年代此时有1000个region都满了\",{\"1\":{\"52\":1}}],[\"比如一张表总共100万行记录\",{\"1\":{\"135\":1}}],[\"比如一个region花200ms能回收10m垃圾\",{\"1\":{\"52\":1}}],[\"比如可以设计一个或者两三个联合索引\",{\"1\":{\"134\":1}}],[\"比如我们使用\",{\"1\":{\"107\":1}}],[\"比如我们查找\",{\"1\":{\"98\":1}}],[\"比如我们之前说的堆默认有2048个region\",{\"1\":{\"57\":1}}],[\"比如ehcache等自带一些lru数据淘汰算法的框架来作为jvm级的缓存\",{\"1\":{\"95\":1}}],[\"比如堆内存大小\",{\"1\":{\"89\":1}}],[\"比如堆大小为4096m\",{\"1\":{\"52\":1}}],[\"比如gc等\",{\"1\":{\"73\":1}}],[\"比如64g\",{\"1\":{\"60\":1}}],[\"比如按照上面算的\",{\"1\":{\"52\":1}}],[\"比如写屏障可以用于记录跨代\",{\"1\":{\"47\":1}}],[\"比如白色\",{\"1\":{\"47\":1}}],[\"比如新增引用\",{\"1\":{\"46\":1}}],[\"比如引用消失\",{\"1\":{\"45\":1}}],[\"比如在新生代中\",{\"1\":{\"32\":1}}],[\"比如像这样的方法\",{\"1\":{\"8\":1}}],[\"比如\",{\"1\":{\"8\":1,\"139\":4}}],[\"比如如下代码\",{\"1\":{\"8\":1}}],[\"比率\",{\"1\":{\"6\":1}}],[\"但根据经验\",{\"1\":{\"232\":1}}],[\"但如果需要恢复数据或主从复制\",{\"1\":{\"206\":1}}],[\"但如果我们把停顿时间调得非常低\",{\"1\":{\"52\":1}}],[\"但一般而言\",{\"1\":{\"197\":1}}],[\"但它可以保证每个更新请求都是更新内存\",{\"1\":{\"203\":1}}],[\"但它可以保证每个更新请求都是更新内存bufferpool\",{\"1\":{\"191\":1}}],[\"但它的实际容量完全有可能小于中型region\",{\"1\":{\"64\":1}}],[\"但有些情况数据库没法检测到\",{\"1\":{\"183\":1}}],[\"但有一种情况比较简单\",{\"1\":{\"12\":1}}],[\"但修改a正读取的数据时\",{\"1\":{\"176\":1}}],[\"但会阻塞对同一表的写请求\",{\"1\":{\"170\":1}}],[\"但也有可能会出现优化错误的情况\",{\"1\":{\"151\":1}}],[\"但也相应的\",{\"1\":{\"7\":1}}],[\"但t2表有100行\",{\"1\":{\"150\":1}}],[\"但程序运行中会存在sleep或者中断的线程\",{\"1\":{\"74\":1}}],[\"但通过jstat\",{\"1\":{\"69\":1}}],[\"但与其说是标记对象\",{\"1\":{\"65\":1}}],[\"但必须为2mb的整数倍\",{\"1\":{\"64\":1}}],[\"但zgc目前实现起来太麻烦\",{\"1\":{\"63\":1}}],[\"但azul\",{\"1\":{\"61\":1}}],[\"但应用运行时间一长就不行了\",{\"1\":{\"52\":1}}],[\"但g1\",{\"1\":{\"52\":1}}],[\"但不能因为这个就随便增大sort\",{\"1\":{\"240\":1}}],[\"但不能支持线程逃逸\",{\"1\":{\"11\":1}}],[\"但不包括gc堆里的对象指针\",{\"1\":{\"61\":1}}],[\"但不再是物理隔离了\",{\"1\":{\"52\":1}}],[\"但这个对象上至少存在一个引用还没有被扫描过\",{\"1\":{\"41\":1}}],[\"但并非为了挑选出一个最好的收集器\",{\"1\":{\"35\":1}}],[\"但后续步骤不是直接对可回收对象回收\",{\"1\":{\"35\":1}}],[\"但minor\",{\"1\":{\"24\":1}}],[\"但使用64位进行存储\",{\"1\":{\"19\":1}}],[\"但实际上两个编译器不是相互取代而是相互协作的关系\",{\"1\":{\"7\":1}}],[\"但翻译出来的机器码优化程度不高\",{\"1\":{\"7\":1}}],[\"但是要想设计\",{\"1\":{\"209\":1}}],[\"但是操作系统如果宕机了\",{\"1\":{\"205\":1}}],[\"但是在整体并发处理能力方面要远远优于myisam的表级锁定的\",{\"1\":{\"179\":1}}],[\"但是对于当前这种情况依然用不到age这个索引字段\",{\"1\":{\"139\":1}}],[\"但是假如你要是order\",{\"1\":{\"136\":1}}],[\"但是排序的时候age和position颠倒位置了\",{\"1\":{\"131\":1}}],[\"但是出现了using\",{\"1\":{\"131\":1}}],[\"但是最终查找效率不一定比全表扫描高\",{\"1\":{\"124\":1}}],[\"但是最多新生代的占比不会超过60\",{\"1\":{\"52\":1}}],[\"但是不建议修改\",{\"1\":{\"107\":1}}],[\"但是不推荐\",{\"1\":{\"52\":1}}],[\"但是由于每个节点都存储了数据\",{\"1\":{\"102\":1}}],[\"但是当我们数据比较多的时候\",{\"1\":{\"101\":1}}],[\"但是很少考虑这个map的容量问题\",{\"1\":{\"95\":1}}],[\"但是free\",{\"1\":{\"69\":1}}],[\"但是zgc的总的执行时间还是远远大于这个时间的\",{\"1\":{\"69\":1}}],[\"但是zgc中对象引用存在\",{\"1\":{\"65\":1}}],[\"但是转发表还得留着不能释放掉\",{\"1\":{\"65\":1}}],[\"但是如果调的过低的话\",{\"1\":{\"62\":1}}],[\"但是gc过程中所有的阶段都设计为可以并发的\",{\"1\":{\"61\":1}}],[\"但是gc做完后发现释放不出空间存放新的对象\",{\"1\":{\"27\":1}}],[\"但是还是保留了分代的概念\",{\"1\":{\"52\":1}}],[\"但是因为只回收一部分region\",{\"1\":{\"52\":1}}],[\"但是因为根据预期停顿时间\",{\"1\":{\"52\":1}}],[\"但是推荐默认的计算方式\",{\"1\":{\"52\":1}}],[\"但是需要知道如何让卡表变脏\",{\"1\":{\"49\":1}}],[\"但是有其他体现颜色的地方\",{\"1\":{\"47\":1}}],[\"但是它有下面几个明显的缺点\",{\"1\":{\"39\":1}}],[\"但是一般不推荐修改\",{\"1\":{\"37\":1}}],[\"但是会带来两个明显的问题\",{\"1\":{\"34\":1}}],[\"但是他们因为互相引用对方\",{\"1\":{\"25\":1}}],[\"但是目前主流的虚拟机中并没有选择这个算法来管理内存\",{\"1\":{\"25\":1}}],[\"但是\",{\"1\":{\"8\":1,\"36\":1,\"99\":1,\"179\":1}}],[\"但是jvm也不清楚程序员会写出什么样的代码\",{\"1\":{\"5\":1}}],[\"但是这种方式需要在上层语言和机器码之间经过中间⼀层jvm字节码的转换\",{\"1\":{\"5\":1}}],[\"占用磁盘空间也会比较小\",{\"1\":{\"136\":1}}],[\"占用空间大小\",{\"1\":{\"79\":1}}],[\"占用较大带宽\",{\"1\":{\"19\":1}}],[\"占用资源更多\",{\"1\":{\"7\":1}}],[\"占用内存小\",{\"1\":{\"7\":1}}],[\"占整个堆内存的1\",{\"1\":{\"0\":1}}],[\"阈值计算公式\",{\"1\":{\"6\":2}}],[\"当需要updat主键时\",{\"1\":{\"235\":1}}],[\"当对计数器更新时\",{\"1\":{\"223\":1}}],[\"当对象a的成员变量的引用发生变化时\",{\"1\":{\"46\":1}}],[\"当对象b的成员变量的引用发生变化时\",{\"1\":{\"45\":1}}],[\"当对象没有覆盖finalize方法\",{\"1\":{\"28\":1}}],[\"当对象没有被引用的时候\",{\"1\":{\"20\":1}}],[\"当对象需要大量且连续的空间时\",{\"1\":{\"21\":1}}],[\"当移动到\",{\"1\":{\"205\":1}}],[\"当写到第二个文件的结尾时\",{\"1\":{\"205\":1}}],[\"当分析器分析过后\",{\"1\":{\"198\":1}}],[\"当没有命中缓存或设置了按需开启且查询\",{\"1\":{\"198\":1}}],[\"当有需要时\",{\"1\":{\"197\":1}}],[\"当有字段有索引时候的效率\",{\"1\":{\"153\":1}}],[\"当从硬盘中查询出结果后\",{\"1\":{\"197\":1}}],[\"当管理员修改了用户权限后\",{\"1\":{\"196\":1}}],[\"当链接一个\",{\"1\":{\"196\":1}}],[\"当trx\",{\"1\":{\"189\":3}}],[\"当\",{\"1\":{\"189\":3,\"196\":1,\"197\":1,\"205\":1}}],[\"当执行第一条sql语句时会生成read\",{\"1\":{\"188\":1}}],[\"当等待次数很高\",{\"1\":{\"181\":1}}],[\"当系统并发量高的时候\",{\"1\":{\"179\":1}}],[\"当客户端a提交事务后\",{\"1\":{\"176\":1}}],[\"当代价也越高\",{\"1\":{\"172\":1}}],[\"当释放锁后其余session语句会继续执行\",{\"1\":{\"169\":1}}],[\"当一个事务a对一条数据进行修改\",{\"1\":{\"165\":1}}],[\"当一个对象在方法中被定义后\",{\"1\":{\"20\":1}}],[\"当两个或多个事务同时选定了一条数据进行更新\",{\"1\":{\"165\":1}}],[\"当两个表数据量接近\",{\"1\":{\"151\":1}}],[\"当字段没有索引时\",{\"1\":{\"153\":1}}],[\"当字段没有索引时候的效率\",{\"1\":{\"153\":1}}],[\"当字段有索引时候\",{\"1\":{\"153\":1}}],[\"当a表数据集小于b表时\",{\"1\":{\"152\":1}}],[\"当被驱动表关联关系字段没有建立索引时\",{\"1\":{\"149\":1}}],[\"当主键不连续时\",{\"1\":{\"145\":1}}],[\"当主键连续且自增\",{\"0\":{\"144\":1}}],[\"当通过非主键索引查询数据时\",{\"1\":{\"116\":1}}],[\"当使用二级索引查询数据的时候\",{\"1\":{\"116\":1}}],[\"当使用jvm参数\",{\"1\":{\"12\":1}}],[\"当数据超过两千万行\",{\"1\":{\"107\":1}}],[\"当树的一边比另一边更高的时候\",{\"1\":{\"101\":1}}],[\"当我们使用不当的时候\",{\"1\":{\"179\":1}}],[\"当我们插入\",{\"1\":{\"103\":1}}],[\"当我们继续添加这种单边增长数据\",{\"1\":{\"101\":1}}],[\"当我们的数据是顺序增加的时候\",{\"1\":{\"100\":1}}],[\"当我们不加索引的时候\",{\"1\":{\"98\":1}}],[\"当线程运行到这些位置时\",{\"1\":{\"73\":1}}],[\"当加上读屏障时\",{\"1\":{\"68\":1}}],[\"当老年代占有率达到了参数\",{\"1\":{\"55\":1}}],[\"当老年代使用达到该比例时会触发fullgc\",{\"1\":{\"40\":1}}],[\"当读取成员变量时\",{\"1\":{\"47\":1}}],[\"当这个比值越大\",{\"1\":{\"231\":1}}],[\"当这个方法调用次数非常多\",{\"1\":{\"6\":1}}],[\"当这一块的内存使用完后\",{\"1\":{\"33\":1}}],[\"当前要擦除的位置\",{\"1\":{\"205\":1}}],[\"当前记录位置\",{\"1\":{\"205\":1}}],[\"当前正在等待锁定的数量\",{\"1\":{\"181\":1}}],[\"当前session和其他session均可以读出数据\",{\"1\":{\"169\":1}}],[\"当前session更新数据会报错\",{\"1\":{\"169\":1}}],[\"当前的写操作没有执行完\",{\"1\":{\"167\":1}}],[\"当前虚拟机的垃圾收集都采用分代收集算法\",{\"1\":{\"32\":1}}],[\"当前放对象的survivor区域里\",{\"1\":{\"23\":1}}],[\"当前代码中\",{\"1\":{\"12\":1}}],[\"当它的年龄增加到一定程度\",{\"1\":{\"22\":1}}],[\"当堆内存大于32g时\",{\"1\":{\"19\":1}}],[\"当堆内存小于4g时\",{\"1\":{\"19\":1}}],[\"当内存大于4g时\",{\"1\":{\"19\":1}}],[\"当无法进行本地线程分配缓冲时\",{\"1\":{\"16\":1}}],[\"当java堆内存并不是规整的\",{\"1\":{\"16\":1}}],[\"当jvm检测到一个加锁的代码不会出现锁竞争时\",{\"1\":{\"12\":1}}],[\"当然架构设计中对于写热点还有削峰填谷的处理方式\",{\"1\":{\"223\":1}}],[\"当然这也不是绝对的\",{\"1\":{\"128\":1}}],[\"当然satb可能造成更多的浮动垃圾\",{\"1\":{\"47\":1}}],[\"当然通过参数\",{\"1\":{\"39\":1}}],[\"当然也可以用参数\",{\"1\":{\"37\":1,\"52\":1}}],[\"当然有\",{\"1\":{\"36\":1}}],[\"当然\",{\"1\":{\"8\":1,\"136\":1}}],[\"当识别出热点代码后\",{\"1\":{\"7\":1}}],[\"当再次执行时\",{\"1\":{\"5\":1}}],[\"每天只做一次加工后\",{\"1\":{\"222\":1}}],[\"每隔\",{\"1\":{\"205\":1}}],[\"每隔1秒执行1次命令\",{\"1\":{\"90\":1}}],[\"每秒处理几万甚至几十万消息时很正常的\",{\"1\":{\"60\":1}}],[\"每个索引页可存储的数据就更多\",{\"1\":{\"230\":1}}],[\"每个内存地址大概占用\",{\"1\":{\"107\":1}}],[\"每个\",{\"1\":{\"107\":1}}],[\"每个数据页的大小为\",{\"1\":{\"107\":1}}],[\"每个节点都存储了索引和数据\",{\"1\":{\"104\":1}}],[\"每个节点或者是黑色\",{\"1\":{\"101\":1}}],[\"每个叶子节点\",{\"1\":{\"101\":1}}],[\"每个对象有64位的指针\",{\"1\":{\"66\":1}}],[\"每个大型region中只会存放一个大对象\",{\"1\":{\"64\":1}}],[\"每个region是2m\",{\"1\":{\"52\":1}}],[\"每个元素对应着其标识的内存区域一块特定大小的内存块\",{\"1\":{\"48\":1}}],[\"每个线程的栈大小\",{\"1\":{\"0\":1}}],[\"每款垃圾回收器都有自己的想法\",{\"1\":{\"47\":1}}],[\"每次执行回表操作时都相当于要随机读取一个聚簇索引页面\",{\"1\":{\"228\":1}}],[\"每次从二级索引\",{\"1\":{\"228\":1}}],[\"每次从堆内对象的引用类型中读取一个指针时\",{\"1\":{\"68\":1}}],[\"每次随机选择一行进行更新\",{\"1\":{\"223\":1}}],[\"每次等待所花平均时间\",{\"1\":{\"181\":1}}],[\"每次操作对某行数据进行加锁\",{\"1\":{\"171\":1}}],[\"每次操作锁住整张表\",{\"1\":{\"167\":1}}],[\"每次和磁盘进行\",{\"1\":{\"107\":1}}],[\"每次根据允许的收集时间\",{\"1\":{\"52\":1}}],[\"每次使用其中的一块\",{\"1\":{\"33\":1}}],[\"每次收集都会有大量对象\",{\"1\":{\"32\":1}}],[\"每当某个方法被调用一次时\",{\"1\":{\"6\":1}}],[\"热点代码在被jit即时编译的过程中\",{\"1\":{\"7\":1}}],[\"热点代码识别\",{\"0\":{\"6\":1}}],[\"热点探测\",{\"1\":{\"6\":1}}],[\"会严重影响性能\",{\"1\":{\"235\":1}}],[\"会严重限制系统的并发能力\",{\"1\":{\"223\":1}}],[\"会丢失数据\",{\"1\":{\"205\":1}}],[\"会不定时将\",{\"1\":{\"202\":1}}],[\"会在查询缓存返回结果的时候\",{\"1\":{\"200\":1}}],[\"会生成这样一个语法树\",{\"1\":{\"198\":1}}],[\"会根据索引查找到相应数据\",{\"1\":{\"202\":1}}],[\"会根据语法规则分析传入的语句是否满足\",{\"1\":{\"198\":1}}],[\"会根据二分查找算法\",{\"1\":{\"105\":1}}],[\"会先做词法分析\",{\"1\":{\"198\":1}}],[\"会先查询缓存中是否存在相同的\",{\"1\":{\"197\":1}}],[\"会先从undo日志链中获取最新的一条数据\",{\"1\":{\"189\":1}}],[\"会返回\",{\"1\":{\"196\":1}}],[\"会再根据roll\",{\"1\":{\"189\":1}}],[\"会阻塞\",{\"1\":{\"176\":1}}],[\"会阻塞其他进程对同一表的读和写操作\",{\"1\":{\"170\":1}}],[\"会出现死锁情况\",{\"1\":{\"171\":1}}],[\"会面临多个事务并发访问或修改同一条数据的问题\",{\"1\":{\"166\":1}}],[\"会导致最后提交的更新覆盖之前提交的更新\",{\"1\":{\"165\":1}}],[\"会将表的总行数存储在磁盘上\",{\"1\":{\"157\":1}}],[\"会将所有的非叶子节点都放入到内存中\",{\"1\":{\"107\":1}}],[\"会快一点\",{\"1\":{\"154\":1}}],[\"会按照索引字段的顺序排序\",{\"1\":{\"118\":1}}],[\"会首先查找到对应的主键值\",{\"1\":{\"116\":1}}],[\"会自己创建一个隐藏列\",{\"1\":{\"114\":1}}],[\"会从该表的所有列中选择数据不重复的一列来组织\",{\"1\":{\"114\":1}}],[\"会处理大量数据\",{\"1\":{\"69\":1}}],[\"会存在上一次垃圾回收还没执行完\",{\"1\":{\"39\":1}}],[\"会和服务抢资源\",{\"1\":{\"39\":1}}],[\"会直接进入老年代\",{\"1\":{\"21\":1}}],[\"会直接从缓存中获取机器码直接执行\",{\"1\":{\"5\":1}}],[\"会触发minor\",{\"1\":{\"21\":1}}],[\"会给gc带来较大压力\",{\"1\":{\"20\":1}}],[\"会对这个对象的锁进行锁消除\",{\"1\":{\"12\":1}}],[\"会对代码进行一些优化\",{\"1\":{\"7\":1}}],[\"会默认使用混合模式\",{\"1\":{\"5\":1}}],[\"因为每个员工的员工编号是惟一的\",{\"1\":{\"211\":1}}],[\"因为只要更新过表中的值\",{\"1\":{\"197\":1}}],[\"因为只需要进行一次磁盘\",{\"1\":{\"99\":1}}],[\"因为来一个请求就直接对磁盘文件进行随机读写\",{\"1\":{\"191\":1,\"203\":1}}],[\"因为锁主要加在索引上\",{\"1\":{\"178\":1}}],[\"因为数据库会拿真实数据进行计算\",{\"1\":{\"173\":1}}],[\"因为加的是读锁\",{\"1\":{\"169\":1}}],[\"因为myisam存储引擎在存储数据时\",{\"1\":{\"157\":1}}],[\"因为部分情况下\",{\"1\":{\"151\":1}}],[\"因为关联关系在t1表中为索引\",{\"1\":{\"148\":1}}],[\"因为用户没有筛选sex字段\",{\"1\":{\"139\":1}}],[\"因为用户程序继续运行\",{\"1\":{\"39\":1}}],[\"因为这些字段查询太频繁了\",{\"1\":{\"139\":1}}],[\"因为大多数情况基于索引进行where筛选往往可以最快速度筛选出你要的少部分数据\",{\"1\":{\"137\":1}}],[\"因为字段类型较小的话\",{\"1\":{\"136\":1}}],[\"因为你的索引树里就包含男和女两种值\",{\"1\":{\"135\":1}}],[\"因为age为常量\",{\"1\":{\"131\":1}}],[\"因为索引的创建顺序为name\",{\"1\":{\"131\":1}}],[\"因为extra字段里有using\",{\"1\":{\"131\":1}}],[\"因为根据name字段过滤完\",{\"1\":{\"127\":1}}],[\"因为回表效率不高\",{\"1\":{\"124\":1}}],[\"因为叶子节点是按照联合字段综合排序的\",{\"1\":{\"118\":1}}],[\"因为叶子节点就是按照增序排列的\",{\"1\":{\"106\":1}}],[\"因为前提是如果左边的索引字段相同的情况下\",{\"1\":{\"118\":1}}],[\"因为整型的数据更好比较大小\",{\"1\":{\"114\":1}}],[\"因为非聚集索引需要回表操作\",{\"1\":{\"113\":1}}],[\"因为\",{\"1\":{\"107\":1}}],[\"因为同事还没代码权限\",{\"1\":{\"69\":1}}],[\"因为不是我们的项目\",{\"1\":{\"69\":1}}],[\"因为不需要在重新标记阶段再次深度扫描被删除引用对象\",{\"1\":{\"47\":1}}],[\"因为zgc调优参数并不多\",{\"1\":{\"69\":1}}],[\"因为目前主板地址总线最宽只有48bit\",{\"1\":{\"68\":1}}],[\"因为使用了读屏障\",{\"1\":{\"67\":1}}],[\"因为可能还有访问在使用这个转发表\",{\"1\":{\"65\":1}}],[\"因为复制一个大对象的代价非常高昂\",{\"1\":{\"64\":1}}],[\"因为内存太大\",{\"1\":{\"60\":1}}],[\"因为标记期间应用线程还在继续跑\",{\"1\":{\"41\":1}}],[\"因为直到现在为止还没有最好的垃圾收集器出现\",{\"1\":{\"35\":1}}],[\"因为虚拟机栈是对应一个线程的\",{\"1\":{\"11\":1}}],[\"因为编译执行需要识别热点代码\",{\"1\":{\"5\":1}}],[\"因此可以索引该字段的开始部分\",{\"1\":{\"232\":1}}],[\"因此每个员工可以被惟一区分\",{\"1\":{\"211\":1}}],[\"因此很可能查询刚建立缓存\",{\"1\":{\"197\":1}}],[\"因此mysql不选择nlj\",{\"1\":{\"150\":1}}],[\"因此mysql需要从头开始扫描b+树的所有叶子节点\",{\"1\":{\"150\":1}}],[\"因此inner\",{\"1\":{\"148\":1}}],[\"因此走索引查询出t1表中的数据\",{\"1\":{\"148\":1}}],[\"因此查询用到了name索引\",{\"1\":{\"131\":1}}],[\"因此jvm引入安全区域\",{\"1\":{\"74\":1}}],[\"因此gc也不是随时都能立即触发的\",{\"1\":{\"73\":1}}],[\"因此zgc无法使用指针压缩\",{\"1\":{\"66\":1}}],[\"因此zgc可以支持2^42=4tb内存\",{\"1\":{\"66\":1}}],[\"因此\",{\"1\":{\"12\":1,\"146\":1,\"196\":1,\"197\":1}}],[\"因此他不会逃逸\",{\"1\":{\"9\":1}}],[\"因此也被称为服务端编译器\",{\"1\":{\"7\":1}}],[\"因此也被称为客户端编译器\",{\"1\":{\"7\":1}}],[\"因此在hotspot中\",{\"1\":{\"5\":1}}],[\"在不同场景使用不同的排序模式\",{\"1\":{\"240\":1}}],[\"在不同的表中存储特定的列\",{\"1\":{\"222\":1}}],[\"在阿里的编码规范中\",{\"1\":{\"232\":1}}],[\"在选择列类型时\",{\"1\":{\"230\":1}}],[\"在定义列时\",{\"1\":{\"230\":1}}],[\"在具体实现上\",{\"1\":{\"223\":1}}],[\"在使用缓存表和汇总表时\",{\"1\":{\"222\":1}}],[\"在检索列表时\",{\"1\":{\"216\":1}}],[\"在第一范式的基础上进一步满足更多规范要求的称为第二范式\",{\"1\":{\"209\":1}}],[\"在擦除前需要将内容刷到磁盘中\",{\"1\":{\"205\":1}}],[\"在工程实现上\",{\"1\":{\"200\":1}}],[\"在开始执行之前\",{\"1\":{\"199\":1}}],[\"在可重复读的隔离级别下\",{\"1\":{\"178\":1}}],[\"在session\",{\"1\":{\"177\":1}}],[\"在b客户端修改了数据后\",{\"1\":{\"173\":1}}],[\"在a客户端中\",{\"1\":{\"173\":1}}],[\"在a事务数据根据之前读取的修改后\",{\"1\":{\"165\":1}}],[\"在客户端b中\",{\"1\":{\"173\":1}}],[\"在获取驱动表数据时mysql扫描了t2表数据100行\",{\"1\":{\"149\":1}}],[\"在where和order\",{\"1\":{\"137\":1}}],[\"在排序中被优化\",{\"1\":{\"131\":1}}],[\"在extra中并未出现using\",{\"1\":{\"131\":1}}],[\"在绝大多数情况来看\",{\"1\":{\"128\":1}}],[\"在mysql5\",{\"1\":{\"127\":1,\"206\":1}}],[\"在表记录不多的情况下会选择全表扫描\",{\"0\":{\"126\":1}}],[\"在进行范围查询的时候\",{\"1\":{\"106\":1}}],[\"在\",{\"1\":{\"105\":1,\"115\":1}}],[\"在某些情况下\",{\"1\":{\"99\":1}}],[\"在每个事务修改完之后\",{\"1\":{\"188\":1}}],[\"在每个gc周期开始\",{\"1\":{\"66\":1}}],[\"在每次gc后eden区使用一般会大幅减少\",{\"1\":{\"92\":1}}],[\"在输出信息前加上一个timestamp列\",{\"1\":{\"88\":1}}],[\"在界面右方点击打开本地的hprof文件进行分析\",{\"1\":{\"81\":1}}],[\"在这个区域内进行gc都是安全的\",{\"1\":{\"74\":1}}],[\"在这个期间由于对象分配速率很高\",{\"1\":{\"69\":1}}],[\"在耗尽之前触发gc\",{\"1\":{\"70\":1}}],[\"在堆内存达到10\",{\"1\":{\"70\":1}}],[\"在堆内为每个线程划分出一块单独区域\",{\"1\":{\"16\":1}}],[\"在标记和移动阶段\",{\"1\":{\"68\":1}}],[\"在标记完成后统一回收所有被标记的对象\",{\"1\":{\"34\":1}}],[\"在半导体现有的发展情况下\",{\"1\":{\"62\":1}}],[\"在保证他的年轻代gc别太频繁的同时\",{\"1\":{\"58\":1}}],[\"在混合回收的时候\",{\"1\":{\"57\":1}}],[\"在一般的业务场景下\",{\"1\":{\"197\":1}}],[\"在一般应用中\",{\"1\":{\"11\":1}}],[\"在一个产品表中\",{\"1\":{\"116\":1}}],[\"在一次回收过程中指定做几次筛选回收\",{\"1\":{\"57\":1}}],[\"在下次垃圾回收时再处理\",{\"1\":{\"52\":1}}],[\"在回收时间有限情况下\",{\"1\":{\"52\":1}}],[\"在g1中\",{\"1\":{\"52\":1}}],[\"在系统运行中\",{\"1\":{\"52\":1}}],[\"在新生代可以引入记录集\",{\"1\":{\"48\":1}}],[\"在新生代做gcroots可达性扫描过程中可能会碰到跨代引用的对象\",{\"1\":{\"48\":1}}],[\"在并发扫描结束之后\",{\"1\":{\"43\":1}}],[\"在并发标记过程中\",{\"1\":{\"42\":1}}],[\"在并发标记的过程中\",{\"1\":{\"41\":1}}],[\"在并发标记和并发清理阶段又产生垃圾\",{\"1\":{\"39\":1}}],[\"在重新标记的时候多线程执行\",{\"1\":{\"40\":1}}],[\"在cms\",{\"1\":{\"40\":1}}],[\"在注重吞吐量以及\",{\"1\":{\"37\":1}}],[\"在寄存器中是35位\",{\"1\":{\"19\":1}}],[\"在64位系统中\",{\"1\":{\"19\":1}}],[\"在分配时查找一块空间足够的可用内存\",{\"1\":{\"16\":1}}],[\"在加载完成便可以确定\",{\"1\":{\"16\":1}}],[\"在触发了jit时\",{\"1\":{\"12\":1}}],[\"在它的append和tostring方法都加了sychronized同步锁\",{\"1\":{\"12\":1}}],[\"在内存不紧张的情况下\",{\"1\":{\"8\":1}}],[\"在编程中\",{\"1\":{\"8\":1}}],[\"在编译过程中\",{\"1\":{\"7\":2}}],[\"在编译时不可避免的需要进行编译优化\",{\"1\":{\"7\":1}}],[\"在编译执行识别热点代码的过程中\",{\"1\":{\"5\":1}}],[\"在jdk的jdk1\",{\"1\":{\"223\":1}}],[\"在jdk8中\",{\"1\":{\"8\":1}}],[\"在jvm中32位地址可以支持4g内存\",{\"1\":{\"19\":1}}],[\"在jvm运行参数确定的前提下\",{\"1\":{\"6\":1}}],[\"在解释时\",{\"1\":{\"7\":1}}],[\"在hotspot虚拟机中\",{\"1\":{\"7\":1,\"18\":1}}],[\"在hotspot中使方法调用计数器和回边计数器来实现\",{\"1\":{\"6\":1}}],[\"在字节码中遇到的向后跳转的指令称之为回边\",{\"1\":{\"6\":1}}],[\"在应用启动过程中发生大量fullgc\",{\"1\":{\"0\":1}}],[\"兼顾效率和运行成本\",{\"1\":{\"5\":1}}],[\"而双路排序只会把主键和需要排序的字段放到\",{\"1\":{\"240\":1}}],[\"而order\",{\"1\":{\"233\":1}}],[\"而这些随机io带来的性能开销比较大\",{\"1\":{\"228\":1}}],[\"而这个节点上存储了\",{\"1\":{\"105\":1}}],[\"而在某个扫描区间中的二级索引记录的主键值是无序的\",{\"1\":{\"228\":1}}],[\"而大量的表关联很多的时候非常影响查询的性能\",{\"1\":{\"213\":1}}],[\"而name和price作为二级索引\",{\"1\":{\"116\":1}}],[\"而当我们不是顺序插入的时候\",{\"1\":{\"115\":1}}],[\"而如果使用\",{\"1\":{\"114\":1}}],[\"而如果我们使用二叉树来存储\",{\"1\":{\"98\":1}}],[\"而每次加载一页的数据\",{\"1\":{\"107\":1}}],[\"而\",{\"1\":{\"103\":1,\"104\":2,\"106\":2,\"116\":1}}],[\"而最主要的问题是\",{\"1\":{\"99\":1}}],[\"而早期的\",{\"1\":{\"99\":1}}],[\"而减少磁盘\",{\"1\":{\"98\":1}}],[\"而我们在实际的缓冲中间件redis等的使用\",{\"1\":{\"223\":1}}],[\"而我们所能想到的优化\",{\"1\":{\"98\":1}}],[\"而我们的数据库查询的时候每次都要进行磁盘\",{\"1\":{\"98\":1}}],[\"而添加分代或者thread\",{\"1\":{\"69\":1}}],[\"而不必等待整个堆中所有指向该region的引用都被修正后才能清理\",{\"1\":{\"67\":1}}],[\"而不是单纯只看表内的数据量\",{\"1\":{\"151\":1}}],[\"而不是单纯的使用其中一种模式\",{\"1\":{\"5\":1}}],[\"而不是插入到已有的节点再进行分裂和平衡\",{\"1\":{\"115\":1}}],[\"而不是让大对象直接进入老年代的region中\",{\"1\":{\"52\":1}}],[\"而zgc的gc信息保存在指针中\",{\"1\":{\"66\":1}}],[\"而root数量和堆大小是没有任何关系的\",{\"1\":{\"62\":1}}],[\"而cms对增量引用的根对象会做深度扫描\",{\"1\":{\"47\":1}}],[\"而老年代的对象存活几率是比较高的\",{\"1\":{\"32\":1}}],[\"而是专门做了优化\",{\"1\":{\"155\":1}}],[\"而是会自动进行平衡\",{\"1\":{\"101\":1}}],[\"而是原子类型\",{\"1\":{\"68\":1}}],[\"而是让所有存活的对象向一端移动\",{\"1\":{\"35\":1}}],[\"而是使用标量替换的方法进\",{\"1\":{\"20\":1}}],[\"而是默认采用了混合模式\",{\"1\":{\"5\":1}}],[\"而stringbuilder则没加\",{\"1\":{\"12\":1}}],[\"而stringbuffer是线程安全的\",{\"1\":{\"12\":1}}],[\"而瘦身的方式\",{\"1\":{\"11\":1}}],[\"而栈是一个非常小的内存结构\",{\"1\":{\"11\":1}}],[\"而堆内存是对应整个java进程的\",{\"1\":{\"11\":1}}],[\"而改为直接创建它的若干个被这个方法使用的成员变量来代替\",{\"1\":{\"10\":1}}],[\"而test2方法中的t就逃逸到其他方法了\",{\"1\":{\"9\":1}}],[\"而进行jit时\",{\"1\":{\"7\":1}}],[\"而且面目可憎\",{\"1\":{\"209\":1}}],[\"而且整型数据占用的内存空间更小\",{\"1\":{\"114\":1}}],[\"而且业务是跑批类型\",{\"1\":{\"69\":1}}],[\"而且不需要stw\",{\"1\":{\"68\":1}}],[\"而且停顿用户线程将大幅提高收集效率\",{\"1\":{\"52\":1}}],[\"而且一个大对象如果太大\",{\"1\":{\"52\":1}}],[\"而且没有额外的空间对它进行分配担保\",{\"1\":{\"32\":1}}],[\"而且\",{\"1\":{\"8\":1,\"102\":1,\"107\":1}}],[\"而且想要编译出优化程度更高的代码\",{\"1\":{\"7\":1}}],[\"而且在class编译时会对原文件进行一定优化\",{\"1\":{\"3\":1}}],[\"故而退而求其次\",{\"1\":{\"5\":1}}],[\"后续查询既可不用加工数据\",{\"1\":{\"222\":1}}],[\"后续则会自动调整\",{\"1\":{\"40\":1}}],[\"后的单词识别为表名\",{\"1\":{\"198\":1}}],[\"后面的字符串识别为列名等等\",{\"1\":{\"198\":1}}],[\"后面3行代码都不需要加读屏障\",{\"1\":{\"68\":1}}],[\"后面会介绍到\",{\"1\":{\"38\":1}}],[\"后仍然能够存活\",{\"1\":{\"22\":1}}],[\"后可以看到以下的执行日志\",{\"1\":{\"8\":1}}],[\"后执行的方式称为编译执行\",{\"1\":{\"5\":1}}],[\"后端编译\",{\"0\":{\"4\":1}}],[\"将它们的主键值排好序之后再统一执行回表操作\",{\"1\":{\"228\":1}}],[\"将计数类操作与业务解耦\",{\"1\":{\"223\":1}}],[\"将经常需要用到的汇总且结果不变的数据\",{\"1\":{\"222\":1}}],[\"将本来需要连表查询的语句\",{\"1\":{\"222\":1}}],[\"将更新后数据写入\",{\"1\":{\"202\":2}}],[\"将更新数据的旧值写入\",{\"1\":{\"202\":1}}],[\"将进入优化器\",{\"1\":{\"198\":1}}],[\"将结果存储在缓存中\",{\"1\":{\"197\":1}}],[\"将join\",{\"1\":{\"150\":1}}],[\"将employees\",{\"1\":{\"126\":1}}],[\"将表记录单独存储在\",{\"1\":{\"113\":1}}],[\"将所有的叶子节点连了起来\",{\"1\":{\"104\":1}}],[\"将同一份物理内存映射为了三份虚拟内存\",{\"1\":{\"69\":1}}],[\"将创建大量的新对象\",{\"1\":{\"69\":1}}],[\"将这些region组成重分配集\",{\"1\":{\"65\":1}}],[\"将一个region中的存活对象复制到另一个region中\",{\"1\":{\"52\":1}}],[\"将a新的成员变量引用对象d记录下来\",{\"1\":{\"46\":1}}],[\"将b原来成员变量的引用对象d记录下来\",{\"1\":{\"45\":1}}],[\"将白色对象直接标记为黑色\",{\"1\":{\"43\":1}}],[\"将对象用weakreference软引用类型的对象包裹\",{\"1\":{\"27\":1}}],[\"将对象用softreference软引用类型的对象包裹\",{\"1\":{\"27\":1}}],[\"将对象拆分后\",{\"1\":{\"10\":1}}],[\"将\",{\"1\":{\"26\":1,\"115\":1,\"198\":2,\"202\":2}}],[\"将被移动到\",{\"1\":{\"22\":1}}],[\"将该对象成员变量分解若干个被这个方法使用的成员变量所代替\",{\"1\":{\"20\":1}}],[\"将foo\",{\"1\":{\"8\":1}}],[\"将那些运行频率高的热点代码进行提前编译\",{\"1\":{\"5\":1}}],[\"将那些字节码指令\",{\"1\":{\"5\":1}}],[\"将class的字节码文件解释编译成机器码供计算机执行\",{\"1\":{\"4\":1}}],[\"join要慎重使用\",{\"1\":{\"151\":1}}],[\"join已经默认指定了驱动表\",{\"1\":{\"151\":1}}],[\"join和right\",{\"1\":{\"151\":1}}],[\"join形式\",{\"1\":{\"151\":1}}],[\"join方法只适用与inner\",{\"1\":{\"151\":1}}],[\"join指定驱动表\",{\"1\":{\"151\":1}}],[\"join通常情况下mysql执行引擎会优化挑选小表为驱动表\",{\"1\":{\"151\":1}}],[\"join的表尽量不要超过三张\",{\"1\":{\"151\":1}}],[\"join写在左边的表不一定是驱动表\",{\"1\":{\"148\":1}}],[\"join关联优化\",{\"0\":{\"147\":1}}],[\"join\",{\"0\":{\"148\":1,\"149\":1},\"1\":{\"129\":6,\"146\":1,\"148\":1,\"149\":2,\"150\":1,\"151\":3,\"199\":1}}],[\"json=on\",{\"1\":{\"129\":1}}],[\"jstat命令可以查看堆内存各部分的使用量\",{\"1\":{\"88\":1}}],[\"jstat\",{\"0\":{\"88\":1},\"1\":{\"88\":1,\"89\":1,\"90\":1,\"92\":1}}],[\"jstack找出占用cpu最高的线程\",{\"0\":{\"84\":1}}],[\"jstack\",{\"0\":{\"82\":1,\"83\":1}}],[\"jinfo\",{\"0\":{\"85\":1,\"86\":1,\"87\":1}}],[\"jit就能针对该对象进行优化\",{\"1\":{\"9\":1}}],[\"jit\",{\"1\":{\"8\":1}}],[\"jit会运用很多经典的编译优化技术来实现对字节码指令的优化\",{\"1\":{\"7\":1}}],[\"jhsdb\",{\"1\":{\"80\":1}}],[\"jmap\",{\"0\":{\"78\":1,\"79\":1,\"80\":1},\"1\":{\"69\":1,\"79\":2,\"80\":2,\"81\":1}}],[\"jfokus\",{\"1\":{\"61\":1}}],[\"j\",{\"1\":{\"28\":2}}],[\"jdk\",{\"1\":{\"71\":2}}],[\"jdk17查看堆内存信息\",{\"1\":{\"80\":1}}],[\"jdk11中删除了cms垃圾收集器\",{\"1\":{\"71\":1}}],[\"jdk13就把最大支持堆内存从4t扩大到了16t\",{\"1\":{\"68\":1}}],[\"jdk1\",{\"1\":{\"24\":1,\"36\":1}}],[\"jdk8查看堆内存信息\",{\"1\":{\"80\":1}}],[\"jdk8\",{\"1\":{\"10\":1,\"37\":1,\"88\":1}}],[\"jdk8中提供的\",{\"1\":{\"7\":1}}],[\"java的引用类型一般分为四种\",{\"1\":{\"27\":1}}],[\"java对象一般在堆上进行分配\",{\"1\":{\"20\":1}}],[\"java中的int\",{\"1\":{\"10\":1}}],[\"java\",{\"1\":{\"8\":1,\"29\":2,\"32\":1,\"35\":1,\"61\":2,\"83\":1}}],[\"java被\",{\"1\":{\"5\":1}}],[\"jvm内存分析工具\",{\"1\":{\"81\":1}}],[\"jvm内存溢出排查\",{\"1\":{\"81\":1}}],[\"jvm内存模型\",{\"0\":{\"0\":1}}],[\"jvm工具详解\",{\"0\":{\"76\":1}}],[\"jvm就可以安全的进行一些操作\",{\"1\":{\"73\":1}}],[\"jvm是如何判断对象被移动过呢\",{\"1\":{\"68\":1}}],[\"jvm源码里target\",{\"1\":{\"52\":1}}],[\"jvm目标是不超过2048个region\",{\"1\":{\"52\":1}}],[\"jvm仅在第一次使用设定值\",{\"1\":{\"40\":1}}],[\"jvm的垃圾收集器\",{\"0\":{\"31\":1,\"51\":1}}],[\"jvm通过逃逸分析确定该对象不会被外部访问\",{\"1\":{\"20\":1}}],[\"jvm会不停的给年轻代增加更多的region\",{\"1\":{\"52\":1}}],[\"jvm会计算老年代剩余可用空间\",{\"1\":{\"24\":1}}],[\"jvm会强制使用64位\",{\"1\":{\"19\":1}}],[\"jvm会默认去掉高位的0\",{\"1\":{\"19\":1}}],[\"jvm会在编译时将这个无用的锁消除掉\",{\"1\":{\"12\":1}}],[\"jvm默认启用了指针压缩功能\",{\"1\":{\"19\":1}}],[\"jvm默认开启\",{\"1\":{\"16\":1}}],[\"jvm使用cas方式分配内存\",{\"1\":{\"16\":1}}],[\"jvm对象创建及内存分配机制\",{\"0\":{\"14\":1}}],[\"jvm虚拟机就可以将deadcode移除来进行优化\",{\"1\":{\"8\":1}}],[\"jvm也能保证一个不错的执行效率\",{\"1\":{\"7\":1}}],[\"jvm只负责进行翻译和执行\",{\"1\":{\"7\":1}}],[\"jvm为了加快运行速度\",{\"1\":{\"5\":1}}],[\"jvm执行引擎如何执行一段java代码已经在class文件中确定了\",{\"1\":{\"5\":1}}],[\"jvm在执行时\",{\"1\":{\"4\":1}}],[\"jvm\",{\"0\":{\"89\":1,\"243\":1},\"1\":{\"4\":4,\"8\":1,\"11\":1,\"84\":1},\"2\":{\"1\":1,\"13\":1,\"30\":1,\"50\":1,\"75\":1,\"96\":1}}],[\"些直接面向本地机器指令编程的语言的\",{\"1\":{\"5\":1}}],[\"cnf文件里配置\",{\"1\":{\"205\":1}}],[\"cnf\",{\"1\":{\"197\":2,\"206\":1}}],[\"city=xx\",{\"1\":{\"139\":3}}],[\"city\",{\"1\":{\"139\":5}}],[\"check\",{\"1\":{\"205\":4}}],[\"changed\",{\"1\":{\"129\":1}}],[\"charset=utf8\",{\"1\":{\"121\":1}}],[\"char\",{\"1\":{\"79\":1}}],[\"chosen\",{\"1\":{\"129\":4}}],[\"current\",{\"1\":{\"121\":1,\"181\":1}}],[\"currenttimemillis\",{\"1\":{\"8\":2,\"12\":4}}],[\"csdn博客\",{\"1\":{\"81\":1}}],[\"create\",{\"1\":{\"121\":2,\"201\":1}}],[\"cr\",{\"1\":{\"61\":1}}],[\"clause\",{\"1\":{\"129\":7}}],[\"classloader\",{\"1\":{\"29\":1}}],[\"class文件中已经保留了每一行java代码对应的字节码\",{\"1\":{\"5\":1}}],[\"class\",{\"1\":{\"4\":1,\"8\":2,\"12\":1,\"25\":2,\"28\":1,\"29\":1,\"41\":5,\"79\":1,\"83\":1,\"84\":1,\"88\":1}}],[\"click\",{\"1\":{\"61\":1}}],[\"cleanup\",{\"1\":{\"52\":1}}],[\"cause\",{\"1\":{\"129\":4}}],[\"cache关键词时才缓存\",{\"1\":{\"197\":1}}],[\"cache\",{\"1\":{\"124\":2,\"197\":5,\"205\":3}}],[\"call\",{\"1\":{\"121\":1}}],[\"catch\",{\"1\":{\"83\":2}}],[\"card\",{\"1\":{\"48\":1}}],[\"cardtable\",{\"1\":{\"48\":1}}],[\"case\",{\"1\":{\"131\":7}}],[\"case1\",{\"1\":{\"131\":1}}],[\"cas\",{\"1\":{\"16\":1}}],[\"count的性能很高\",{\"1\":{\"157\":1}}],[\"count\",{\"0\":{\"153\":1},\"1\":{\"153\":7,\"154\":2,\"155\":2,\"231\":2,\"232\":28}}],[\"cost\",{\"1\":{\"129\":7}}],[\"control\",{\"1\":{\"187\":1}}],[\"considered\",{\"1\":{\"129\":4}}],[\"constant\",{\"1\":{\"129\":1}}],[\"conditions\",{\"1\":{\"129\":8}}],[\"condition\",{\"1\":{\"127\":1,\"129\":10,\"131\":1}}],[\"concurrency\",{\"1\":{\"187\":1}}],[\"concurrent\",{\"1\":{\"39\":2,\"52\":1,\"65\":4}}],[\"concat\",{\"1\":{\"121\":1}}],[\"concgcthreads\",{\"1\":{\"40\":1}}],[\"copy\",{\"1\":{\"126\":2,\"127\":1}}],[\"copy的表\",{\"1\":{\"126\":1}}],[\"columns\",{\"1\":{\"129\":2}}],[\"col1=30\",{\"1\":{\"111\":1}}],[\"col1\",{\"1\":{\"100\":2,\"111\":1}}],[\"col2=89\",{\"1\":{\"98\":1}}],[\"col2\",{\"1\":{\"98\":1}}],[\"color了\",{\"1\":{\"68\":1}}],[\"color的依据是什么呢\",{\"1\":{\"68\":1}}],[\"color还是good\",{\"1\":{\"68\":1}}],[\"color\",{\"1\":{\"68\":2}}],[\"colored\",{\"1\":{\"66\":1}}],[\"collection\",{\"1\":{\"52\":1}}],[\"commit=1\",{\"1\":{\"205\":1}}],[\"commit参数值\",{\"1\":{\"205\":2}}],[\"commit​\",{\"1\":{\"205\":1}}],[\"commit\",{\"1\":{\"202\":1,\"205\":1}}],[\"committed\",{\"1\":{\"172\":1,\"174\":1}}],[\"comment=\",{\"1\":{\"121\":1}}],[\"comment\",{\"1\":{\"121\":4}}],[\"command命令查看rss发现也差不多占用了5g\",{\"1\":{\"69\":1}}],[\"com\",{\"1\":{\"63\":1,\"84\":1}}],[\"computation\",{\"1\":{\"129\":2}}],[\"compute\",{\"1\":{\"84\":2}}],[\"compiler\",{\"1\":{\"88\":1}}],[\"compilethreshold​来设定\",{\"1\":{\"6\":1}}],[\"compact\",{\"1\":{\"61\":1}}],[\"compdemo\",{\"1\":{\"8\":5}}],[\"cpu会飙高\",{\"1\":{\"84\":1}}],[\"cpu或者cpu核心\",{\"1\":{\"52\":1}}],[\"cpu\",{\"1\":{\"37\":5,\"69\":1,\"166\":1}}],[\"cms回收阶段是跟用户线程一起并发执行的\",{\"1\":{\"52\":1}}],[\"cms就一块老年代区域\",{\"1\":{\"47\":1}}],[\"cms用增量更新\",{\"1\":{\"47\":1}}],[\"cmsinitiatingoccupancyfraction设定的值\",{\"1\":{\"40\":1}}],[\"cmsinitiatingoccupancyfraction\",{\"1\":{\"40\":1}}],[\"cmsfullgcsbeforecompaction\",{\"1\":{\"40\":1}}],[\"cms\",{\"1\":{\"36\":1,\"37\":1,\"38\":2,\"39\":2,\"47\":1,\"52\":1}}],[\"cms收集器默认6岁\",{\"1\":{\"22\":1}}],[\"c2编译器会对字节码进行更加激进的优化\",{\"1\":{\"7\":1}}],[\"c2编译器会更加激进的对字节码进行优化\",{\"1\":{\"7\":1}}],[\"c2相当于一个高级编译\",{\"1\":{\"7\":1}}],[\"c1会对字节码做简单和可靠的优化\",{\"1\":{\"7\":1}}],[\"c1相当于一个初级编译\",{\"1\":{\"7\":1}}],[\"c++开发者吐槽执⾏速度慢的根源\",{\"1\":{\"5\":1}}],[\"c++那\",{\"1\":{\"5\":1}}],[\"c\",{\"0\":{\"117\":1},\"1\":{\"5\":1,\"41\":4,\"79\":1,\"84\":2}}],[\"和字段\",{\"1\":{\"240\":1}}],[\"和主键\",{\"1\":{\"240\":2}}],[\"和第五范式\",{\"1\":{\"209\":1}}],[\"和更新\",{\"1\":{\"209\":1}}],[\"和已创建的最大的事务id组成\",{\"1\":{\"188\":1}}],[\"和悲观锁\",{\"1\":{\"167\":1}}],[\"和case\",{\"1\":{\"131\":1}}],[\"和预想的差不多\",{\"1\":{\"69\":1}}],[\"和linux检查出的内存占用有出入\",{\"1\":{\"69\":1}}],[\"和marked1配合用于辅助gc\",{\"1\":{\"66\":1}}],[\"和最终标记\",{\"1\":{\"65\":1}}],[\"和g1一样\",{\"1\":{\"65\":1}}],[\"和原始快照\",{\"1\":{\"43\":1}}],[\"和执行构造方法\",{\"1\":{\"19\":1}}],[\"和对齐填充\",{\"1\":{\"18\":1}}],[\"和foo\",{\"1\":{\"8\":1}}],[\"和\",{\"0\":{\"113\":1},\"1\":{\"5\":2,\"7\":1,\"25\":1,\"34\":1,\"37\":1,\"52\":1,\"105\":2,\"106\":1,\"129\":1,\"204\":1,\"205\":1}}],[\"称之为回表\",{\"1\":{\"116\":1}}],[\"称之为解释执行\",{\"1\":{\"5\":1}}],[\"称为\",{\"1\":{\"48\":1}}],[\"称为后端编译\",{\"1\":{\"4\":1}}],[\"⾄于编译的过程\",{\"1\":{\"4\":1}}],[\"就行了\",{\"1\":{\"209\":1}}],[\"就打开表继续执行\",{\"1\":{\"200\":1}}],[\"就知道你要做什么了\",{\"1\":{\"199\":1}}],[\"就收到\",{\"1\":{\"198\":1}}],[\"就由连接器进行处理\",{\"1\":{\"196\":1}}],[\"就算有其他事务对数据进行修改也不影响该事务内的查询结果\",{\"1\":{\"187\":1}}],[\"就用常量1做统计\",{\"1\":{\"154\":1}}],[\"就查下受欢迎度较高的女性\",{\"1\":{\"139\":1}}],[\"就保留小部分数据下来基于磁盘文件进行order\",{\"1\":{\"139\":1}}],[\"就不需要频繁的移动和修改叶子节点的顺序\",{\"1\":{\"115\":1}}],[\"就需要分析传过来的\",{\"1\":{\"198\":1}}],[\"就需要真正执行\",{\"1\":{\"198\":1}}],[\"就需要修改整个叶子节点的顺序\",{\"1\":{\"115\":1}}],[\"就需要逐位去比较大小\",{\"1\":{\"114\":1}}],[\"就能查询到数据\",{\"1\":{\"99\":1}}],[\"就能知道当前对象是bad\",{\"1\":{\"68\":1}}],[\"就只剩44位了\",{\"1\":{\"68\":1}}],[\"就只能在运行这一行代码时才能确定\",{\"1\":{\"8\":1}}],[\"就将这个要删除的引用记录下来\",{\"1\":{\"43\":1}}],[\"就将这个新插入的引用记录下来\",{\"1\":{\"43\":1}}],[\"就将还存活的对象复制到另一块去\",{\"1\":{\"33\":1}}],[\"就减轻了垃圾回收的压力\",{\"1\":{\"20\":1}}],[\"就称之为逃逸\",{\"1\":{\"20\":1}}],[\"就称之为标量替换\",{\"1\":{\"10\":1}}],[\"就称之为线程逃逸\",{\"1\":{\"9\":1}}],[\"就无法进行内联\",{\"1\":{\"8\":1}}],[\"就是幻读\",{\"1\":{\"165\":1}}],[\"就是驱动表\",{\"1\":{\"151\":1}}],[\"就是说\",{\"1\":{\"136\":1}}],[\"就是值比较多的字段\",{\"1\":{\"135\":1}}],[\"就是索引和数据分开存储\",{\"1\":{\"113\":1}}],[\"就是索引和数据存储在一起的索引\",{\"1\":{\"113\":1}}],[\"就是redis加上jvm级缓存\",{\"1\":{\"95\":1}}],[\"就是根据上一段提到的colored\",{\"1\":{\"68\":1}}],[\"就是利用上面提到的颜色指针\",{\"1\":{\"68\":1}}],[\"就是当灰色对象要删除指向白色对象的引用关系时\",{\"1\":{\"43\":1}}],[\"就是当黑色对象插入新的指向白色对象的引用关系时\",{\"1\":{\"43\":1}}],[\"就是分析对象动态作用域\",{\"1\":{\"20\":1}}],[\"就是去掉对象的mark标志位中的补充信息\",{\"1\":{\"11\":1}}],[\"就是死代码\",{\"1\":{\"8\":1}}],[\"就是记录统计方法的调用次数\",{\"1\":{\"6\":1}}],[\"就看不到方法内联了\",{\"1\":{\"8\":1}}],[\"就成为编译优化技术\",{\"1\":{\"7\":1}}],[\"就可以执行\",{\"1\":{\"197\":1}}],[\"就可以访问到要查询的数据了\",{\"1\":{\"105\":1}}],[\"就可以找到\",{\"1\":{\"105\":1}}],[\"就可以直接进入老年代了\",{\"1\":{\"23\":1}}],[\"就可以认为是热点代码\",{\"1\":{\"6\":1}}],[\"就可以提交到\",{\"1\":{\"4\":1}}],[\"就会根据该记录的主键值执行回表操作\",{\"1\":{\"228\":1}}],[\"就会把\",{\"1\":{\"205\":1}}],[\"就会返回没有权限的错误\",{\"1\":{\"200\":1}}],[\"就会从缓存中获取数据进行返回\",{\"1\":{\"197\":1}}],[\"就会产生using\",{\"1\":{\"131\":1}}],[\"就会创建新的节点\",{\"1\":{\"115\":1}}],[\"就会使用这个主键索引来构建\",{\"1\":{\"114\":1}}],[\"就会自动进行一次平衡\",{\"1\":{\"101\":1}}],[\"就会将该红节点转化成黑节点\",{\"1\":{\"101\":1}}],[\"就会进入老年代中\",{\"1\":{\"58\":1}}],[\"就会被放入humongous中\",{\"1\":{\"52\":1}}],[\"就会被晋升到老年代中\",{\"1\":{\"22\":1}}],[\"就会记录一下该方法的调用次数\",{\"1\":{\"6\":1}}],[\"就会触发即时编译\",{\"1\":{\"6\":1}}],[\"就适当降低该值\",{\"1\":{\"0\":1}}],[\"⽂件\",{\"1\":{\"4\":1}}],[\"规范的\",{\"1\":{\"4\":1}}],[\"只把根节点放到了内存中\",{\"1\":{\"99\":1}}],[\"只需要\",{\"1\":{\"98\":1}}],[\"只需要付出少量对象的复制成本就可以完成每次垃圾收集\",{\"1\":{\"32\":1}}],[\"只能边交流边goole\",{\"1\":{\"69\":1}}],[\"只是需要再根据主键回到原表取数据\",{\"1\":{\"240\":1}}],[\"只是需要等到下一轮垃圾回收中才被清除\",{\"1\":{\"42\":1}}],[\"只是简单标记\",{\"1\":{\"47\":1}}],[\"只是根据对象存活周期的不同将内存分为几块\",{\"1\":{\"32\":1}}],[\"只使用设定的回收阈值\",{\"1\":{\"40\":1}}],[\"只有一行数据\",{\"1\":{\"223\":1}}],[\"只有一个main线程顺序执行代码\",{\"1\":{\"12\":1}}],[\"只有再次建立连接\",{\"1\":{\"196\":1}}],[\"只有当执行了修改innodb表的语句时\",{\"1\":{\"189\":1}}],[\"只有当写锁释放后\",{\"1\":{\"170\":1}}],[\"只有当读锁释放后\",{\"1\":{\"170\":1}}],[\"只有叶子节点存储了索引和数据\",{\"1\":{\"104\":1}}],[\"只有1\",{\"1\":{\"69\":1}}],[\"只有它能与\",{\"1\":{\"38\":1}}],[\"只要一个大对象超过了1m\",{\"1\":{\"52\":1}}],[\"只要筛选本收集区的卡表中变脏的元素加入gcroots里\",{\"1\":{\"48\":1}}],[\"只要有一个对象的字段存在跨代指针\",{\"1\":{\"48\":1}}],[\"只要重新与引用链上的任何的一个对象建立关联即可\",{\"1\":{\"28\":1}}],[\"只要能够编译出满⾜\",{\"1\":{\"4\":1}}],[\"只受限于本地物理内存大小\",{\"1\":{\"0\":1}}],[\"这会使得这些事务只能串行执行\",{\"1\":{\"223\":1}}],[\"这套机制看起来复杂\",{\"1\":{\"203\":1}}],[\"这条记录上都有一个全局的互斥锁\",{\"1\":{\"223\":1}}],[\"这条主要时数据层面的\",{\"1\":{\"164\":1}}],[\"这条是操作层面的\",{\"1\":{\"164\":1}}],[\"这可能会产生脏读\",{\"1\":{\"163\":1}}],[\"这可以简化理解为\",{\"1\":{\"43\":1}}],[\"这其实是不对的\",{\"1\":{\"133\":1}}],[\"这无疑是增加了磁盘\",{\"1\":{\"102\":1}}],[\"这和全表扫描基本没什么区别\",{\"1\":{\"100\":1}}],[\"这就进入了\",{\"1\":{\"197\":1}}],[\"这就使得每一页上能查询出更多的数据记录\",{\"1\":{\"107\":1}}],[\"这就使得每一页只能加载较少的数据记录\",{\"1\":{\"107\":1}}],[\"这就导致数据量大的时候\",{\"1\":{\"101\":1}}],[\"这就是为什么\",{\"1\":{\"107\":1}}],[\"这就是\",{\"1\":{\"100\":1}}],[\"这就是一种内存泄漏\",{\"1\":{\"95\":1}}],[\"这就要看具体的实现策略了\",{\"1\":{\"27\":1}}],[\"这些问题的本质就是数据的并发问题\",{\"1\":{\"163\":1}}],[\"这些事务可能会对同一条数据进行增删改等操作\",{\"1\":{\"163\":1}}],[\"这些字段好像基数都不大\",{\"1\":{\"139\":1}}],[\"这些增长的对象就是每次young\",{\"1\":{\"92\":1}}],[\"这些只能等到下次gc才能回收的对象就是浮动垃圾\",{\"1\":{\"69\":1}}],[\"这些对象很难进入当次gc\",{\"1\":{\"69\":1}}],[\"这些代替的成员变量在栈帧或寄存器上分配空间\",{\"1\":{\"20\":1}}],[\"这使得理论上只要还有一个空闲region\",{\"1\":{\"67\":1}}],[\"这使得在大部分情况下\",{\"1\":{\"7\":1}}],[\"这次访问将会被预置的内存屏障\",{\"1\":{\"65\":1}}],[\"这是g1相对于cms的另一个大优势\",{\"1\":{\"52\":1}}],[\"这是严重bug\",{\"1\":{\"43\":1}}],[\"这是百分比\",{\"1\":{\"40\":1}}],[\"这也预示着虽然名字叫作\",{\"1\":{\"64\":1}}],[\"这也就是它的名字garbage\",{\"1\":{\"52\":1}}],[\"这也算是浮动垃圾的一部分\",{\"1\":{\"42\":1}}],[\"这也是长久以前\",{\"1\":{\"5\":1}}],[\"这部分对象在标记和回收期间可能也会变为垃圾\",{\"1\":{\"42\":1}}],[\"这部分本应该回收但是没有回收到的内存\",{\"1\":{\"42\":1}}],[\"这里写的相对路径\",{\"1\":{\"206\":1}}],[\"这里肯定就是对用户user表搜索了\",{\"1\":{\"139\":1}}],[\"这里面就涉及到对用户信息的筛选\",{\"1\":{\"139\":1}}],[\"这里position\",{\"1\":{\"131\":1}}],[\"这里有一个索引下推\",{\"1\":{\"127\":1}}],[\"这里优化的思路就是每一次磁盘\",{\"1\":{\"107\":1}}],[\"这里的\",{\"1\":{\"107\":1}}],[\"这里叶子节点\",{\"1\":{\"101\":1}}],[\"这里就涉及到一个问题\",{\"1\":{\"60\":1}}],[\"这里设置的\",{\"1\":{\"52\":1}}],[\"这里我们引入\",{\"1\":{\"41\":1}}],[\"这里可以看出\",{\"1\":{\"5\":1}}],[\"这样排序后就会直接从内存里返回查询结果了\",{\"1\":{\"240\":1}}],[\"这样会节省一些io开销\",{\"1\":{\"228\":1}}],[\"这样可使计数器表小且快\",{\"1\":{\"223\":1}}],[\"这样可以节约索引空间\",{\"1\":{\"232\":1}}],[\"这样可以非常快速的去访问相邻的叶子节点\",{\"1\":{\"104\":1}}],[\"这样可以让系统不至于单次停顿时间过长\",{\"1\":{\"57\":1}}],[\"这样undo日志链可以将数据串联成一个历史版本链\",{\"1\":{\"188\":1}}],[\"这样能尽快收到反馈\",{\"1\":{\"139\":1}}],[\"这样只需要遍历name字段的联合索引树就能拿到所有结果\",{\"1\":{\"129\":1}}],[\"这样的列在做索引时\",{\"1\":{\"230\":1}}],[\"这样的效率是比较低的\",{\"1\":{\"106\":1}}],[\"这样的话在回收过程就会不断空出来新的region\",{\"1\":{\"57\":1}}],[\"这样范围查询的效率是非常高的\",{\"1\":{\"106\":1}}],[\"这样范围查询的时候就需要不断的从根节点向下遍历\",{\"1\":{\"102\":1}}],[\"这样查询某个数据时候性能就会大大提升\",{\"1\":{\"98\":1}}],[\"这样\",{\"1\":{\"66\":2,\"115\":2,\"197\":1}}],[\"这样合并就节省了一次遍历对象图的开销\",{\"1\":{\"65\":1}}],[\"这样整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾\",{\"1\":{\"60\":1}}],[\"这样就能保证你的查询速度和性能了\",{\"1\":{\"139\":1}}],[\"这样就能满足查询要求了\",{\"1\":{\"139\":1}}],[\"这样就能扫描到白色的对象\",{\"1\":{\"43\":1}}],[\"这样就需要不断的从根节点向叶子节点查询\",{\"1\":{\"106\":1}}],[\"这样就算gc把对象移动了\",{\"1\":{\"68\":1}}],[\"这样就使每次的内存回收都是对内存区间的一半进行回收\",{\"1\":{\"33\":1}}],[\"这样就不会因为没有一大块连续空间导致对象内存不够分配\",{\"1\":{\"20\":1}}],[\"这样我们就可以根据各个年代的特点选择合适的垃圾收集算法\",{\"1\":{\"32\":1}}],[\"这样该对象所占用的内存空间就可以随栈帧出栈而销毁\",{\"1\":{\"20\":1}}],[\"这样两个方法耗时是差不多的\",{\"1\":{\"12\":1}}],[\"这一步速度很快\",{\"1\":{\"52\":1}}],[\"这一步操作保证了java里对象实例不赋值默认值也可以直接使用\",{\"1\":{\"17\":1}}],[\"这一步可提前至tlab分配时进行\",{\"1\":{\"17\":1}}],[\"这时不需要将所有长度全部加上索引\",{\"1\":{\"232\":1}}],[\"这时\",{\"1\":{\"198\":1}}],[\"这时候\",{\"1\":{\"105\":1}}],[\"这时候我们是不是就想到了树这种数据结构\",{\"1\":{\"98\":1}}],[\"这时候它们暂时处于\",{\"1\":{\"28\":1}}],[\"这时再做gc进行标记存活的对象\",{\"1\":{\"66\":1}}],[\"这时要将堆中的对象挪到虚拟机栈中\",{\"1\":{\"11\":1}}],[\"这时就可以向jit提交针对该方法的热点编译请求\",{\"1\":{\"6\":1}}],[\"这三种优化措施中\",{\"1\":{\"11\":1}}],[\"这对解释执行阶段的速度也有所影响\",{\"1\":{\"7\":1}}],[\"这两个字段放到\",{\"1\":{\"240\":1}}],[\"这两个词可以看出\",{\"1\":{\"39\":1}}],[\"这两个对象之间再无任何引用\",{\"1\":{\"25\":1}}],[\"这两个编译器存在已久\",{\"1\":{\"7\":1}}],[\"这两个计数器都有一个明确的阈值\",{\"1\":{\"6\":1}}],[\"这个比值越大越好\",{\"1\":{\"231\":1}}],[\"这个取决于应用程序\",{\"1\":{\"222\":1}}],[\"这个惟一属性列被称为主关键字或主键\",{\"1\":{\"211\":1}}],[\"这个id用来在mysql集群环境中标记唯一mysql服务器\",{\"1\":{\"206\":1}}],[\"这个时候mysql还没有分配事务id\",{\"1\":{\"189\":1}}],[\"这个隔离性就是靠着mvcc\",{\"1\":{\"187\":1}}],[\"这个表一般来说数据量会比较大\",{\"1\":{\"139\":1}}],[\"这个所谓的字段类型小一点的列\",{\"1\":{\"136\":1}}],[\"这个查询只能在联合索引里匹配到名字是\",{\"1\":{\"127\":1}}],[\"这个平衡是会消耗时间的\",{\"1\":{\"115\":1}}],[\"这个修改过程是比较耗费时间的\",{\"1\":{\"115\":1}}],[\"这个磁盘\",{\"1\":{\"107\":1}}],[\"这个值可以修改\",{\"1\":{\"107\":1}}],[\"这个因为之前已经大概知道young\",{\"1\":{\"92\":1}}],[\"这个屏障会把读出的指针更新到对象的新地址上\",{\"1\":{\"68\":1}}],[\"这个region立即就能够被释放和重用掉\",{\"1\":{\"67\":1}}],[\"这个region就可以立即释放用于新对象的分配\",{\"1\":{\"65\":1}}],[\"这个参数来控制排序\",{\"1\":{\"240\":1}}],[\"这个参数控制\",{\"1\":{\"205\":1}}],[\"这个参数的值\",{\"1\":{\"58\":1}}],[\"这个参数标识最后的混合回收阶段会执行8次\",{\"1\":{\"57\":1}}],[\"这个参数需要配合\",{\"1\":{\"8\":1}}],[\"这个过程就是回表操作\",{\"1\":{\"116\":1}}],[\"这个过程要把重分配集中的存活对象复制到新的region上\",{\"1\":{\"65\":1}}],[\"这个过程是非常耗时的\",{\"1\":{\"56\":1}}],[\"这个过程耗时较长但是不需要停顿用户线程\",{\"1\":{\"39\":1}}],[\"这个停顿时间再怎么低也得有个限度\",{\"1\":{\"52\":1}}],[\"这个对象也有可能是浮动垃圾\",{\"1\":{\"43\":1}}],[\"这个对象是那个类\",{\"1\":{\"18\":1}}],[\"这个gcroot引用的对象之前又被扫描过\",{\"1\":{\"42\":1}}],[\"这个条件标记成以下三种颜色\",{\"1\":{\"41\":1}}],[\"这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些region\",{\"1\":{\"65\":1}}],[\"这个阶段其实也可以做到与用户程序一起并发执行\",{\"1\":{\"52\":1}}],[\"这个阶段如果有新增对象会被标记为黑色不做任何处理\",{\"1\":{\"39\":1}}],[\"这个阶段的停顿时间一般会比初始标记阶段的时间稍长\",{\"1\":{\"39\":1}}],[\"这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢\",{\"1\":{\"27\":1}}],[\"这个方法实现简单\",{\"1\":{\"25\":1}}],[\"这个规则其实是希望那些可能是长期存活的对象\",{\"1\":{\"23\":1}}],[\"这个优化措施主要针对synchronized关键字\",{\"1\":{\"12\":1}}],[\"这个也是经过逃逸分析后可以直接进行的优化措施\",{\"1\":{\"12\":1}}],[\"这个性能开销是难以接受的\",{\"1\":{\"11\":1}}],[\"这个阈值默认是10000次\",{\"1\":{\"6\":1}}],[\"这个行为称之为\",{\"1\":{\"6\":1}}],[\"这个跟早期jdk版本的\",{\"1\":{\"0\":1}}],[\"这种在mysql的实现中也有体现\",{\"1\":{\"223\":1}}],[\"这种解决思路其实就是写热点的分散\",{\"1\":{\"223\":1}}],[\"这种不会因为服务宕机而丢失数据\",{\"1\":{\"205\":1}}],[\"这种不会像cms那样回收完因为有很多内存碎片还需要整理一次\",{\"1\":{\"52\":1}}],[\"这种方式磁盘扫描了t2表100行\",{\"1\":{\"148\":1}}],[\"这种写法也有缺陷\",{\"1\":{\"145\":1}}],[\"这种写法\",{\"1\":{\"142\":1}}],[\"这种字段建立索引\",{\"1\":{\"136\":1}}],[\"这种需要二次查找的过程就被称为\",{\"1\":{\"116\":1}}],[\"这种情况只会走name字段索引\",{\"1\":{\"127\":1}}],[\"这种情况完全可以考虑采用一些成熟的jvm级缓存框架来解决\",{\"1\":{\"95\":1}}],[\"这种情况下它的执行还会很快吗\",{\"1\":{\"60\":1}}],[\"这种线程无法响应jvm的中断请求\",{\"1\":{\"74\":1}}],[\"这种使用region划分内存空间以及有优先级的区域回收方式\",{\"1\":{\"52\":1}}],[\"这种如果又去对老年代再去扫描效率太低了\",{\"1\":{\"48\":1}}],[\"这种浮动垃圾只能等到下一次gc再清理了\",{\"1\":{\"39\":1}}],[\"这种算法没有什么新的思想\",{\"1\":{\"32\":1}}],[\"这种叫方法逃逸\",{\"1\":{\"9\":1}}],[\"这种先编译\",{\"1\":{\"5\":1}}],[\"这种优化不会提高执行效率\",{\"1\":{\"3\":1}}],[\"这⾥就暂时略过\",{\"1\":{\"4\":1}}],[\"07\",{\"0\":{\"208\":1}}],[\"0默认开启了biglog\",{\"1\":{\"206\":1}}],[\"0代表关闭查询缓存off\",{\"1\":{\"197\":1}}],[\"0查看锁等待\",{\"1\":{\"182\":1}}],[\"0查看锁\",{\"1\":{\"182\":1}}],[\"00\",{\"1\":{\"145\":1}}],[\"06\",{\"0\":{\"76\":1,\"193\":1},\"1\":{\"145\":1}}],[\"05\",{\"0\":{\"51\":1,\"186\":1},\"1\":{\"145\":2}}],[\"04\",{\"0\":{\"31\":1,\"162\":1},\"1\":{\"145\":1}}],[\"03\",{\"0\":{\"14\":1,\"141\":1},\"1\":{\"145\":1,\"224\":1}}],[\"0\",{\"1\":{\"7\":1,\"8\":2,\"12\":2,\"28\":2,\"107\":1,\"121\":1,\"129\":1,\"197\":1,\"205\":2}}],[\"02\",{\"0\":{\"2\":1,\"120\":1},\"1\":{\"224\":1}}],[\"01\",{\"0\":{\"0\":1,\"97\":1}}],[\"‍\",{\"1\":{\"0\":1,\"6\":1,\"12\":1,\"29\":1,\"66\":1,\"95\":1,\"160\":1,\"206\":1,\"240\":1}}],[\"mutex\",{\"1\":{\"223\":1}}],[\"multi\",{\"1\":{\"187\":1}}],[\"mvcc多版本控制机制\",{\"0\":{\"187\":1}}],[\"mrr的详细信息\",{\"1\":{\"228\":1}}],[\"mrr\",{\"0\":{\"228\":1},\"1\":{\"129\":1,\"228\":1}}],[\"my\",{\"1\":{\"197\":2}}],[\"myi\",{\"1\":{\"110\":1}}],[\"myisam\",{\"0\":{\"110\":1,\"111\":1,\"113\":1},\"1\":{\"109\":1,\"113\":3,\"116\":1,\"194\":1,\"201\":1}}],[\"myd\",{\"1\":{\"110\":1,\"111\":1,\"113\":2}}],[\"myysql\",{\"1\":{\"103\":1}}],[\"mysql很多参数设置都是做过优化的\",{\"1\":{\"240\":1}}],[\"mysql通过\",{\"1\":{\"240\":1}}],[\"mysql通过mvcc机制读取历史版本\",{\"1\":{\"175\":1}}],[\"mysql中提出了一个名为disk\",{\"1\":{\"228\":1}}],[\"mysql是关系型数据库\",{\"1\":{\"209\":1}}],[\"mysql这套机制看起来复杂\",{\"1\":{\"191\":1}}],[\"mysql将readlog日志缓存刷入磁盘\",{\"1\":{\"190\":1}}],[\"mysql将更新后数据写入binlog日志\",{\"1\":{\"190\":1}}],[\"mysql将更新后数据写入readlog日志缓存中\",{\"1\":{\"190\":1}}],[\"mysql将更新数据的旧值写入undo日志\",{\"1\":{\"190\":1}}],[\"mysql将bufferpool中的数据进行更新\",{\"1\":{\"190\":1}}],[\"mysql内部是严格按照启动顺序来分配事务id的\",{\"1\":{\"189\":1}}],[\"mysql内部可能觉得第一个字段就用范围\",{\"1\":{\"123\":1}}],[\"mysql默认在可重复读和读已提交的事务隔离情况下都实现了mvcc\",{\"1\":{\"187\":1}}],[\"mysql默认级别是repeatable\",{\"1\":{\"177\":1}}],[\"mysql在可重复读的事务隔离机制下\",{\"1\":{\"187\":1}}],[\"mysql8\",{\"1\":{\"197\":1,\"206\":1}}],[\"mysql8的关键字为\",{\"1\":{\"172\":1}}],[\"mysql8以上版本有降序索引可以支持该种查询方式\",{\"1\":{\"131\":1}}],[\"mysql事务隔离级别及锁机制\",{\"0\":{\"162\":1}}],[\"mysql并不会把全部字段取出来\",{\"1\":{\"155\":1}}],[\"mysql主要扫描聚簇索引\",{\"1\":{\"153\":1}}],[\"mysql从被驱动表t1中取出每一行数据\",{\"1\":{\"149\":1}}],[\"mysql会根据索引查找到相应数据\",{\"1\":{\"190\":1}}],[\"mysql会保留本次修改的数据到undo回滚日志\",{\"1\":{\"188\":1}}],[\"mysql会进行切块\",{\"1\":{\"150\":1}}],[\"mysql会先将驱动表t2中的数据取出来存放到内存的join\",{\"1\":{\"149\":1}}],[\"mysql会使用基于块的嵌套循环连接\",{\"1\":{\"149\":1}}],[\"mysql会查询出90010条数据\",{\"1\":{\"142\":1}}],[\"mysql优化器会自动选择较小的表作为驱动表\",{\"1\":{\"148\":1}}],[\"mysql先将小表的数据取出来\",{\"1\":{\"148\":1}}],[\"mysql认为走索引效率不如全表扫描\",{\"1\":{\"146\":1}}],[\"mysql支持两种方式的排序filesort和index\",{\"1\":{\"131\":1}}],[\"mysql最终如何选择索引\",{\"1\":{\"129\":1}}],[\"mysql最终是否选择走索引或者一张表涉及多个索引\",{\"1\":{\"129\":1}}],[\"mysql>\",{\"1\":{\"129\":9}}],[\"mysql如何选择合适的索引\",{\"0\":{\"129\":1}}],[\"mysql索引\",{\"0\":{\"225\":1}}],[\"mysql索引优化二\",{\"0\":{\"141\":1},\"1\":{\"224\":1}}],[\"mysql索引优化一\",{\"0\":{\"120\":1},\"1\":{\"224\":1}}],[\"mysql索引底层数据结构\",{\"0\":{\"97\":1}}],[\"mysql\",{\"0\":{\"100\":1,\"101\":1,\"102\":1,\"107\":1,\"194\":1,\"202\":1,\"245\":1},\"1\":{\"99\":1,\"100\":2,\"103\":1,\"105\":1,\"107\":5,\"109\":2,\"114\":2,\"115\":4,\"127\":1,\"182\":2,\"194\":1,\"196\":5,\"197\":3,\"198\":4,\"199\":2,\"201\":1,\"202\":7,\"203\":2,\"205\":1,\"238\":1,\"240\":2},\"2\":{\"119\":1,\"140\":1,\"161\":1,\"185\":1,\"192\":1,\"207\":1,\"236\":1,\"241\":1}}],[\"memory\",{\"1\":{\"201\":1}}],[\"medium\",{\"1\":{\"64\":1}}],[\"method\",{\"1\":{\"8\":1}}],[\"metaspacesize设置成一样的值\",{\"1\":{\"0\":1}}],[\"metaspacesiz\",{\"1\":{\"0\":1}}],[\"min\",{\"1\":{\"189\":2}}],[\"minor\",{\"1\":{\"22\":2}}],[\"mixedgc不是fullgc\",{\"1\":{\"55\":1}}],[\"mixedgc\",{\"0\":{\"55\":1},\"1\":{\"57\":1}}],[\"mode信息里显示<\",{\"1\":{\"238\":2}}],[\"mode\",{\"1\":{\"39\":1,\"167\":1}}],[\"male\",{\"1\":{\"139\":2}}],[\"map\",{\"1\":{\"129\":3}}],[\"may\",{\"1\":{\"129\":1}}],[\"manager\",{\"1\":{\"121\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":4,\"127\":3}}],[\"math\",{\"1\":{\"84\":5}}],[\"major\",{\"1\":{\"62\":1}}],[\"markers\",{\"1\":{\"129\":1}}],[\"marked0标识\",{\"1\":{\"66\":1}}],[\"marked1标识\",{\"1\":{\"66\":1}}],[\"marking\",{\"1\":{\"52\":1}}],[\"mark\",{\"1\":{\"39\":2,\"52\":1,\"65\":3}}],[\"max\",{\"1\":{\"103\":1,\"181\":1,\"189\":2,\"206\":1,\"238\":1,\"240\":3}}],[\"maxgcpausemills\",{\"1\":{\"54\":2,\"58\":2,\"60\":1}}],[\"maxgcpausemillis\",{\"1\":{\"52\":1,\"57\":1}}],[\"maxgcpausemillis指定\",{\"1\":{\"52\":1}}],[\"maxtenuringthreshold\",{\"1\":{\"22\":1,\"57\":1}}],[\"maxtrivialsize=size\",{\"1\":{\"8\":1}}],[\"maxinlinesize=size\",{\"1\":{\"8\":1}}],[\"maxmetaspacesize和\",{\"1\":{\"0\":1}}],[\"maxmetaspacesize\",{\"1\":{\"0\":2}}],[\"main\",{\"1\":{\"8\":2,\"12\":1,\"28\":1,\"41\":1,\"61\":1,\"83\":2,\"84\":1}}],[\"14\",{\"1\":{\"232\":2}}],[\"13\",{\"1\":{\"232\":1}}],[\"12\",{\"1\":{\"232\":1}}],[\"12176\",{\"1\":{\"129\":1}}],[\"1nf\",{\"1\":{\"209\":2}}],[\"1gb\",{\"1\":{\"206\":1}}],[\"1m\",{\"1\":{\"204\":1}}],[\"1mb~32mb\",{\"1\":{\"57\":1}}],[\"1代表开启on\",{\"1\":{\"197\":1}}],[\"192\",{\"1\":{\"196\":1}}],[\"19663\",{\"1\":{\"84\":1}}],[\"1下面执行\",{\"1\":{\"177\":1}}],[\"11\",{\"1\":{\"121\":2,\"232\":1}}],[\"1170117016\",{\"1\":{\"107\":1}}],[\"1170\",{\"1\":{\"107\":1}}],[\"18\",{\"1\":{\"107\":1,\"210\":2}}],[\"18位\",{\"1\":{\"66\":1}}],[\"1kb\",{\"1\":{\"107\":1}}],[\"16m\",{\"1\":{\"204\":1}}],[\"16\",{\"1\":{\"107\":1}}],[\"16kb\",{\"1\":{\"107\":3}}],[\"16k\",{\"0\":{\"107\":1},\"1\":{\"107\":1}}],[\"15个字符长度即可\",{\"1\":{\"232\":1}}],[\"15\",{\"1\":{\"105\":3,\"111\":1,\"206\":1,\"232\":1}}],[\"1521\",{\"1\":{\"12\":1}}],[\"1位\",{\"1\":{\"66\":4}}],[\"10123\",{\"1\":{\"129\":5}}],[\"1024\",{\"1\":{\"107\":1}}],[\"10这个命令查看了一下堆内存占用还好\",{\"1\":{\"69\":1}}],[\"1049\",{\"1\":{\"12\":1}}],[\"1039\",{\"1\":{\"12\":1}}],[\"10\",{\"1\":{\"9\":2,\"32\":1,\"84\":2,\"90\":1,\"92\":1,\"142\":2,\"144\":1,\"145\":2,\"146\":2,\"232\":1}}],[\"10000=100万次\",{\"1\":{\"149\":1,\"150\":1}}],[\"100000000\",{\"1\":{\"12\":2}}],[\"10000000\",{\"1\":{\"8\":1}}],[\"1000000\",{\"1\":{\"8\":1}}],[\"100000\",{\"1\":{\"8\":1}}],[\"1000\",{\"1\":{\"69\":1,\"90\":1}}],[\"100\",{\"1\":{\"6\":1,\"129\":1,\"148\":1,\"204\":1}}],[\"10的新生代内存\",{\"1\":{\"0\":1}}],[\"1\",{\"0\":{\"15\":1,\"21\":1,\"36\":1,\"123\":1,\"133\":1,\"181\":1,\"222\":1},\"1\":{\"0\":1,\"7\":2,\"8\":2,\"16\":1,\"27\":1,\"28\":1,\"41\":1,\"52\":2,\"71\":2,\"83\":1,\"84\":1,\"101\":1,\"107\":1,\"116\":1,\"129\":4,\"152\":2,\"153\":3,\"154\":3,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"205\":2,\"210\":2}}],[\"元空间无固定初始大小\",{\"1\":{\"0\":1}}],[\"元空间最大值\",{\"1\":{\"0\":1}}],[\"元空间设置参数有两个\",{\"1\":{\"0\":1}}],[\"3nf\",{\"1\":{\"209\":2,\"212\":1}}],[\"3306\",{\"1\":{\"196\":1}}],[\"333s\",{\"1\":{\"124\":1}}],[\"34\",{\"1\":{\"145\":1}}],[\"3中explain的执行结果一样\",{\"1\":{\"131\":1}}],[\"32\",{\"1\":{\"107\":1}}],[\"30~40\",{\"1\":{\"105\":1}}],[\"300000\",{\"1\":{\"92\":1}}],[\"30\",{\"1\":{\"70\":1,\"105\":7,\"111\":1}}],[\"3g\",{\"1\":{\"69\":1}}],[\"3\",{\"0\":{\"17\":1,\"23\":1,\"38\":1,\"125\":1,\"135\":1,\"224\":1},\"1\":{\"0\":1,\"7\":2,\"8\":2,\"41\":1,\"101\":1,\"103\":1,\"107\":1,\"131\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"205\":1,\"232\":1,\"239\":1,\"240\":1}}],[\"2nf\",{\"1\":{\"209\":2,\"211\":1}}],[\"28\",{\"1\":{\"145\":2}}],[\"255\",{\"1\":{\"136\":2}}],[\"23\",{\"1\":{\"121\":2,\"145\":1}}],[\"22\",{\"1\":{\"121\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":4,\"127\":3}}],[\"22位\",{\"1\":{\"66\":1}}],[\"24\",{\"1\":{\"121\":1}}],[\"2461\",{\"1\":{\"12\":1}}],[\"21902400\",{\"1\":{\"107\":1}}],[\"2^32=64tib\",{\"1\":{\"107\":1}}],[\"200m\",{\"1\":{\"206\":1}}],[\"2022\",{\"1\":{\"145\":2}}],[\"2052\",{\"1\":{\"129\":2}}],[\"2054\",{\"1\":{\"129\":1}}],[\"20~50\",{\"1\":{\"106\":1}}],[\"20\",{\"1\":{\"70\":1,\"105\":1,\"106\":1,\"111\":1,\"121\":1,\"136\":1,\"177\":1,\"178\":1}}],[\"2018\",{\"1\":{\"61\":1}}],[\"2的35次方=32g\",{\"1\":{\"19\":1}}],[\"2的32次方\",{\"1\":{\"19\":1}}],[\"2\",{\"0\":{\"16\":1,\"22\":1,\"36\":1,\"37\":2,\"38\":1,\"39\":1,\"124\":1,\"134\":1,\"182\":1,\"223\":1},\"1\":{\"0\":1,\"7\":2,\"8\":2,\"16\":3,\"27\":1,\"28\":1,\"41\":1,\"84\":1,\"98\":1,\"101\":1,\"116\":1,\"129\":1,\"131\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"197\":1,\"204\":1,\"205\":1,\"239\":1}}],[\"默认1m\",{\"1\":{\"240\":1}}],[\"默认1024字节\",{\"1\":{\"238\":1}}],[\"默认15\",{\"1\":{\"57\":1}}],[\"默认值为\",{\"1\":{\"204\":2}}],[\"默认值是6bytes\",{\"1\":{\"8\":1}}],[\"默认值是325bytes\",{\"1\":{\"8\":1}}],[\"默认值是35byt\",{\"1\":{\"8\":1}}],[\"默认值是1000bytes\",{\"1\":{\"8\":1}}],[\"默认会给你设置存储引擎为\",{\"1\":{\"201\":1}}],[\"默认为\",{\"1\":{\"206\":1}}],[\"默认为0\",{\"1\":{\"206\":1}}],[\"默认为不使用\",{\"1\":{\"70\":1}}],[\"默认为15岁\",{\"1\":{\"22\":1}}],[\"默认5\",{\"1\":{\"57\":1}}],[\"默认50\",{\"1\":{\"57\":1}}],[\"默认45\",{\"1\":{\"57\":1}}],[\"默认就是百分比\",{\"1\":{\"57\":1}}],[\"默认整堆5\",{\"1\":{\"57\":1}}],[\"默认200ms\",{\"1\":{\"57\":1}}],[\"默认2表示新生代占年老代的1\",{\"1\":{\"0\":1}}],[\"默认将整堆划分为2048个分区\",{\"1\":{\"57\":1}}],[\"默认8次\",{\"1\":{\"57\":1}}],[\"默认85\",{\"1\":{\"57\":1}}],[\"默认8\",{\"1\":{\"52\":1}}],[\"默认8表示一个survivor区占用1\",{\"1\":{\"0\":1}}],[\"默认年轻代占5\",{\"1\":{\"52\":1}}],[\"默认的新生代和老年代收集器\",{\"1\":{\"37\":1}}],[\"默认的收集线程数跟\",{\"1\":{\"37\":1}}],[\"默认是92\",{\"1\":{\"40\":1}}],[\"默认是0\",{\"1\":{\"40\":1}}],[\"默认是关闭的\",{\"1\":{\"8\":1}}],[\"默认是21m左右\",{\"1\":{\"0\":1}}],[\"默认开启\",{\"1\":{\"8\":1,\"19\":1,\"70\":1}}],[\"默认\",{\"1\":{\"0\":1,\"204\":2,\"205\":1}}],[\"默认物理内存的1\",{\"1\":{\"0\":2}}],[\"404\",{\"1\":{\"242\":1}}],[\"4096m\",{\"1\":{\"204\":1}}],[\"4nf\",{\"1\":{\"209\":1}}],[\"48m\",{\"1\":{\"204\":1}}],[\"4对比\",{\"1\":{\"131\":1}}],[\"444s\",{\"1\":{\"124\":1}}],[\"4cd0得到线程堆栈信息中4cd0的这个线程号后面10行的信息\",{\"1\":{\"84\":1}}],[\"4g以下可以用parallel\",{\"1\":{\"71\":1}}],[\"49\",{\"1\":{\"70\":1,\"111\":1}}],[\"4位是颜色位\",{\"1\":{\"68\":1}}],[\"42位\",{\"1\":{\"66\":1}}],[\"42\",{\"1\":{\"8\":1}}],[\"4\",{\"0\":{\"18\":1,\"24\":1,\"39\":1,\"126\":1,\"136\":1,\"225\":1},\"1\":{\"0\":1,\"7\":2,\"8\":1,\"71\":1,\"131\":1,\"173\":1,\"174\":1,\"175\":1,\"232\":1,\"240\":1}}],[\"x\",{\"1\":{\"84\":1}}],[\"x4\",{\"1\":{\"8\":3}}],[\"x3\",{\"1\":{\"8\":3}}],[\"x2\",{\"1\":{\"8\":4}}],[\"x1+x2+x3+x4\",{\"1\":{\"8\":1}}],[\"x1+x2\",{\"1\":{\"8\":1}}],[\"x1\",{\"1\":{\"8\":4}}],[\"xx=xx\",{\"1\":{\"139\":2}}],[\"xx\",{\"0\":{\"52\":1},\"1\":{\"0\":9,\"6\":1,\"7\":1,\"8\":10,\"10\":1,\"12\":1,\"16\":2,\"19\":1,\"20\":2,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"37\":1,\"39\":1,\"40\":10,\"52\":5,\"54\":2,\"55\":1,\"57\":12,\"58\":2,\"60\":1,\"69\":2,\"81\":2,\"139\":7}}],[\"xmn\",{\"1\":{\"0\":1}}],[\"xmx\",{\"1\":{\"0\":1}}],[\"xms\",{\"1\":{\"0\":1}}],[\"xss\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
