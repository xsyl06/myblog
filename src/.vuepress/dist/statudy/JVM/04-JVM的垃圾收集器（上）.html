<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.34" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://xsyl06.github.io/myblog/myblog/statudy/JVM/04-JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%B8%8A%EF%BC%89.html"><meta property="og:site_name" content="Xsyl06的博客"><meta property="og:title" content="04-JVM的垃圾收集器（上）"><meta property="og:description" content="04-JVM的垃圾收集器（上） 一、垃圾收集算法 ​image​ 分代收集理论 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象(近 99%)死去，所以可以选..."><meta property="og:type" content="article"><meta property="og:image" content="https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221223146-y0g6u5u.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-04-08T09:26:37.000Z"><meta property="article:author" content="xsyl06"><meta property="article:tag" content="JVM"><meta property="article:tag" content="垃圾收集器"><meta property="article:published_time" content="2024-04-01T00:00:00.000Z"><meta property="article:modified_time" content="2024-04-08T09:26:37.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"04-JVM的垃圾收集器（上）","image":["https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221223146-y0g6u5u.png","https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221223637-t15eyfh.png","https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221223830-1kh3pzf.png","https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221223938-gg0hd7c.png","https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221224025-ip60b66.png","https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221224347-t09ptcu.png","https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221224944-qvf6t28.png","https://xsyl06.github.io/myblog/myblog/assets/img/image-20240221224944-qvf6t28.png","https://xsyl06.github.io/myblog/myblog/assets/img/net-img-1658137342127-7c2771e6-fa14-41e5-bc0b-f8213da25d57-20240222231142-kmo3ni8.png","https://xsyl06.github.io/myblog/myblog/assets/img/net-img-1658137551870-430cc481-25bc-452c-a28f-dce29a402648-20240222231144-prfqnoe.png","https://cdn.nlark.com/yuque/0/2022/png/1295195/1658138144392-49d489bc-8d51-44a5-98df-e993c8cf91e6.png"],"datePublished":"2024-04-01T00:00:00.000Z","dateModified":"2024-04-08T09:26:37.000Z","author":[{"@type":"Person","name":"xsyl06","url":"https://gitee.com/xsyl06"}]}</script><title>04-JVM的垃圾收集器（上） | Xsyl06的博客</title><meta name="description" content="04-JVM的垃圾收集器（上） 一、垃圾收集算法 ​image​ 分代收集理论 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象(近 99%)死去，所以可以选...">
    <link rel="preload" href="/myblog/assets/style-ClFDCvuC.css" as="style"><link rel="stylesheet" href="/myblog/assets/style-ClFDCvuC.css">
    <link rel="modulepreload" href="/myblog/assets/app-DeNibpf_.js"><link rel="modulepreload" href="/myblog/assets/04-JVM的垃圾收集器（上）.html-X19JjV2X.js"><link rel="modulepreload" href="/myblog/assets/image-20240221224025-ip60b66-CayMTXT0.js"><link rel="modulepreload" href="/myblog/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/myblog/assets/index.html-DFQY-6pN.js" as="script"><link rel="prefetch" href="/myblog/assets/01-JVM内存模型.html-DpeOlX0o.js" as="script"><link rel="prefetch" href="/myblog/assets/02-深入理解JVM执行引擎.html-CxaY2WxQ.js" as="script"><link rel="prefetch" href="/myblog/assets/03-JVM对象创建及内存分配机制.html-CBxU-teT.js" as="script"><link rel="prefetch" href="/myblog/assets/05-JVM的垃圾收集器（下）.html-BnNNOfem.js" as="script"><link rel="prefetch" href="/myblog/assets/06-JVM工具详解.html-DnI0PVr_.js" as="script"><link rel="prefetch" href="/myblog/assets/01-理解Mysql索引底层数据结构.html-6IHGTd1h.js" as="script"><link rel="prefetch" href="/myblog/assets/02-Mysql索引优化一.html-DXFpP-ai.js" as="script"><link rel="prefetch" href="/myblog/assets/03-Mysql索引优化二.html-nvRhS3mG.js" as="script"><link rel="prefetch" href="/myblog/assets/04-理解Mysql事务隔离级别及锁机制.html-DL4bDlh2.js" as="script"><link rel="prefetch" href="/myblog/assets/05-理解MVCC与BufferPool.html-DdmKrzNR.js" as="script"><link rel="prefetch" href="/myblog/assets/06-Innodb原理与Mysql日志机制.html-S8ZtWPP9.js" as="script"><link rel="prefetch" href="/myblog/assets/07-表结构及索引设计.html-B65WnVS6.js" as="script"><link rel="prefetch" href="/myblog/assets/08-全局理解Mysql性能优化.html-m3mdINku.js" as="script"><link rel="prefetch" href="/myblog/assets/Using filesort文件排序原理.html-GmKnTpUl.js" as="script"><link rel="prefetch" href="/myblog/assets/01-Redis核心数据结构与高性能.html-Crr4g8MN.js" as="script"><link rel="prefetch" href="/myblog/assets/Redis单机版搭建.html-BffKCejP.js" as="script"><link rel="prefetch" href="/myblog/assets/Redis常用命令.html-DjCLipmb.js" as="script"><link rel="prefetch" href="/myblog/assets/404.html-CuI5SQ28.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-CuKth7E6.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-Cuvvw4jl.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-Bp3ZikKS.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-B7W5Dh5D.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-5G6SxZI4.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-CqDyxxZe.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-6sry0iCL.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-luTD51t6.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-VeI9Lg_A.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-D071ANcb.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-Br9TnwnU.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-Dhm63UWv.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-VmkCiNKP.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-D71BrGP0.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-BKj0hLUp.js" as="script"><link rel="prefetch" href="/myblog/assets/index.html-D9xrihqR.js" as="script"><link rel="prefetch" href="/myblog/assets/flowchart-966sEcGG.js" as="script"><link rel="prefetch" href="/myblog/assets/photoswipe.esm-SzV8tJDW.js" as="script"><link rel="prefetch" href="/myblog/assets/SearchResult-BXO7KzYE.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/myblog/"><img class="vp-nav-logo" src="https://theme-hope-assets.vuejs.press/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">Xsyl06的博客</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/myblog/" aria-label="博客主页"><iconify-icon class="font-icon icon" style="" mode="style" inline icon="home" width="1em" height="1em"></iconify-icon>博客主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="java"><span class="title"><iconify-icon class="font-icon icon" style="" mode="style" inline icon="skill-icons:java-dark" width="1em" height="1em"></iconify-icon>java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link active" href="/myblog/statudy/JVM/" aria-label="JVM"><!---->JVM<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/myblog/statudy/Mysql/" aria-label="Mysql"><!---->Mysql<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/myblog/statudy/Redis/" aria-label="Redis"><!---->Redis<!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/myblog/" aria-label="博客主页"><iconify-icon class="font-icon icon" style="" mode="style" inline icon="home" width="1em" height="1em"></iconify-icon>博客主页<!----></a></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><iconify-icon class="font-icon icon" style="" mode="style" inline icon="skill-icons:java-dark" width="1em" height="1em"></iconify-icon><span class="vp-sidebar-title">JAVA</span><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">JVM</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/myblog/statudy/JVM/01-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" aria-label="01-JVM内存模型"><!---->01-JVM内存模型<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/myblog/statudy/JVM/02-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html" aria-label="02-深入理解JVM执行引擎"><!---->02-深入理解JVM执行引擎<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/myblog/statudy/JVM/03-JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6.html" aria-label="03-JVM对象创建及内存分配机制"><!---->03-JVM对象创建及内存分配机制<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/myblog/statudy/JVM/04-JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%B8%8A%EF%BC%89.html" aria-label="04-JVM的垃圾收集器（上）"><!---->04-JVM的垃圾收集器（上）<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/myblog/statudy/JVM/05-JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%B8%8B%EF%BC%89.html" aria-label="05-JVM的垃圾收集器（下）"><!---->05-JVM的垃圾收集器（下）<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/myblog/statudy/JVM/06-JVM%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3.html" aria-label="06-JVM工具详解"><!---->06-JVM工具详解<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Mysql</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Redis</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->04-JVM的垃圾收集器（上）</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://gitee.com/xsyl06" target="_blank" rel="noopener noreferrer">xsyl06</a></span><span property="author" content="xsyl06"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-04-01T00:00:00.000Z"></span><span class="page-pageview-info" aria-label="访问量🔢" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon eye-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="eye icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z"></path></svg><span id="ArtalkPV" class="vp-pageview waline-pageview-count" data-path="/statudy/JVM/04-JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%B8%8A%EF%BC%89.html" data-page-key="/statudy/JVM/04-JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%B8%8A%EF%BC%89.html">...</span></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 17 分钟</span><meta property="timeRequired" content="PT17M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category1 clickable" role="navigation">JVM</span><!--]--><meta property="articleSection" content="JVM"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag1 clickable" role="navigation">JVM</span><span class="page-tag-item tag6 clickable" role="navigation">垃圾收集器</span><!--]--><meta property="keywords" content="JVM,垃圾收集器"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level1" href="#一、垃圾收集算法">一、垃圾收集算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#分代收集理论">分代收集理论</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#标记-复制算法">标记-复制算法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#标记-清除算法">标记-清除算法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#标记-整理算法">标记-整理算法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level1" href="#二、垃圾收集器">二、垃圾收集器</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-1-serial-收集器-xx-useserialgc-xx-useserialoldgc">2.1 Serial 收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-2-parallel-scavenge-收集器-xx-useparallelgc-年轻代-xx-useparalleloldgc-老年代">2.2 Parallel Scavenge 收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-3-parnew-收集器-xx-useparnewgc">2.3 ParNew 收集器(-XX:+UseParNewGC)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-4-cms-收集器-xx-useconcmarksweepgc-old">2.4 CMS 收集器(-XX:+UseConcMarkSweepGC(old))</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#cms的相关核心参数">CMS的相关核心参数</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level1" href="#三、垃圾收集底层算法实现">三、垃圾收集底层算法实现</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#三色标记">三色标记</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#多标-浮动垃圾">多标-浮动垃圾</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#漏标-读写屏障">漏标-读写屏障</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#写屏障">写屏障</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#写屏障实现satb">写屏障实现SATB</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#写屏障实现增量更新">写屏障实现增量更新</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#读屏障">读屏障</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#记忆集与卡表">记忆集与卡表</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#卡表的维护">卡表的维护</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1>04-JVM的垃圾收集器（上）</h1><h1 id="一、垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#一、垃圾收集算法"><span>一、垃圾收集算法</span></a></h1><p>​<img src="/myblog/assets/img/image-20240221223146-y0g6u5u.png" alt="image">​</p><h2 id="分代收集理论" tabindex="-1"><a class="header-anchor" href="#分代收集理论"><span>分代收集理论</span></a></h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象(近 99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢 10 倍以上。</p><h2 id="标记-复制算法" tabindex="-1"><a class="header-anchor" href="#标记-复制算法"><span>标记-复制算法</span></a></h2><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p>​<img src="/myblog/assets/img/image-20240221223637-t15eyfh.png" alt="image">​</p><h2 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法"><span>标记-清除算法</span></a></h2><p>算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：</p><ol><li><strong>效率问题 (如果需要标记的对象太多，效率不高)</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p>​<img src="/myblog/assets/img/image-20240221223830-1kh3pzf.png" alt="image">​</p><h2 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法"><span>标记-整理算法</span></a></h2><p>根据老年代的特点，特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p>​<img src="/myblog/assets/img/image-20240221223938-gg0hd7c.png" alt="image">​</p><h1 id="二、垃圾收集器" tabindex="-1"><a class="header-anchor" href="#二、垃圾收集器"><span>二、垃圾收集器</span></a></h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>​<img src="/myblog/assets/img/image-20240221224025-ip60b66.png" alt="image">​</p><p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 Java 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h2 id="_2-1-serial-收集器-xx-useserialgc-xx-useserialoldgc" tabindex="-1"><a class="header-anchor" href="#_2-1-serial-收集器-xx-useserialgc-xx-useserialoldgc"><span>2.1 <strong>Serial 收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)</strong></span></a></h2><p><strong>Serial（串行）</strong> 收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是<strong>它在进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>（ <strong>&quot;Stop The World&quot;</strong> ），直到它收集结束。</p><p><strong>新生代采用</strong>复制算法​ <strong>，老年代采用</strong>标记-整理​<strong>算法。</strong></p><p>​<img src="/myblog/assets/img/image-20240221224347-t09ptcu.png" alt="image">​</p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，<strong>它简单而高效</strong>（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p><p><strong>Serial Old 收集器是 Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h2 id="_2-2-parallel-scavenge-收集器-xx-useparallelgc-年轻代-xx-useparalleloldgc-老年代" tabindex="-1"><a class="header-anchor" href="#_2-2-parallel-scavenge-收集器-xx-useparallelgc-年轻代-xx-useparalleloldgc-老年代"><span>2.2 <strong>Parallel Scavenge 收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</strong></span></a></h2><p><strong>Parallel</strong> 收集器其实<strong>就是 Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器类似。默认的收集线程数跟 cpu 核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改 <strong>。</strong></p><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用</strong>复制算法​ <strong>，老年代采用</strong>标记-整理​<strong>算法。</strong></p><p>​<img src="/myblog/assets/img/image-20240221224944-qvf6t28.png" alt="image">​</p><p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本。使用多线程和“<strong>标记-整理</strong>”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器(JDK8 默认的新生代和老年代收集器)。</p><h2 id="_2-3-parnew-收集器-xx-useparnewgc" tabindex="-1"><a class="header-anchor" href="#_2-3-parnew-收集器-xx-useparnewgc"><span>2.3 <strong>ParNew 收集器(-XX:+UseParNewGC)</strong></span></a></h2><p>ParNew 收集器其实跟 Parallel 收集器很类似，区别主要在于它可以和 CMS 收集器配合使用。​</p><p><strong>新生代采用</strong>复制算法​ <strong>，老年代采用</strong>标记-整理​<strong>算法。</strong></p><p>​<img src="/myblog/assets/img/image-20240221224944-qvf6t28.png" alt="image">​</p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><h2 id="_2-4-cms-收集器-xx-useconcmarksweepgc-old" tabindex="-1"><a class="header-anchor" href="#_2-4-cms-收集器-xx-useconcmarksweepgc-old"><span>2.4 <strong>CMS 收集器(-XX:+UseConcMarkSweepGC(old))</strong></span></a></h2><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的 <strong>Mark Sweep</strong> 这两个词可以看出，CMS 收集器是一种 **“**​标记-清除​ <strong>”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ol><li><strong>初始标记：</strong> 暂停所有的其他线程(STW)，并记录下 gc roots <strong>直接能引用的对象，速度很快。</strong></li><li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，<strong>这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。</strong></li><li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。​</li><li><strong>并发重置：</strong> 重置本次GC过程中的标记数据。</li></ol><p>​<img src="/myblog/assets/img/net-img-1658137342127-7c2771e6-fa14-41e5-bc0b-f8213da25d57-20240222231142-kmo3ni8.png" alt="image">​</p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面几个明显的缺点：</p><ul><li>对CPU资源敏感（会和服务抢资源）；</li><li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li><li>它使用的回收算法-“<strong>标记-清除</strong>”算法会导致收集结束时会有大量<strong>空间碎片产生</strong>，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li><li>执行过程中的不确定性，<strong>会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况</strong>，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是&quot;concurrent mode failure&quot;，此时会进入stop the world，用serial old垃圾收集器来回收</li></ul><h3 id="cms的相关核心参数" tabindex="-1"><a class="header-anchor" href="#cms的相关核心参数"><span><strong>CMS的相关核心参数</strong></span></a></h3><ol><li>-XX:+UseConcMarkSweepGC：启用cms</li><li>-XX:ConcGCThreads：并发的GC线程数</li><li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）</li><li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次</li><li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li><li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li><li>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，降低CMS GC标记阶段(也会对年轻代一起做标记，如果在minor gc就干掉了很多对垃圾对象，标记阶段就会减少一些标记时间)时的开销，一般CMS的GC耗时 80%都在标记阶段</li><li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li><li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</li></ol><h1 id="三、垃圾收集底层算法实现" tabindex="-1"><a class="header-anchor" href="#三、垃圾收集底层算法实现"><span>三、垃圾收集底层算法实现</span></a></h1><h2 id="三色标记" tabindex="-1"><a class="header-anchor" href="#三色标记"><span>三色标记</span></a></h2><p>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。</p><p>这里我们引入“三色标记”来给大家解释下，把gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</p><ul><li><strong>黑色：</strong> 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</li><li><strong>灰色：</strong> 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</li><li><strong>白色：</strong> 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</li></ul><p>​<img src="/myblog/assets/img/net-img-1658137551870-430cc481-25bc-452c-a28f-dce29a402648-20240222231144-prfqnoe.png" alt="image">​</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 垃圾收集算法细节之三色标记
 * 为了简化例子，代码写法可能不规范，请忽略
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreeColorRemark</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//开始做并发标记</span>
        <span class="token class-name">D</span> d <span class="token operator">=</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d<span class="token punctuation">;</span>   <span class="token comment">// 1.读</span>
        a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 2.写</span>
        a<span class="token punctuation">.</span>d <span class="token operator">=</span> d<span class="token punctuation">;</span>       <span class="token comment">// 3.写</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">D</span> d <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token class-name">C</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">D</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="多标-浮动垃圾" tabindex="-1"><a class="header-anchor" href="#多标-浮动垃圾"><span>多标-浮动垃圾</span></a></h3><p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。<br> 另外，<strong>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色</strong>，本轮不会进行清除。这部分对象在标记和回收期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p><h3 id="漏标-读写屏障" tabindex="-1"><a class="header-anchor" href="#漏标-读写屏障"><span>漏标-读写屏障</span></a></h3><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案：<strong>增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB）</strong> 。</p><ul><li><strong>增量更新：</strong> 就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， <strong>黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。</strong></li><li><strong>原始快照：</strong> 就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(<strong>目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)</strong></li></ul><p>以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。</p><h3 id="写屏障" tabindex="-1"><a class="header-anchor" href="#写屏障"><span>写屏障</span></a></h3><p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>/**
* @param field 某对象的成员变量，如 a.b.d 
* @param new_value 新值，如 null
*/
void oop_field_store(oop* field, oop new_value) { 
    *field = new_value; // 赋值操作
} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）:</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void oop_field_store(oop* field, oop new_value) {  
    pre_write_barrier(field);          // 写屏障-写前操作
    *field = new_value; 
    post_write_barrier(field, value);  // 写屏障-写后操作
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="写屏障实现satb" tabindex="-1"><a class="header-anchor" href="#写屏障实现satb"><span><strong>写屏障实现SATB</strong></span></a></h4><p>当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B<strong>原来成员变量的引用</strong>对象D记录下来：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void pre_write_barrier(oop* field) 
{ 
	oop old_value = *field; // 获取旧值 
	remark_set.add(old_value); // 记录原来的引用对象 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="写屏障实现增量更新" tabindex="-1"><a class="header-anchor" href="#写屏障实现增量更新"><span><strong>写屏障实现增量更新</strong></span></a></h4><p>当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A<strong>新的成员变量引用对象</strong>D记录下来</p><h3 id="读屏障" tabindex="-1"><a class="header-anchor" href="#读屏障"><span>读屏障</span></a></h3><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>oop oop_field_load(oop* field) {
    pre_load_barrier(field); // 读屏障-读取前操作
    return *field;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>读屏障是直接针对第一步：D d = a.b.d，当读取成员变量时，一律记录下来：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>void pre_load_barrier(oop* field) {  
    oop old_value = *field;
    remark_set.add(old_value); // 记录读取到的对象
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。</p><p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下 <strong>：</strong></p><ul><li><strong>CMS：写屏障 + 增量更新</strong></li><li><strong>G1，Shenandoah：写屏障 + SATB</strong></li><li><strong>ZGC：读屏障</strong></li></ul><p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p><p><strong>为什么G1用SATB？CMS用增量更新？</strong></p><p><strong>我的理解：</strong> SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p><h2 id="记忆集与卡表" tabindex="-1"><a class="header-anchor" href="#记忆集与卡表"><span>记忆集与卡表</span></a></h2><p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象(老年代的对象引用着新生代的对象)，这种如果又去对老年代再去扫描效率太低了。</p><p>为此，在新生代可以引入记录集（Remember Set）的数据结构（记录从<strong>非收集区[老年代]</strong> 到<strong>收集区[新生代]</strong> 的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。</p><p>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。</p><p>hotspot使用一种叫做“卡表”(Cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。</p><p>卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。</p><p>hotSpot使用的卡页是2^9大小，即512字节 <img src="https://cdn.nlark.com/yuque/0/2022/png/1295195/1658138144392-49d489bc-8d51-44a5-98df-e993c8cf91e6.png" alt="image">​</p><p>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.</p><p><strong>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</strong></p><h3 id="卡表的维护" tabindex="-1"><a class="header-anchor" href="#卡表的维护"><span><strong>卡表的维护</strong></span></a></h3><p>卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。</p><p>Hotspot使用写屏障维护卡表状态。</p></div><!--[--><!----><!--]--><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: xsyl06@qq.com">Wang</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/myblog/statudy/JVM/03-JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6.html" aria-label="03-JVM对象创建及内存分配机制"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->03-JVM对象创建及内存分配机制</div></a><a class="route-link nav-link next" href="/myblog/statudy/JVM/05-JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E4%B8%8B%EF%BC%89.html" aria-label="05-JVM的垃圾收集器（下）"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">05-JVM的垃圾收集器（下）<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">MIT Licensed | Copyright © 2024-present xsyl06</div></footer></div><!--]--><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/myblog/assets/app-DeNibpf_.js" defer></script>
  </body>
</html>
